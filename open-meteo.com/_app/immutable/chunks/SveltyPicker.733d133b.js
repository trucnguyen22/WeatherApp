import {
  s as $t,
  r as Pe,
  u as Zt,
  v as zt,
  w as Gt,
  h as vt,
  d as pt,
  j as dt,
  x as de,
  y as At,
  i as Et,
  z as xt,
  A as Oe,
  B as Le,
  C as Be,
  D as ue,
  E as Ie,
  f as Mt,
  g as wt,
  M as se,
  J as Mi,
  o as je,
  L as Di,
  p as ke,
  a as Ot,
  l as jt,
  F as pe,
  c as Lt,
  m as Nt,
  P as ze,
  H as Dt,
  a0 as Pi,
  n as Ut,
  e as ge,
  Z as Kt,
  I as xe,
  a1 as Ne,
  k as Ge,
  Q as he,
  N as Me,
  t as wi,
  a2 as fe,
  G as Si,
  a3 as Oi,
  _ as Te,
} from "./scheduler.f440829a.js";
import { h as Ue, u as Li } from "./LicenseSelector.1a7ea370.js";
import {
  S as te,
  i as ee,
  a as Pt,
  t as Bt,
  b as oe,
  d as ne,
  m as re,
  e as ae,
  g as Qt,
  c as Jt,
  j as Ce,
  k as Re,
  h as me,
} from "./index.2c544bcc.js";
import { a as Bi, b as Ye } from "./stores.226dc1e3.js";
import { c as Ii, g as Ci } from "./_commonjsHelpers.042e6b4d.js";
import { g as Fe } from "./spread.84d39b6c.js";
import { c as ji, f as le } from "./LocationSearch.b31bb8e5.js";
import { e as Ft, u as Ae, d as He, o as Ni } from "./each.27ca486b.js";
function Ri(q) {
  let k, T, y, A;
  const O = q[2].default,
    F = Pe(O, q, q[1], null);
  let G = [
      { xmlns: "http://www.w3.org/2000/svg" },
      { width: "16" },
      { height: "16" },
      { fill: "currentColor" },
      { viewBox: "0 0 16 16" },
      q[0],
    ],
    U = {};
  for (let H = 0; H < G.length; H += 1) U = Zt(U, G[H]);
  return {
    c() {
      (k = zt("svg")), F && F.c(), (T = zt("path")), (y = zt("path")), this.h();
    },
    l(H) {
      k = Gt(H, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        fill: !0,
        viewBox: !0,
      });
      var Y = vt(k);
      F && F.l(Y),
        (T = Gt(Y, "path", { "fill-rule": !0, d: !0 })),
        vt(T).forEach(pt),
        (y = Gt(Y, "path", { d: !0 })),
        vt(y).forEach(pt),
        Y.forEach(pt),
        this.h();
    },
    h() {
      dt(T, "fill-rule", "evenodd"),
        dt(
          T,
          "d",
          "M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"
        ),
        dt(
          y,
          "d",
          "M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"
        ),
        de(k, U),
        At(k, "bi", !0),
        At(k, "bi-arrow-clockwise", !0);
    },
    m(H, Y) {
      Et(H, k, Y), F && F.m(k, null), xt(k, T), xt(k, y), (A = !0);
    },
    p(H, [Y]) {
      F &&
        F.p &&
        (!A || Y & 2) &&
        Oe(F, O, H, H[1], A ? Be(O, H[1], Y, null) : Le(H[1]), null),
        de(
          k,
          (U = Fe(G, [
            { xmlns: "http://www.w3.org/2000/svg" },
            { width: "16" },
            { height: "16" },
            { fill: "currentColor" },
            { viewBox: "0 0 16 16" },
            Y & 1 && H[0],
          ]))
        ),
        At(k, "bi", !0),
        At(k, "bi-arrow-clockwise", !0);
    },
    i(H) {
      A || (Pt(F, H), (A = !0));
    },
    o(H) {
      Bt(F, H), (A = !1);
    },
    d(H) {
      H && pt(k), F && F.d(H);
    },
  };
}
function Fi(q, k, T) {
  const y = [];
  let A = ue(k, y),
    { $$slots: O = {}, $$scope: F } = k;
  return (
    (q.$$set = (G) => {
      (k = Zt(Zt({}, k), Ie(G))),
        T(0, (A = ue(k, y))),
        "$$scope" in G && T(1, (F = G.$$scope));
    }),
    [A, F, O]
  );
}
class Ai extends te {
  constructor(k) {
    super(), ee(this, k, Fi, Ri, $t, {});
  }
}
function Hi(q) {
  let k, T, y, A;
  const O = q[2].default,
    F = Pe(O, q, q[1], null);
  let G = [
      { xmlns: "http://www.w3.org/2000/svg" },
      { width: "16" },
      { height: "16" },
      { fill: "currentColor" },
      { viewBox: "0 0 16 16" },
      q[0],
    ],
    U = {};
  for (let H = 0; H < G.length; H += 1) U = Zt(U, G[H]);
  return {
    c() {
      (k = zt("svg")), F && F.c(), (T = zt("path")), (y = zt("path")), this.h();
    },
    l(H) {
      k = Gt(H, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        fill: !0,
        viewBox: !0,
      });
      var Y = vt(k);
      F && F.l(Y),
        (T = Gt(Y, "path", { d: !0 })),
        vt(T).forEach(pt),
        (y = Gt(Y, "path", { d: !0 })),
        vt(y).forEach(pt),
        Y.forEach(pt),
        this.h();
    },
    h() {
      dt(
        T,
        "d",
        "M7.938 2.016A.13.13 0 0 1 8.002 2a.13.13 0 0 1 .063.016.146.146 0 0 1 .054.057l6.857 11.667c.036.06.035.124.002.183a.163.163 0 0 1-.054.06.116.116 0 0 1-.066.017H1.146a.115.115 0 0 1-.066-.017.163.163 0 0 1-.054-.06.176.176 0 0 1 .002-.183L7.884 2.073a.147.147 0 0 1 .054-.057zm1.044-.45a1.13 1.13 0 0 0-1.96 0L.165 13.233c-.457.778.091 1.767.98 1.767h13.713c.889 0 1.438-.99.98-1.767L8.982 1.566z"
      ),
        dt(
          y,
          "d",
          "M7.002 12a1 1 0 1 1 2 0 1 1 0 0 1-2 0zM7.1 5.995a.905.905 0 1 1 1.8 0l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 5.995z"
        ),
        de(k, U),
        At(k, "bi", !0),
        At(k, "bi-exclamation-triangle", !0);
    },
    m(H, Y) {
      Et(H, k, Y), F && F.m(k, null), xt(k, T), xt(k, y), (A = !0);
    },
    p(H, [Y]) {
      F &&
        F.p &&
        (!A || Y & 2) &&
        Oe(F, O, H, H[1], A ? Be(O, H[1], Y, null) : Le(H[1]), null),
        de(
          k,
          (U = Fe(G, [
            { xmlns: "http://www.w3.org/2000/svg" },
            { width: "16" },
            { height: "16" },
            { fill: "currentColor" },
            { viewBox: "0 0 16 16" },
            Y & 1 && H[0],
          ]))
        ),
        At(k, "bi", !0),
        At(k, "bi-exclamation-triangle", !0);
    },
    i(H) {
      A || (Pt(F, H), (A = !0));
    },
    o(H) {
      Bt(F, H), (A = !1);
    },
    d(H) {
      H && pt(k), F && F.d(H);
    },
  };
}
function _i(q, k, T) {
  const y = [];
  let A = ue(k, y),
    { $$slots: O = {}, $$scope: F } = k;
  return (
    (q.$$set = (G) => {
      (k = Zt(Zt({}, k), Ie(G))),
        T(0, (A = ue(k, y))),
        "$$scope" in G && T(1, (F = G.$$scope));
    }),
    [A, F, O]
  );
}
class zi extends te {
  constructor(k) {
    super(), ee(this, k, _i, Hi, $t, {});
  }
}
function Gi(q) {
  let k, T, y, A;
  const O = q[2].default,
    F = Pe(O, q, q[1], null);
  let G = [
      { xmlns: "http://www.w3.org/2000/svg" },
      { width: "16" },
      { height: "16" },
      { fill: "currentColor" },
      { viewBox: "0 0 16 16" },
      q[0],
    ],
    U = {};
  for (let H = 0; H < G.length; H += 1) U = Zt(U, G[H]);
  return {
    c() {
      (k = zt("svg")), F && F.c(), (T = zt("path")), (y = zt("path")), this.h();
    },
    l(H) {
      k = Gt(H, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        fill: !0,
        viewBox: !0,
      });
      var Y = vt(k);
      F && F.l(Y),
        (T = Gt(Y, "path", { d: !0 })),
        vt(T).forEach(pt),
        (y = Gt(Y, "path", { d: !0 })),
        vt(y).forEach(pt),
        Y.forEach(pt),
        this.h();
    },
    h() {
      dt(
        T,
        "d",
        "M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"
      ),
        dt(
          y,
          "d",
          "m8.93 6.588-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588zM9 4.5a1 1 0 1 1-2 0 1 1 0 0 1 2 0z"
        ),
        de(k, U),
        At(k, "bi", !0),
        At(k, "bi-info-circle", !0);
    },
    m(H, Y) {
      Et(H, k, Y), F && F.m(k, null), xt(k, T), xt(k, y), (A = !0);
    },
    p(H, [Y]) {
      F &&
        F.p &&
        (!A || Y & 2) &&
        Oe(F, O, H, H[1], A ? Be(O, H[1], Y, null) : Le(H[1]), null),
        de(
          k,
          (U = Fe(G, [
            { xmlns: "http://www.w3.org/2000/svg" },
            { width: "16" },
            { height: "16" },
            { fill: "currentColor" },
            { viewBox: "0 0 16 16" },
            Y & 1 && H[0],
          ]))
        ),
        At(k, "bi", !0),
        At(k, "bi-info-circle", !0);
    },
    i(H) {
      A || (Pt(F, H), (A = !0));
    },
    o(H) {
      Bt(F, H), (A = !1);
    },
    d(H) {
      H && pt(k), F && F.d(H);
    },
  };
}
function Ui(q, k, T) {
  const y = [];
  let A = ue(k, y),
    { $$slots: O = {}, $$scope: F } = k;
  return (
    (q.$$set = (G) => {
      (k = Zt(Zt({}, k), Ie(G))),
        T(0, (A = ue(k, y))),
        "$$scope" in G && T(1, (F = G.$$scope));
    }),
    [A, F, O]
  );
}
class Yi extends te {
  constructor(k) {
    super(), ee(this, k, Ui, Gi, $t, {});
  }
}
var Ti = { exports: {} };
(function (q) {
  (function (k, T) {
    q.exports
      ? ((T.default = T), (q.exports = k.document ? T(k) : T))
      : (k.Highcharts && k.Highcharts.error(16, !0), (k.Highcharts = T(k)));
  })(typeof window < "u" ? window : Ii, function (k) {
    function T(A, O, F, G) {
      A.hasOwnProperty(O) ||
        ((A[O] = G.apply(null, F)),
        typeof CustomEvent == "function" &&
          k.dispatchEvent(
            new CustomEvent("HighchartsModuleLoaded", {
              detail: { path: O, module: A[O] },
            })
          ));
    }
    var y = {};
    return (
      T(y, "Core/Globals.js", [], function () {
        var A;
        return (
          (function (O) {
            (O.SVG_NS = "http://www.w3.org/2000/svg"),
              (O.product = "Highcharts"),
              (O.version = "11.1.0"),
              (O.win = typeof k < "u" ? k : {}),
              (O.doc = O.win.document),
              (O.svg =
                O.doc &&
                O.doc.createElementNS &&
                !!O.doc.createElementNS(O.SVG_NS, "svg").createSVGRect),
              (O.userAgent =
                (O.win.navigator && O.win.navigator.userAgent) || ""),
              (O.isChrome = O.userAgent.indexOf("Chrome") !== -1),
              (O.isFirefox = O.userAgent.indexOf("Firefox") !== -1),
              (O.isMS =
                /(edge|msie|trident)/i.test(O.userAgent) && !O.win.opera),
              (O.isSafari =
                !O.isChrome && O.userAgent.indexOf("Safari") !== -1),
              (O.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(
                O.userAgent
              )),
              (O.isWebKit = O.userAgent.indexOf("AppleWebKit") !== -1),
              (O.deg2rad = (2 * Math.PI) / 360),
              (O.hasBidiBug =
                O.isFirefox &&
                4 > parseInt(O.userAgent.split("Firefox/")[1], 10)),
              (O.hasTouch = !!O.win.TouchEvent),
              (O.marginNames = [
                "plotTop",
                "marginRight",
                "marginBottom",
                "plotLeft",
              ]),
              (O.noop = function () {}),
              (O.supportsPassiveEvents = (function () {
                let F = !1;
                if (!O.isMS) {
                  const G = Object.defineProperty({}, "passive", {
                    get: function () {
                      F = !0;
                    },
                  });
                  O.win.addEventListener &&
                    O.win.removeEventListener &&
                    (O.win.addEventListener("testPassive", O.noop, G),
                    O.win.removeEventListener("testPassive", O.noop, G));
                }
                return F;
              })()),
              (O.charts = []),
              (O.dateFormats = {}),
              (O.seriesTypes = {}),
              (O.symbolSizes = {}),
              (O.chartCount = 0);
          })(A || (A = {})),
          A
        );
      }),
      T(y, "Core/Utilities.js", [y["Core/Globals.js"]], function (A) {
        function O(t, e, s, a) {
          const b = e ? "Highcharts error" : "Highcharts warning";
          t === 32 && (t = `${b}: Deprecated member`);
          const r = N(t);
          let w = r
            ? `${b} #${t}: www.highcharts.com/errors/${t}/`
            : t.toString();
          if (typeof a < "u") {
            let L = "";
            r && (w += "?"),
              C(a, function (I, V) {
                (L += `
 - ${V}: ${I}`),
                  r && (w += encodeURI(V) + "=" + encodeURI(I));
              }),
              (w += L);
          }
          j(
            A,
            "displayError",
            { chart: s, code: t, message: w, params: a },
            function () {
              if (e) throw Error(w);
              v.console && O.messages.indexOf(w) === -1 && console.warn(w);
            }
          ),
            O.messages.push(w);
        }
        function F(t, e) {
          return parseInt(t, e || 10);
        }
        function G(t) {
          return typeof t == "string";
        }
        function U(t) {
          return (
            (t = Object.prototype.toString.call(t)),
            t === "[object Array]" || t === "[object Array Iterator]"
          );
        }
        function H(t, e) {
          return !!t && typeof t == "object" && (!e || !U(t));
        }
        function Y(t) {
          return H(t) && typeof t.nodeType == "number";
        }
        function S(t) {
          const e = t && t.constructor;
          return !(!H(t, !0) || Y(t) || !e || !e.name || e.name === "Object");
        }
        function N(t) {
          return typeof t == "number" && !isNaN(t) && 1 / 0 > t && -1 / 0 < t;
        }
        function D(t) {
          return typeof t < "u" && t !== null;
        }
        function c(t, e, s) {
          const a = G(e) && !D(s);
          let b;
          const r = (w, L) => {
            D(w)
              ? t.setAttribute(L, w)
              : a
              ? (b = t.getAttribute(L)) ||
                L !== "class" ||
                (b = t.getAttribute(L + "Name"))
              : t.removeAttribute(L);
          };
          return G(e) ? r(s, e) : C(e, r), b;
        }
        function p(t) {
          return U(t) ? t : [t];
        }
        function f(t, e) {
          let s;
          t || (t = {});
          for (s in e) t[s] = e[s];
          return t;
        }
        function u() {
          const t = arguments,
            e = t.length;
          for (let s = 0; s < e; s++) {
            const a = t[s];
            if (typeof a < "u" && a !== null) return a;
          }
        }
        function n(t, e) {
          A.isMS &&
            !A.svg &&
            e &&
            D(e.opacity) &&
            (e.filter = `alpha(opacity=${100 * e.opacity})`),
            f(t.style, e);
        }
        function d(t) {
          return Math.pow(10, Math.floor(Math.log(t) / Math.LN10));
        }
        function g(t, e) {
          return 1e14 < t ? t : parseFloat(t.toPrecision(e || 14));
        }
        function M(t, e, s) {
          let a;
          return e === "width"
            ? ((e = Math.min(t.offsetWidth, t.scrollWidth)),
              (s = t.getBoundingClientRect && t.getBoundingClientRect().width),
              s < e && s >= e - 1 && (e = Math.floor(s)),
              Math.max(
                0,
                e -
                  (M(t, "padding-left", !0) || 0) -
                  (M(t, "padding-right", !0) || 0)
              ))
            : e === "height"
            ? Math.max(
                0,
                Math.min(t.offsetHeight, t.scrollHeight) -
                  (M(t, "padding-top", !0) || 0) -
                  (M(t, "padding-bottom", !0) || 0)
              )
            : ((t = v.getComputedStyle(t, void 0)) &&
                ((a = t.getPropertyValue(e)),
                u(s, e !== "opacity") && (a = F(a))),
              a);
        }
        function C(t, e, s) {
          for (const a in t)
            Object.hasOwnProperty.call(t, a) && e.call(s || t[a], t[a], a, t);
        }
        function P(t, e, s) {
          function a(w, L) {
            const I = t.removeEventListener;
            I && I.call(t, w, L, !1);
          }
          function b(w) {
            let L, I;
            t.nodeName &&
              (e ? ((L = {}), (L[e] = !0)) : (L = w),
              C(L, function (V, B) {
                if (w[B]) for (I = w[B].length; I--; ) a(B, w[B][I].fn);
              }));
          }
          var r = (typeof t == "function" && t.prototype) || t;
          if (Object.hasOwnProperty.call(r, "hcEvents")) {
            const w = r.hcEvents;
            e
              ? ((r = w[e] || []),
                s
                  ? ((w[e] = r.filter(function (L) {
                      return s !== L.fn;
                    })),
                    a(e, s))
                  : (b(w), (w[e] = [])))
              : (b(w), delete r.hcEvents);
          }
        }
        function j(t, e, s, a) {
          if (
            ((s = s || {}),
            h.createEvent && (t.dispatchEvent || (t.fireEvent && t !== A)))
          ) {
            var b = h.createEvent("Events");
            b.initEvent(e, !0, !0),
              (s = f(b, s)),
              t.dispatchEvent ? t.dispatchEvent(s) : t.fireEvent(e, s);
          } else if (t.hcEvents) {
            s.target ||
              f(s, {
                preventDefault: function () {
                  s.defaultPrevented = !0;
                },
                target: t,
                type: e,
              }),
              (b = []);
            let r = t,
              w = !1;
            for (; r.hcEvents; )
              Object.hasOwnProperty.call(r, "hcEvents") &&
                r.hcEvents[e] &&
                (b.length && (w = !0), b.unshift.apply(b, r.hcEvents[e])),
                (r = Object.getPrototypeOf(r));
            w && b.sort((L, I) => L.order - I.order),
              b.forEach((L) => {
                L.fn.call(t, s) === !1 && s.preventDefault();
              });
          }
          a && !s.defaultPrevented && a.call(t, s);
        }
        const { charts: m, doc: h, win: v } = A;
        ((O || (O = {})).messages = []),
          (Math.easeInOutSine = function (t) {
            return -0.5 * (Math.cos(Math.PI * t) - 1);
          });
        var l = Array.prototype.find
          ? function (t, e) {
              return t.find(e);
            }
          : function (t, e) {
              let s;
              const a = t.length;
              for (s = 0; s < a; s++) if (e(t[s], s)) return t[s];
            };
        C(
          {
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some",
          },
          function (t, e) {
            A[e] = function (s) {
              return (
                O(32, !1, void 0, { [`Highcharts.${e}`]: `use Array.${t}` }),
                Array.prototype[t].apply(s, [].slice.call(arguments, 1))
              );
            };
          }
        );
        let o;
        const i = (function () {
          const t = Math.random().toString(36).substring(2, 9) + "-";
          let e = 0;
          return function () {
            return "highcharts-" + (o ? "" : t) + e++;
          };
        })();
        return (
          v.jQuery &&
            (v.jQuery.fn.highcharts = function () {
              const t = [].slice.call(arguments);
              if (this[0])
                return t[0]
                  ? (new A[G(t[0]) ? t.shift() : "Chart"](this[0], t[0], t[1]),
                    this)
                  : m[c(this[0], "data-highcharts-chart")];
            }),
          (l = {
            addEvent: function (t, e, s, a = {}) {
              var b = (typeof t == "function" && t.prototype) || t;
              Object.hasOwnProperty.call(b, "hcEvents") || (b.hcEvents = {}),
                (b = b.hcEvents),
                A.Point &&
                  t instanceof A.Point &&
                  t.series &&
                  t.series.chart &&
                  (t.series.chart.runTrackerClick = !0);
              const r = t.addEventListener;
              return (
                r &&
                  r.call(
                    t,
                    e,
                    s,
                    A.supportsPassiveEvents
                      ? {
                          passive:
                            a.passive === void 0
                              ? e.indexOf("touch") !== -1
                              : a.passive,
                          capture: !1,
                        }
                      : !1
                  ),
                b[e] || (b[e] = []),
                b[e].push({
                  fn: s,
                  order: typeof a.order == "number" ? a.order : 1 / 0,
                }),
                b[e].sort((w, L) => w.order - L.order),
                function () {
                  P(t, e, s);
                }
              );
            },
            arrayMax: function (t) {
              let e = t.length,
                s = t[0];
              for (; e--; ) t[e] > s && (s = t[e]);
              return s;
            },
            arrayMin: function (t) {
              let e = t.length,
                s = t[0];
              for (; e--; ) t[e] < s && (s = t[e]);
              return s;
            },
            attr: c,
            clamp: function (t, e, s) {
              return t > e ? (t < s ? t : s) : e;
            },
            clearTimeout: function (t) {
              D(t) && clearTimeout(t);
            },
            correctFloat: g,
            createElement: function (t, e, s, a, b) {
              return (
                (t = h.createElement(t)),
                e && f(t, e),
                b && n(t, { padding: "0", border: "none", margin: "0" }),
                s && n(t, s),
                a && a.appendChild(t),
                t
              );
            },
            css: n,
            defined: D,
            destroyObjectProperties: function (t, e) {
              C(t, function (s, a) {
                s && s !== e && s.destroy && s.destroy(), delete t[a];
              });
            },
            diffObjects: function (t, e, s, a) {
              function b(w, L, I, V) {
                const B = s ? L : w;
                C(w, function (x, R) {
                  if (!V && a && -1 < a.indexOf(R) && L[R]) {
                    (x = p(x)), (I[R] = []);
                    for (let W = 0; W < Math.max(x.length, L[R].length); W++)
                      L[R][W] &&
                        (x[W] === void 0
                          ? (I[R][W] = L[R][W])
                          : ((I[R][W] = {}), b(x[W], L[R][W], I[R][W], V + 1)));
                  } else H(x, !0) && !x.nodeType ? ((I[R] = U(x) ? [] : {}), b(x, L[R] || {}, I[R], V + 1), Object.keys(I[R]).length !== 0 || (R === "colorAxis" && V === 0) || delete I[R]) : (w[R] !== L[R] || (R in w && !(R in L))) && (I[R] = B[R]);
                });
              }
              const r = {};
              return b(t, e, r, 0), r;
            },
            discardElement: function (t) {
              t && t.parentElement && t.parentElement.removeChild(t);
            },
            erase: function (t, e) {
              let s = t.length;
              for (; s--; )
                if (t[s] === e) {
                  t.splice(s, 1);
                  break;
                }
            },
            error: O,
            extend: f,
            extendClass: function (t, e) {
              const s = function () {};
              return (s.prototype = new t()), f(s.prototype, e), s;
            },
            find: l,
            fireEvent: j,
            getClosestDistance: function (t, e) {
              const s = !e;
              let a, b, r;
              return (
                t.forEach((w) => {
                  if (1 < w.length)
                    for (r = w.length - 1; 0 < r; r--)
                      (b = w[r] - w[r - 1]),
                        0 > b && !s
                          ? (e == null || e(), (e = void 0))
                          : b && (typeof a > "u" || b < a) && (a = b);
                }),
                a
              );
            },
            getMagnitude: d,
            getNestedProperty: function (t, e) {
              for (t = t.split("."); t.length && D(e); ) {
                const s = t.shift();
                if (typeof s > "u" || s === "__proto__") return;
                if (s === "this") {
                  let a;
                  return H(e) && (a = e["@this"]), a ?? e;
                }
                if (
                  ((e = e[s]),
                  !D(e) ||
                    typeof e == "function" ||
                    typeof e.nodeType == "number" ||
                    e === v)
                )
                  return;
              }
              return e;
            },
            getStyle: M,
            inArray: function (t, e, s) {
              return (
                O(32, !1, void 0, {
                  "Highcharts.inArray": "use Array.indexOf",
                }),
                e.indexOf(t, s)
              );
            },
            insertItem: function (t, e) {
              const s = t.options.index,
                a = e.length;
              let b;
              for (b = t.options.isInternal ? a : 0; b < a + 1; b++)
                if (
                  !e[b] ||
                  (N(s) && s < u(e[b].options.index, e[b]._i)) ||
                  e[b].options.isInternal
                ) {
                  e.splice(b, 0, t);
                  break;
                }
              return b;
            },
            isArray: U,
            isClass: S,
            isDOMElement: Y,
            isFunction: function (t) {
              return typeof t == "function";
            },
            isNumber: N,
            isObject: H,
            isString: G,
            keys: function (t) {
              return (
                O(32, !1, void 0, { "Highcharts.keys": "use Object.keys" }),
                Object.keys(t)
              );
            },
            merge: function () {
              let t,
                e = arguments,
                s = {};
              const a = function (r, w) {
                return (
                  typeof r != "object" && (r = {}),
                  C(w, function (L, I) {
                    I !== "__proto__" &&
                      I !== "constructor" &&
                      (!H(L, !0) || S(L) || Y(L)
                        ? (r[I] = w[I])
                        : (r[I] = a(r[I] || {}, L)));
                  }),
                  r
                );
              };
              e[0] === !0 &&
                ((s = e[1]), (e = Array.prototype.slice.call(e, 2)));
              const b = e.length;
              for (t = 0; t < b; t++) s = a(s, e[t]);
              return s;
            },
            normalizeTickInterval: function (t, e, s, a, b) {
              let r = t;
              s = u(s, d(t));
              const w = t / s;
              for (
                e ||
                  ((e = b
                    ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]
                    : [1, 2, 2.5, 5, 10]),
                  a === !1 &&
                    (s === 1
                      ? (e = e.filter(function (L) {
                          return L % 1 === 0;
                        }))
                      : 0.1 >= s && (e = [1 / s]))),
                  a = 0;
                a < e.length &&
                ((r = e[a]),
                !(
                  (b && r * s >= t) ||
                  (!b && w <= (e[a] + (e[a + 1] || e[a])) / 2)
                ));
                a++
              );
              return (r = g(r * s, -Math.round(Math.log(0.001) / Math.LN10)));
            },
            objectEach: C,
            offset: function (t) {
              const e = h.documentElement;
              return (
                (t =
                  t.parentElement || t.parentNode
                    ? t.getBoundingClientRect()
                    : { top: 0, left: 0, width: 0, height: 0 }),
                {
                  top:
                    t.top + (v.pageYOffset || e.scrollTop) - (e.clientTop || 0),
                  left:
                    t.left +
                    (v.pageXOffset || e.scrollLeft) -
                    (e.clientLeft || 0),
                  width: t.width,
                  height: t.height,
                }
              );
            },
            pad: function (t, e, s) {
              return (
                Array((e || 2) + 1 - String(t).replace("-", "").length).join(
                  s || "0"
                ) + t
              );
            },
            pick: u,
            pInt: F,
            pushUnique: function (t, e) {
              return 0 > t.indexOf(e) && !!t.push(e);
            },
            relativeLength: function (t, e, s) {
              return /%$/.test(t)
                ? (e * parseFloat(t)) / 100 + (s || 0)
                : parseFloat(t);
            },
            removeEvent: P,
            splat: p,
            stableSort: function (t, e) {
              const s = t.length;
              let a, b;
              for (b = 0; b < s; b++) t[b].safeI = b;
              for (
                t.sort(function (r, w) {
                  return (a = e(r, w)), a === 0 ? r.safeI - w.safeI : a;
                }),
                  b = 0;
                b < s;
                b++
              )
                delete t[b].safeI;
            },
            syncTimeout: function (t, e, s) {
              return 0 < e ? setTimeout(t, e, s) : (t.call(0, s), -1);
            },
            timeUnits: {
              millisecond: 1,
              second: 1e3,
              minute: 6e4,
              hour: 36e5,
              day: 864e5,
              week: 6048e5,
              month: 24192e5,
              year: 314496e5,
            },
            uniqueKey: i,
            useSerialIds: function (t) {
              return (o = u(t, o));
            },
            wrap: function (t, e, s) {
              const a = t[e];
              t[e] = function () {
                const b = arguments,
                  r = this;
                return s.apply(
                  this,
                  [
                    function () {
                      return a.apply(r, arguments.length ? arguments : b);
                    },
                  ].concat([].slice.call(arguments))
                );
              };
            },
          }),
          l
        );
      }),
      T(y, "Core/Chart/ChartDefaults.js", [], function () {
        return {
          alignThresholds: !1,
          panning: { enabled: !1, type: "x" },
          styledMode: !1,
          borderRadius: 0,
          colorCount: 10,
          allowMutatingData: !0,
          ignoreHiddenSeries: !0,
          spacing: [10, 10, 15, 10],
          resetZoomButton: {
            theme: { zIndex: 6 },
            position: { align: "right", x: -10, y: 10 },
          },
          reflow: !0,
          type: "line",
          zooming: {
            singleTouch: !1,
            resetButton: {
              theme: { zIndex: 6 },
              position: { align: "right", x: -10, y: 10 },
            },
          },
          width: null,
          height: null,
          borderColor: "#334eff",
          backgroundColor: "#ffffff",
          plotBorderColor: "#cccccc",
        };
      }),
      T(
        y,
        "Core/Color/Color.js",
        [y["Core/Globals.js"], y["Core/Utilities.js"]],
        function (A, O) {
          const { isNumber: F, merge: G, pInt: U } = O;
          class H {
            static parse(S) {
              return S ? new H(S) : H.None;
            }
            constructor(S) {
              (this.rgba = [NaN, NaN, NaN, NaN]), (this.input = S);
              const N = A.Color;
              if (N && N !== H) return new N(S);
              this.init(S);
            }
            init(S) {
              let N, D;
              if (typeof S == "object" && typeof S.stops < "u")
                this.stops = S.stops.map((f) => new H(f[1]));
              else if (typeof S == "string") {
                if (
                  ((this.input = S = H.names[S.toLowerCase()] || S),
                  S.charAt(0) === "#")
                ) {
                  var c = S.length,
                    p = parseInt(S.substr(1), 16);
                  c === 7
                    ? (N = [(p & 16711680) >> 16, (p & 65280) >> 8, p & 255, 1])
                    : c === 4 &&
                      (N = [
                        ((p & 3840) >> 4) | ((p & 3840) >> 8),
                        ((p & 240) >> 4) | (p & 240),
                        ((p & 15) << 4) | (p & 15),
                        1,
                      ]);
                }
                if (!N)
                  for (p = H.parsers.length; p-- && !N; )
                    (D = H.parsers[p]),
                      (c = D.regex.exec(S)) && (N = D.parse(c));
              }
              N && (this.rgba = N);
            }
            get(S) {
              const N = this.input,
                D = this.rgba;
              if (typeof N == "object" && typeof this.stops < "u") {
                const c = G(N);
                return (
                  (c.stops = [].slice.call(c.stops)),
                  this.stops.forEach((p, f) => {
                    c.stops[f] = [c.stops[f][0], p.get(S)];
                  }),
                  c
                );
              }
              return D && F(D[0])
                ? S === "rgb" || (!S && D[3] === 1)
                  ? "rgb(" + D[0] + "," + D[1] + "," + D[2] + ")"
                  : S === "a"
                  ? `${D[3]}`
                  : "rgba(" + D.join(",") + ")"
                : N;
            }
            brighten(S) {
              const N = this.rgba;
              if (this.stops)
                this.stops.forEach(function (D) {
                  D.brighten(S);
                });
              else if (F(S) && S !== 0)
                for (let D = 0; 3 > D; D++)
                  (N[D] += U(255 * S)),
                    0 > N[D] && (N[D] = 0),
                    255 < N[D] && (N[D] = 255);
              return this;
            }
            setOpacity(S) {
              return (this.rgba[3] = S), this;
            }
            tweenTo(S, N) {
              const D = this.rgba,
                c = S.rgba;
              return !F(D[0]) || !F(c[0])
                ? S.input || "none"
                : ((S = c[3] !== 1 || D[3] !== 1),
                  (S ? "rgba(" : "rgb(") +
                    Math.round(c[0] + (D[0] - c[0]) * (1 - N)) +
                    "," +
                    Math.round(c[1] + (D[1] - c[1]) * (1 - N)) +
                    "," +
                    Math.round(c[2] + (D[2] - c[2]) * (1 - N)) +
                    (S ? "," + (c[3] + (D[3] - c[3]) * (1 - N)) : "") +
                    ")");
            }
          }
          return (
            (H.names = { white: "#ffffff", black: "#000000" }),
            (H.parsers = [
              {
                regex:
                  /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function (Y) {
                  return [U(Y[1]), U(Y[2]), U(Y[3]), parseFloat(Y[4], 10)];
                },
              },
              {
                regex:
                  /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function (Y) {
                  return [U(Y[1]), U(Y[2]), U(Y[3]), 1];
                },
              },
            ]),
            (H.None = new H("")),
            H
          );
        }
      ),
      T(y, "Core/Color/Palettes.js", [], function () {
        return {
          colors:
            "#2caffe #544fc5 #00e272 #fe6a35 #6b8abc #d568fb #2ee0ca #fa4b42 #feb56a #91e8e1".split(
              " "
            ),
        };
      }),
      T(
        y,
        "Core/Time.js",
        [y["Core/Globals.js"], y["Core/Utilities.js"]],
        function (A, O) {
          const { win: F } = A,
            {
              defined: G,
              error: U,
              extend: H,
              isObject: Y,
              merge: S,
              objectEach: N,
              pad: D,
              pick: c,
              splat: p,
              timeUnits: f,
            } = O,
            u =
              A.isSafari &&
              F.Intl &&
              F.Intl.DateTimeFormat.prototype.formatRange,
            n =
              A.isSafari &&
              F.Intl &&
              !F.Intl.DateTimeFormat.prototype.formatRange;
          class d {
            constructor(M) {
              (this.options = {}),
                (this.variableTimezone = this.useUTC = !1),
                (this.Date = F.Date),
                (this.getTimezoneOffset = this.timezoneOffsetFunction()),
                this.update(M);
            }
            get(M, C) {
              if (this.variableTimezone || this.timezoneOffset) {
                const P = C.getTime(),
                  j = P - this.getTimezoneOffset(C);
                return C.setTime(j), (M = C["getUTC" + M]()), C.setTime(P), M;
              }
              return this.useUTC ? C["getUTC" + M]() : C["get" + M]();
            }
            set(M, C, P) {
              if (this.variableTimezone || this.timezoneOffset) {
                if (
                  M === "Milliseconds" ||
                  M === "Seconds" ||
                  (M === "Minutes" && this.getTimezoneOffset(C) % 36e5 === 0)
                )
                  return C["setUTC" + M](P);
                var j = this.getTimezoneOffset(C);
                return (
                  (j = C.getTime() - j),
                  C.setTime(j),
                  C["setUTC" + M](P),
                  (M = this.getTimezoneOffset(C)),
                  (j = C.getTime() + M),
                  C.setTime(j)
                );
              }
              return this.useUTC || (u && M === "FullYear")
                ? C["setUTC" + M](P)
                : C["set" + M](P);
            }
            update(M = {}) {
              const C = c(M.useUTC, !0);
              (this.options = M = S(!0, this.options, M)),
                (this.Date = M.Date || F.Date || Date),
                (this.timezoneOffset =
                  ((this.useUTC = C) && M.timezoneOffset) || void 0),
                (this.getTimezoneOffset = this.timezoneOffsetFunction()),
                (this.variableTimezone =
                  C && !(!M.getTimezoneOffset && !M.timezone));
            }
            makeTime(M, C, P, j, m, h) {
              let v, l, o;
              return (
                this.useUTC
                  ? ((v = this.Date.UTC.apply(0, arguments)),
                    (l = this.getTimezoneOffset(v)),
                    (v += l),
                    (o = this.getTimezoneOffset(v)),
                    l !== o
                      ? (v += o - l)
                      : l - 36e5 !== this.getTimezoneOffset(v - 36e5) ||
                        n ||
                        (v -= 36e5))
                  : (v = new this.Date(
                      M,
                      C,
                      c(P, 1),
                      c(j, 0),
                      c(m, 0),
                      c(h, 0)
                    ).getTime()),
                v
              );
            }
            timezoneOffsetFunction() {
              const M = this,
                C = this.options,
                P = C.getTimezoneOffset,
                j = C.moment || F.moment;
              if (!this.useUTC)
                return function (m) {
                  return 6e4 * new Date(m.toString()).getTimezoneOffset();
                };
              if (C.timezone) {
                if (j)
                  return function (m) {
                    return 6e4 * -j.tz(m, C.timezone).utcOffset();
                  };
                U(25);
              }
              return this.useUTC && P
                ? function (m) {
                    return 6e4 * P(m.valueOf());
                  }
                : function () {
                    return 6e4 * (M.timezoneOffset || 0);
                  };
            }
            dateFormat(M, C, P) {
              if (!G(C) || isNaN(C))
                return (
                  (A.defaultOptions.lang &&
                    A.defaultOptions.lang.invalidDate) ||
                  ""
                );
              M = c(M, "%Y-%m-%d %H:%M:%S");
              const j = this;
              var m = new this.Date(C);
              const h = this.get("Hours", m),
                v = this.get("Day", m),
                l = this.get("Date", m),
                o = this.get("Month", m),
                i = this.get("FullYear", m),
                t = A.defaultOptions.lang,
                e = t && t.weekdays,
                s = t && t.shortWeekdays;
              return (
                (m = H(
                  {
                    a: s ? s[v] : e[v].substr(0, 3),
                    A: e[v],
                    d: D(l),
                    e: D(l, 2, " "),
                    w: v,
                    b: t.shortMonths[o],
                    B: t.months[o],
                    m: D(o + 1),
                    o: o + 1,
                    y: i.toString().substr(2, 2),
                    Y: i,
                    H: D(h),
                    k: h,
                    I: D(h % 12 || 12),
                    l: h % 12 || 12,
                    M: D(this.get("Minutes", m)),
                    p: 12 > h ? "AM" : "PM",
                    P: 12 > h ? "am" : "pm",
                    S: D(m.getSeconds()),
                    L: D(Math.floor(C % 1e3), 3),
                  },
                  A.dateFormats
                )),
                N(m, function (a, b) {
                  for (; M.indexOf("%" + b) !== -1; )
                    M = M.replace(
                      "%" + b,
                      typeof a == "function" ? a.call(j, C) : a
                    );
                }),
                P ? M.substr(0, 1).toUpperCase() + M.substr(1) : M
              );
            }
            resolveDTLFormat(M) {
              return Y(M, !0)
                ? M
                : ((M = p(M)), { main: M[0], from: M[1], to: M[2] });
            }
            getTimeTicks(M, C, P, j) {
              const m = this,
                h = [],
                v = {};
              var l = new m.Date(C);
              const o = M.unitRange,
                i = M.count || 1;
              let t;
              if (((j = c(j, 1)), G(C))) {
                if (
                  (m.set(
                    "Milliseconds",
                    l,
                    o >= f.second
                      ? 0
                      : i * Math.floor(m.get("Milliseconds", l) / i)
                  ),
                  o >= f.second &&
                    m.set(
                      "Seconds",
                      l,
                      o >= f.minute
                        ? 0
                        : i * Math.floor(m.get("Seconds", l) / i)
                    ),
                  o >= f.minute &&
                    m.set(
                      "Minutes",
                      l,
                      o >= f.hour ? 0 : i * Math.floor(m.get("Minutes", l) / i)
                    ),
                  o >= f.hour &&
                    m.set(
                      "Hours",
                      l,
                      o >= f.day ? 0 : i * Math.floor(m.get("Hours", l) / i)
                    ),
                  o >= f.day &&
                    m.set(
                      "Date",
                      l,
                      o >= f.month
                        ? 1
                        : Math.max(1, i * Math.floor(m.get("Date", l) / i))
                    ),
                  o >= f.month)
                ) {
                  m.set(
                    "Month",
                    l,
                    o >= f.year ? 0 : i * Math.floor(m.get("Month", l) / i)
                  );
                  var e = m.get("FullYear", l);
                }
                o >= f.year && m.set("FullYear", l, e - (e % i)),
                  o === f.week &&
                    ((e = m.get("Day", l)),
                    m.set(
                      "Date",
                      l,
                      m.get("Date", l) - e + j + (e < j ? -7 : 0)
                    )),
                  (e = m.get("FullYear", l)),
                  (j = m.get("Month", l));
                const s = m.get("Date", l),
                  a = m.get("Hours", l);
                for (
                  C = l.getTime(),
                    (!m.variableTimezone && m.useUTC) ||
                      !G(P) ||
                      (t =
                        P - C > 4 * f.month ||
                        m.getTimezoneOffset(C) !== m.getTimezoneOffset(P)),
                    C = l.getTime(),
                    l = 1;
                  C < P;

                )
                  h.push(C),
                    (C =
                      o === f.year
                        ? m.makeTime(e + l * i, 0)
                        : o === f.month
                        ? m.makeTime(e, j + l * i)
                        : !t || (o !== f.day && o !== f.week)
                        ? t && o === f.hour && 1 < i
                          ? m.makeTime(e, j, s, a + l * i)
                          : C + o * i
                        : m.makeTime(e, j, s + l * i * (o === f.day ? 1 : 7))),
                    l++;
                h.push(C),
                  o <= f.hour &&
                    1e4 > h.length &&
                    h.forEach(function (b) {
                      b % 18e5 === 0 &&
                        m.dateFormat("%H%M%S%L", b) === "000000000" &&
                        (v[b] = "day");
                    });
              }
              return (h.info = H(M, { higherRanks: v, totalRange: o * i })), h;
            }
            getDateFormat(M, C, P, j) {
              const m = this.dateFormat("%m-%d %H:%M:%S.%L", C),
                h = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 };
              let v,
                l = "millisecond";
              for (v in f) {
                if (
                  M === f.week &&
                  +this.dateFormat("%w", C) === P &&
                  m.substr(6) === "00:00:00.000"
                ) {
                  v = "week";
                  break;
                }
                if (f[v] > M) {
                  v = l;
                  break;
                }
                if (
                  h[v] &&
                  m.substr(h[v]) !== "01-01 00:00:00.000".substr(h[v])
                )
                  break;
                v !== "week" && (l = v);
              }
              return this.resolveDTLFormat(j[v]).main;
            }
          }
          return d;
        }
      ),
      T(
        y,
        "Core/Defaults.js",
        [
          y["Core/Chart/ChartDefaults.js"],
          y["Core/Color/Color.js"],
          y["Core/Globals.js"],
          y["Core/Color/Palettes.js"],
          y["Core/Time.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H) {
          const { isTouchDevice: Y, svg: S } = F,
            { merge: N } = H,
            D = {
              colors: G.colors,
              symbols: [
                "circle",
                "diamond",
                "square",
                "triangle",
                "triangle-down",
              ],
              lang: {
                loading: "Loading...",
                months:
                  "January February March April May June July August September October November December".split(
                    " "
                  ),
                shortMonths:
                  "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                weekdays:
                  "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(
                    " "
                  ),
                decimalPoint: ".",
                numericSymbols: "kMGTPE".split(""),
                resetZoom: "Reset zoom",
                resetZoomTitle: "Reset zoom level 1:1",
                thousandsSep: " ",
              },
              global: {},
              time: {
                Date: void 0,
                getTimezoneOffset: void 0,
                timezone: void 0,
                timezoneOffset: 0,
                useUTC: !0,
              },
              chart: A,
              title: {
                style: { color: "#333333", fontWeight: "bold" },
                text: "Chart title",
                align: "center",
                margin: 15,
                widthAdjust: -44,
              },
              subtitle: {
                style: { color: "#666666", fontSize: "0.8em" },
                text: "",
                align: "center",
                widthAdjust: -44,
              },
              caption: {
                margin: 15,
                style: { color: "#666666", fontSize: "0.8em" },
                text: "",
                align: "left",
                verticalAlign: "bottom",
              },
              plotOptions: {},
              legend: {
                enabled: !0,
                align: "center",
                alignColumns: !0,
                className: "highcharts-no-tooltip",
                layout: "horizontal",
                itemMarginBottom: 2,
                itemMarginTop: 2,
                labelFormatter: function () {
                  return this.name;
                },
                borderColor: "#999999",
                borderRadius: 0,
                navigation: {
                  style: { fontSize: "0.8em" },
                  activeColor: "#0022ff",
                  inactiveColor: "#cccccc",
                },
                itemStyle: {
                  color: "#333333",
                  cursor: "pointer",
                  fontSize: "0.8em",
                  textDecoration: "none",
                  textOverflow: "ellipsis",
                },
                itemHoverStyle: { color: "#000000" },
                itemHiddenStyle: {
                  color: "#666666",
                  textDecoration: "line-through",
                },
                shadow: !1,
                itemCheckboxStyle: {
                  position: "absolute",
                  width: "13px",
                  height: "13px",
                },
                squareSymbol: !0,
                symbolPadding: 5,
                verticalAlign: "bottom",
                x: 0,
                y: 0,
                title: { style: { fontSize: "0.8em", fontWeight: "bold" } },
              },
              loading: {
                labelStyle: {
                  fontWeight: "bold",
                  position: "relative",
                  top: "45%",
                },
                style: {
                  position: "absolute",
                  backgroundColor: "#ffffff",
                  opacity: 0.5,
                  textAlign: "center",
                },
              },
              tooltip: {
                enabled: !0,
                animation: S,
                borderRadius: 3,
                dateTimeLabelFormats: {
                  millisecond: "%A, %e %b, %H:%M:%S.%L",
                  second: "%A, %e %b, %H:%M:%S",
                  minute: "%A, %e %b, %H:%M",
                  hour: "%A, %e %b, %H:%M",
                  day: "%A, %e %b %Y",
                  week: "Week from %A, %e %b %Y",
                  month: "%B %Y",
                  year: "%Y",
                },
                footerFormat: "",
                headerShape: "callout",
                hideDelay: 500,
                padding: 8,
                shape: "callout",
                shared: !1,
                snap: Y ? 25 : 10,
                headerFormat:
                  '<span style="font-size: 0.8em">{point.key}</span><br/>',
                pointFormat:
                  '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>',
                backgroundColor: "#ffffff",
                borderWidth: void 0,
                shadow: !0,
                stickOnContact: !1,
                style: {
                  color: "#333333",
                  cursor: "default",
                  fontSize: "0.8em",
                },
                useHTML: !1,
              },
              credits: {
                enabled: !0,
                href: "https://www.highcharts.com?credits",
                position: {
                  align: "right",
                  x: -10,
                  verticalAlign: "bottom",
                  y: -5,
                },
                style: {
                  cursor: "pointer",
                  color: "#999999",
                  fontSize: "0.6em",
                },
                text: "Highcharts.com",
              },
            };
          D.chart.styledMode = !1;
          const c = new U(D.time);
          return (
            (A = {
              defaultOptions: D,
              defaultTime: c,
              getOptions: function () {
                return D;
              },
              setOptions: function (p) {
                return (
                  N(!0, D, p),
                  (p.time || p.global) &&
                    (F.time
                      ? F.time.update(N(D.global, D.time, p.global, p.time))
                      : (F.time = c)),
                  D
                );
              },
            }),
            A
          );
        }
      ),
      T(
        y,
        "Core/Animation/Fx.js",
        [
          y["Core/Color/Color.js"],
          y["Core/Globals.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { parse: G } = A,
            { win: U } = O,
            { isNumber: H, objectEach: Y } = F;
          class S {
            constructor(D, c, p) {
              (this.pos = NaN),
                (this.options = c),
                (this.elem = D),
                (this.prop = p);
            }
            dSetter() {
              var D = this.paths;
              const c = D && D[0];
              D = D && D[1];
              const p = this.now || 0;
              let f = [];
              if (p !== 1 && c && D)
                if (c.length === D.length && 1 > p)
                  for (let u = 0; u < D.length; u++) {
                    const n = c[u],
                      d = D[u],
                      g = [];
                    for (let M = 0; M < d.length; M++) {
                      const C = n[M],
                        P = d[M];
                      H(C) && H(P) && (d[0] !== "A" || (M !== 4 && M !== 5))
                        ? (g[M] = C + p * (P - C))
                        : (g[M] = P);
                    }
                    f.push(g);
                  }
                else f = D;
              else f = this.toD || [];
              this.elem.attr("d", f, void 0, !0);
            }
            update() {
              const D = this.elem,
                c = this.prop,
                p = this.now,
                f = this.options.step;
              this[c + "Setter"]
                ? this[c + "Setter"]()
                : D.attr
                ? D.element && D.attr(c, p, null, !0)
                : (D.style[c] = p + this.unit),
                f && f.call(D, p, this);
            }
            run(D, c, p) {
              const f = this,
                u = f.options,
                n = function (M) {
                  return n.stopped ? !1 : f.step(M);
                },
                d =
                  U.requestAnimationFrame ||
                  function (M) {
                    setTimeout(M, 13);
                  },
                g = function () {
                  for (let M = 0; M < S.timers.length; M++)
                    S.timers[M]() || S.timers.splice(M--, 1);
                  S.timers.length && d(g);
                };
              D !== c || this.elem["forceAnimate:" + this.prop]
                ? ((this.startTime = +new Date()),
                  (this.start = D),
                  (this.end = c),
                  (this.unit = p),
                  (this.now = this.start),
                  (this.pos = 0),
                  (n.elem = this.elem),
                  (n.prop = this.prop),
                  n() && S.timers.push(n) === 1 && d(g))
                : (delete u.curAnim[this.prop],
                  u.complete &&
                    Object.keys(u.curAnim).length === 0 &&
                    u.complete.call(this.elem));
            }
            step(D) {
              const c = +new Date(),
                p = this.options,
                f = this.elem,
                u = p.complete,
                n = p.duration,
                d = p.curAnim;
              let g;
              return (
                f.attr && !f.element
                  ? (D = !1)
                  : D || c >= n + this.startTime
                  ? ((this.now = this.end),
                    (this.pos = 1),
                    this.update(),
                    (g = d[this.prop] = !0),
                    Y(d, function (M) {
                      M !== !0 && (g = !1);
                    }),
                    g && u && u.call(f),
                    (D = !1))
                  : ((this.pos = p.easing((c - this.startTime) / n)),
                    (this.now =
                      this.start + (this.end - this.start) * this.pos),
                    this.update(),
                    (D = !0)),
                D
              );
            }
            initPath(D, c, p) {
              function f(m, h) {
                for (; m.length < P; ) {
                  var v = m[0];
                  const l = h[P - m.length];
                  l &&
                    v[0] === "M" &&
                    (m[0] =
                      l[0] === "C"
                        ? ["C", v[1], v[2], v[1], v[2], v[1], v[2]]
                        : ["L", v[1], v[2]]),
                    m.unshift(v),
                    g && ((v = m.pop()), m.push(m[m.length - 1], v));
                }
              }
              function u(m, h) {
                for (; m.length < P; )
                  if (
                    ((h = m[Math.floor(m.length / M) - 1].slice()),
                    h[0] === "C" && ((h[1] = h[5]), (h[2] = h[6])),
                    g)
                  ) {
                    const v = m[Math.floor(m.length / M)].slice();
                    m.splice(m.length / 2, 0, h, v);
                  } else m.push(h);
              }
              const n = D.startX,
                d = D.endX;
              p = p.slice();
              const g = D.isArea,
                M = g ? 2 : 1;
              let C, P, j;
              if (((c = c && c.slice()), !c)) return [p, p];
              if (n && d && d.length) {
                for (D = 0; D < n.length; D++)
                  if (n[D] === d[0]) {
                    C = D;
                    break;
                  } else if (n[0] === d[d.length - n.length + D]) {
                    (C = D), (j = !0);
                    break;
                  } else if (n[n.length - 1] === d[d.length - n.length + D]) {
                    C = n.length - D;
                    break;
                  }
                typeof C > "u" && (c = []);
              }
              return (
                c.length &&
                  H(C) &&
                  ((P = p.length + C * M),
                  j ? (f(c, p), u(p, c)) : (f(p, c), u(c, p))),
                [c, p]
              );
            }
            fillSetter() {
              S.prototype.strokeSetter.apply(this, arguments);
            }
            strokeSetter() {
              this.elem.attr(
                this.prop,
                G(this.start).tweenTo(G(this.end), this.pos),
                void 0,
                !0
              );
            }
          }
          return (S.timers = []), S;
        }
      ),
      T(
        y,
        "Core/Animation/AnimationUtilities.js",
        [y["Core/Animation/Fx.js"], y["Core/Utilities.js"]],
        function (A, O) {
          function F(f) {
            return N(f)
              ? D({ duration: 500, defer: 0 }, f)
              : { duration: f ? 500 : 0, defer: 0 };
          }
          function G(f, u) {
            let n = A.timers.length;
            for (; n--; )
              A.timers[n].elem !== f ||
                (u && u !== A.timers[n].prop) ||
                (A.timers[n].stopped = !0);
          }
          const {
            defined: U,
            getStyle: H,
            isArray: Y,
            isNumber: S,
            isObject: N,
            merge: D,
            objectEach: c,
            pick: p,
          } = O;
          return {
            animate: function (f, u, n) {
              let d,
                g = "",
                M,
                C,
                P;
              N(n) ||
                ((P = arguments),
                (n = { duration: P[2], easing: P[3], complete: P[4] })),
                S(n.duration) || (n.duration = 400),
                (n.easing =
                  typeof n.easing == "function"
                    ? n.easing
                    : Math[n.easing] || Math.easeInOutSine),
                (n.curAnim = D(u)),
                c(u, function (j, m) {
                  G(f, m),
                    (C = new A(f, n, m)),
                    (M = void 0),
                    m === "d" && Y(u.d)
                      ? ((C.paths = C.initPath(f, f.pathArray, u.d)),
                        (C.toD = u.d),
                        (d = 0),
                        (M = 1))
                      : f.attr
                      ? (d = f.attr(m))
                      : ((d = parseFloat(H(f, m)) || 0),
                        m !== "opacity" && (g = "px")),
                    M || (M = j),
                    typeof M == "string" &&
                      M.match("px") &&
                      (M = M.replace(/px/g, "")),
                    C.run(d, M, g);
                });
            },
            animObject: F,
            getDeferredAnimation: function (f, u, n) {
              const d = F(u);
              let g = 0,
                M = 0;
              return (
                (n ? [n] : f.series).forEach((C) => {
                  (C = F(C.options.animation)),
                    (g =
                      u && U(u.defer)
                        ? d.defer
                        : Math.max(g, C.duration + C.defer)),
                    (M = Math.min(d.duration, C.duration));
                }),
                f.renderer.forExport && (g = 0),
                { defer: Math.max(0, g - M), duration: Math.min(g, M) }
              );
            },
            setAnimation: function (f, u) {
              u.renderer.globalAnimation = p(f, u.options.chart.animation, !0);
            },
            stop: G,
          };
        }
      ),
      T(
        y,
        "Core/Renderer/HTML/AST.js",
        [y["Core/Globals.js"], y["Core/Utilities.js"]],
        function (A, O) {
          const { SVG_NS: F, win: G } = A,
            {
              attr: U,
              createElement: H,
              css: Y,
              error: S,
              isFunction: N,
              isString: D,
              objectEach: c,
              splat: p,
            } = O;
          ({ trustedTypes: O } = G);
          const f =
            O &&
            N(O.createPolicy) &&
            O.createPolicy("highcharts", { createHTML: (g) => g });
          O = f ? f.createHTML("") : "";
          try {
            var u = !!new DOMParser().parseFromString(O, "text/html");
          } catch {
            u = !1;
          }
          const n = u;
          class d {
            static filterUserAttributes(M) {
              return (
                c(M, (C, P) => {
                  let j = !0;
                  d.allowedAttributes.indexOf(P) === -1 && (j = !1),
                    ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(
                      P
                    ) !== -1 &&
                      (j =
                        D(C) &&
                        d.allowedReferences.some((m) => C.indexOf(m) === 0)),
                    j ||
                      (S(33, !1, void 0, {
                        "Invalid attribute in config": `${P}`,
                      }),
                      delete M[P]),
                    D(C) && M[P] && (M[P] = C.replace(/</g, "&lt;"));
                }),
                M
              );
            }
            static parseStyle(M) {
              return M.split(";").reduce((C, P) => {
                P = P.split(":").map((m) => m.trim());
                const j = P.shift();
                return (
                  j &&
                    P.length &&
                    (C[j.replace(/-([a-z])/g, (m) => m[1].toUpperCase())] =
                      P.join(":")),
                  C
                );
              }, {});
            }
            static setElementHTML(M, C) {
              (M.innerHTML = d.emptyHTML), C && new d(C).addToDOM(M);
            }
            constructor(M) {
              this.nodes = typeof M == "string" ? this.parseMarkup(M) : M;
            }
            addToDOM(M) {
              function C(P, j) {
                let m;
                return (
                  p(P).forEach(function (h) {
                    var v = h.tagName;
                    const l = h.textContent
                        ? A.doc.createTextNode(h.textContent)
                        : void 0,
                      o = d.bypassHTMLFiltering;
                    let i;
                    if (v)
                      if (v === "#text") i = l;
                      else if (d.allowedTags.indexOf(v) !== -1 || o) {
                        v = A.doc.createElementNS(
                          v === "svg" ? F : j.namespaceURI || F,
                          v
                        );
                        const t = h.attributes || {};
                        c(h, function (e, s) {
                          s !== "tagName" &&
                            s !== "attributes" &&
                            s !== "children" &&
                            s !== "style" &&
                            s !== "textContent" &&
                            (t[s] = e);
                        }),
                          U(v, o ? t : d.filterUserAttributes(t)),
                          h.style && Y(v, h.style),
                          l && v.appendChild(l),
                          C(h.children || [], v),
                          (i = v);
                      } else
                        S(33, !1, void 0, { "Invalid tagName in config": v });
                    i && j.appendChild(i), (m = i);
                  }),
                  m
                );
              }
              return C(this.nodes, M);
            }
            parseMarkup(M) {
              const C = [];
              if (
                ((M = M.trim().replace(/ style=(["'])/g, " data-style=$1")), n)
              )
                M = new DOMParser().parseFromString(
                  f ? f.createHTML(M) : M,
                  "text/html"
                );
              else {
                const j = H("div");
                (j.innerHTML = M), (M = { body: j });
              }
              const P = (j, m) => {
                var h = j.nodeName.toLowerCase();
                const v = { tagName: h };
                if (
                  (h === "#text" && (v.textContent = j.textContent || ""),
                  (h = j.attributes))
                ) {
                  const l = {};
                  [].forEach.call(h, (o) => {
                    o.name === "data-style"
                      ? (v.style = d.parseStyle(o.value))
                      : (l[o.name] = o.value);
                  }),
                    (v.attributes = l);
                }
                if (j.childNodes.length) {
                  const l = [];
                  [].forEach.call(j.childNodes, (o) => {
                    P(o, l);
                  }),
                    l.length && (v.children = l);
                }
                m.push(v);
              };
              return [].forEach.call(M.body.childNodes, (j) => P(j, C)), C;
            }
          }
          return (
            (d.allowedAttributes =
              "alt aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill flood-color flood-opacity height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align text-anchor textAnchor textLength title type valign width x x1 x2 xlink:href y y1 y2 zIndex".split(
                " "
              )),
            (d.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(
              " "
            )),
            (d.allowedTags =
              "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feDropShadow feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text textPath thead title tbody tspan td th tr u ul #text".split(
                " "
              )),
            (d.emptyHTML = O),
            (d.bypassHTMLFiltering = !1),
            d
          );
        }
      ),
      T(
        y,
        "Core/Templating.js",
        [y["Core/Defaults.js"], y["Core/Utilities.js"]],
        function (A, O) {
          function F(n = "", d, g) {
            const M = /\{([a-zA-Z0-9:\.,;\-\/<>%_@"'= #\(\)]+)\}/g,
              C = /\(([a-zA-Z0-9:\.,;\-\/<>%_@"'= ]+)\)/g,
              P = [],
              j = /f$/,
              m = /\.([0-9])/,
              h = U.lang,
              v = (g && g.time) || H,
              l = (g && g.numberFormatter) || G,
              o = (r = "") => {
                let w;
                return r === "true"
                  ? !0
                  : r === "false"
                  ? !1
                  : (w = Number(r)).toString() === r
                  ? w
                  : S(r, d);
              };
            let i,
              t,
              e = 0,
              s;
            for (; (i = M.exec(n)) !== null; ) {
              const r = C.exec(i[1]);
              r && ((i = r), (s = !0)),
                (t && t.isBlock) ||
                  (t = {
                    ctx: d,
                    expression: i[1],
                    find: i[0],
                    isBlock: i[1].charAt(0) === "#",
                    start: i.index,
                    startInner: i.index + i[0].length,
                    length: i[0].length,
                  });
              var a = i[1].split(" ")[0].replace("#", "");
              if (
                (u[a] && (t.isBlock && a === t.fn && e++, t.fn || (t.fn = a)),
                (a = i[1] === "else"),
                t.isBlock && t.fn && (i[1] === `/${t.fn}` || a))
              )
                if (e) a || e--;
                else {
                  var b = t.startInner;
                  (b = n.substr(b, i.index - b)),
                    t.body === void 0
                      ? ((t.body = b), (t.startInner = i.index + i[0].length))
                      : (t.elseBody = b),
                    (t.find += b + i[0]),
                    a || (P.push(t), (t = void 0));
                }
              else t.isBlock || P.push(t);
              if (r && (t == null || !t.isBlock)) break;
            }
            return (
              P.forEach((r) => {
                const { body: w, elseBody: L, expression: I, fn: V } = r;
                var B;
                if (V) {
                  var x = [r],
                    R = I.split(" ");
                  for (B = u[V].length; B--; ) x.unshift(o(R[B + 1]));
                  (B = u[V].apply(d, x)),
                    r.isBlock && typeof B == "boolean" && (B = F(B ? w : L, d));
                } else
                  (x = I.split(":")),
                    (B = o(x.shift() || "")),
                    x.length &&
                      typeof B == "number" &&
                      ((x = x.join(":")),
                      j.test(x)
                        ? ((R = parseInt((x.match(m) || ["", "-1"])[1], 10)),
                          B !== null &&
                            (B = l(
                              B,
                              R,
                              h.decimalPoint,
                              -1 < x.indexOf(",") ? h.thousandsSep : ""
                            )))
                        : (B = v.dateFormat(x, B)));
                n = n.replace(r.find, p(B, ""));
              }),
              s ? F(n, d, g) : n
            );
          }
          function G(n, d, g, M) {
            (n = +n || 0), (d = +d);
            const C = U.lang;
            var P = (n.toString().split(".")[1] || "").split("e")[0].length;
            const j = n.toString().split("e"),
              m = d;
            if (d === -1) d = Math.min(P, 20);
            else if (!D(d)) d = 2;
            else if (d && j[1] && 0 > j[1]) {
              var h = d + +j[1];
              0 <= h
                ? ((j[0] = (+j[0]).toExponential(h).split("e")[0]), (d = h))
                : ((j[0] = j[0].split(".")[0] || 0),
                  (n = 20 > d ? (j[0] * Math.pow(10, j[1])).toFixed(d) : 0),
                  (j[1] = 0));
            }
            (h = (
              Math.abs(j[1] ? j[0] : n) + Math.pow(10, -Math.max(d, P) - 1)
            ).toFixed(d)),
              (P = String(f(h)));
            const v = 3 < P.length ? P.length % 3 : 0;
            return (
              (g = p(g, C.decimalPoint)),
              (M = p(M, C.thousandsSep)),
              (n = (0 > n ? "-" : "") + (v ? P.substr(0, v) + M : "")),
              (n =
                0 > +j[1] && !m
                  ? "0"
                  : n + P.substr(v).replace(/(\d{3})(?=\d)/g, "$1" + M)),
              d && (n += g + h.slice(-d)),
              j[1] && +n != 0 && (n += "e" + j[1]),
              n
            );
          }
          const { defaultOptions: U, defaultTime: H } = A,
            {
              extend: Y,
              getNestedProperty: S,
              isArray: N,
              isNumber: D,
              isObject: c,
              pick: p,
              pInt: f,
            } = O,
            u = {
              add: (n, d) => n + d,
              divide: (n, d) => (d !== 0 ? n / d : ""),
              eq: (n, d) => n == d,
              each: function (n) {
                const d = arguments[arguments.length - 1];
                return N(n)
                  ? n
                      .map((g, M) =>
                        F(
                          d.body,
                          Y(c(g) ? g : { "@this": g }, {
                            "@index": M,
                            "@first": M === 0,
                            "@last": M === n.length - 1,
                          })
                        )
                      )
                      .join("")
                  : !1;
              },
              ge: (n, d) => n >= d,
              gt: (n, d) => n > d,
              if: (n) => !!n,
              le: (n, d) => n <= d,
              lt: (n, d) => n < d,
              multiply: (n, d) => n * d,
              ne: (n, d) => n != d,
              subtract: (n, d) => n - d,
              unless: (n) => !n,
            };
          return {
            dateFormat: function (n, d, g) {
              return H.dateFormat(n, d, g);
            },
            format: F,
            helpers: u,
            numberFormat: G,
          };
        }
      ),
      T(
        y,
        "Core/Renderer/RendererUtilities.js",
        [y["Core/Utilities.js"]],
        function (A) {
          const { clamp: O, pick: F, stableSort: G } = A;
          var U;
          return (
            (function (H) {
              function Y(S, N, D) {
                const c = S;
                var p = c.reducedLen || N,
                  f = (C, P) => (P.rank || 0) - (C.rank || 0);
                const u = (C, P) => C.target - P.target;
                let n,
                  d = !0,
                  g = [],
                  M = 0;
                for (n = S.length; n--; ) M += S[n].size;
                if (M > p) {
                  for (G(S, f), M = n = 0; M <= p; ) (M += S[n].size), n++;
                  g = S.splice(n - 1, S.length);
                }
                for (
                  G(S, u),
                    S = S.map((C) => ({
                      size: C.size,
                      targets: [C.target],
                      align: F(C.align, 0.5),
                    }));
                  d;

                ) {
                  for (n = S.length; n--; )
                    (p = S[n]),
                      (f =
                        (Math.min.apply(0, p.targets) +
                          Math.max.apply(0, p.targets)) /
                        2),
                      (p.pos = O(f - p.size * p.align, 0, N - p.size));
                  for (n = S.length, d = !1; n--; )
                    0 < n &&
                      S[n - 1].pos + S[n - 1].size > S[n].pos &&
                      ((S[n - 1].size += S[n].size),
                      (S[n - 1].targets = S[n - 1].targets.concat(
                        S[n].targets
                      )),
                      (S[n - 1].align = 0.5),
                      S[n - 1].pos + S[n - 1].size > N &&
                        (S[n - 1].pos = N - S[n - 1].size),
                      S.splice(n, 1),
                      (d = !0));
                }
                return (
                  c.push.apply(c, g),
                  (n = 0),
                  S.some((C) => {
                    let P = 0;
                    return (C.targets || []).some(
                      () => (
                        (c[n].pos = C.pos + P),
                        typeof D < "u" && Math.abs(c[n].pos - c[n].target) > D
                          ? (c.slice(0, n + 1).forEach((j) => delete j.pos),
                            (c.reducedLen = (c.reducedLen || N) - 0.1 * N),
                            c.reducedLen > 0.1 * N && Y(c, N, D),
                            !0)
                          : ((P += c[n].size), n++, !1)
                      )
                    );
                  }),
                  G(c, u),
                  c
                );
              }
              H.distribute = Y;
            })(U || (U = {})),
            U
          );
        }
      ),
      T(
        y,
        "Core/Renderer/SVG/SVGElement.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Color/Color.js"],
          y["Core/Globals.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          const { animate: U, animObject: H, stop: Y } = A,
            { deg2rad: S, doc: N, svg: D, SVG_NS: c, win: p } = F,
            {
              addEvent: f,
              attr: u,
              createElement: n,
              css: d,
              defined: g,
              erase: M,
              extend: C,
              fireEvent: P,
              isArray: j,
              isFunction: m,
              isObject: h,
              isString: v,
              merge: l,
              objectEach: o,
              pick: i,
              pInt: t,
              syncTimeout: e,
              uniqueKey: s,
            } = G;
          class a {
            constructor() {
              (this.element = void 0),
                (this.onEvents = {}),
                (this.opacity = 1),
                (this.renderer = void 0),
                (this.SVG_NS = c);
            }
            _defaultGetter(r) {
              return (
                (r = i(
                  this[r + "Value"],
                  this[r],
                  this.element ? this.element.getAttribute(r) : null,
                  0
                )),
                /^[\-0-9\.]+$/.test(r) && (r = parseFloat(r)),
                r
              );
            }
            _defaultSetter(r, w, L) {
              L.setAttribute(w, r);
            }
            add(r) {
              const w = this.renderer,
                L = this.element;
              let I;
              return (
                r && (this.parentGroup = r),
                typeof this.textStr < "u" &&
                  this.element.nodeName === "text" &&
                  w.buildText(this),
                (this.added = !0),
                (!r || r.handleZ || this.zIndex) && (I = this.zIndexSetter()),
                I || (r ? r.element : w.box).appendChild(L),
                this.onAdd && this.onAdd(),
                this
              );
            }
            addClass(r, w) {
              const L = w ? "" : this.attr("class") || "";
              return (
                (r = (r || "")
                  .split(/ /g)
                  .reduce(
                    function (I, V) {
                      return L.indexOf(V) === -1 && I.push(V), I;
                    },
                    L ? [L] : []
                  )
                  .join(" ")),
                r !== L && this.attr("class", r),
                this
              );
            }
            afterSetters() {
              this.doTransform &&
                (this.updateTransform(), (this.doTransform = !1));
            }
            align(r, w, L) {
              const I = {};
              var V = this.renderer,
                B = V.alignedObjects,
                x;
              let R, W;
              r
                ? ((this.alignOptions = r),
                  (this.alignByTranslate = w),
                  (!L || v(L)) &&
                    ((this.alignTo = x = L || "renderer"),
                    M(B, this),
                    B.push(this),
                    (L = void 0)))
                : ((r = this.alignOptions),
                  (w = this.alignByTranslate),
                  (x = this.alignTo)),
                (L = i(
                  L,
                  V[x],
                  x === "scrollablePlotBox" ? V.plotBox : void 0,
                  V
                )),
                (x = r.align);
              const X = r.verticalAlign;
              return (
                (V = (L.x || 0) + (r.x || 0)),
                (B = (L.y || 0) + (r.y || 0)),
                x === "right" ? (R = 1) : x === "center" && (R = 2),
                R && (V += (L.width - (r.width || 0)) / R),
                (I[w ? "translateX" : "x"] = Math.round(V)),
                X === "bottom" ? (W = 1) : X === "middle" && (W = 2),
                W && (B += (L.height - (r.height || 0)) / W),
                (I[w ? "translateY" : "y"] = Math.round(B)),
                this[this.placed ? "animate" : "attr"](I),
                (this.placed = !0),
                (this.alignAttr = I),
                this
              );
            }
            alignSetter(r) {
              const w = { left: "start", center: "middle", right: "end" };
              w[r] &&
                ((this.alignValue = r),
                this.element.setAttribute("text-anchor", w[r]));
            }
            animate(r, w, L) {
              const I = H(i(w, this.renderer.globalAnimation, !0));
              return (
                (w = I.defer),
                N.hidden && (I.duration = 0),
                I.duration !== 0
                  ? (L && (I.complete = L),
                    e(() => {
                      this.element && U(this, r, I);
                    }, w))
                  : (this.attr(r, void 0, L || I.complete),
                    o(
                      r,
                      function (V, B) {
                        I.step &&
                          I.step.call(this, V, { prop: B, pos: 1, elem: this });
                      },
                      this
                    )),
                this
              );
            }
            applyTextOutline(r) {
              const w = this.element;
              r.indexOf("contrast") !== -1 &&
                (r = r.replace(
                  /contrast/g,
                  this.renderer.getContrast(w.style.fill)
                ));
              var L = r.split(" ");
              if (
                ((r = L[L.length - 1]), (L = L[0]) && L !== "none" && F.svg)
              ) {
                (this.fakeTS = !0),
                  (L = L.replace(/(^[\d\.]+)(.*?)$/g, function (B, x, R) {
                    return 2 * Number(x) + R;
                  })),
                  this.removeTextOutline();
                const I = N.createElementNS(c, "tspan");
                u(I, {
                  class: "highcharts-text-outline",
                  fill: r,
                  stroke: r,
                  "stroke-width": L,
                  "stroke-linejoin": "round",
                }),
                  (r = w.querySelector("textPath") || w),
                  [].forEach.call(r.childNodes, (B) => {
                    const x = B.cloneNode(!0);
                    x.removeAttribute &&
                      ["fill", "stroke", "stroke-width", "stroke"].forEach(
                        (R) => x.removeAttribute(R)
                      ),
                      I.appendChild(x);
                  });
                let V = 0;
                [].forEach.call(r.querySelectorAll("text tspan"), (B) => {
                  V += Number(B.getAttribute("dy"));
                }),
                  (L = N.createElementNS(c, "tspan")),
                  (L.textContent = "​"),
                  u(L, { x: Number(w.getAttribute("x")), dy: -V }),
                  I.appendChild(L),
                  r.insertBefore(I, r.firstChild);
              }
            }
            attr(r, w, L, I) {
              const V = this.element,
                B = a.symbolCustomAttribs;
              let x,
                R,
                W = this,
                X,
                Z;
              return (
                typeof r == "string" &&
                  typeof w < "u" &&
                  ((x = r), (r = {}), (r[x] = w)),
                typeof r == "string"
                  ? (W = (this[r + "Getter"] || this._defaultGetter).call(
                      this,
                      r,
                      V
                    ))
                  : (o(
                      r,
                      function (E, _) {
                        (X = !1),
                          I || Y(this, _),
                          this.symbolName &&
                            B.indexOf(_) !== -1 &&
                            (R || (this.symbolAttr(r), (R = !0)), (X = !0)),
                          !this.rotation ||
                            (_ !== "x" && _ !== "y") ||
                            (this.doTransform = !0),
                          X ||
                            ((Z = this[_ + "Setter"] || this._defaultSetter),
                            Z.call(this, E, _, V));
                      },
                      this
                    ),
                    this.afterSetters()),
                L && L.call(this),
                W
              );
            }
            clip(r) {
              return this.attr(
                "clip-path",
                r ? "url(" + this.renderer.url + "#" + r.id + ")" : "none"
              );
            }
            crisp(r, w) {
              w = w || r.strokeWidth || 0;
              const L = (Math.round(w) % 2) / 2;
              return (
                (r.x = Math.floor(r.x || this.x || 0) + L),
                (r.y = Math.floor(r.y || this.y || 0) + L),
                (r.width = Math.floor((r.width || this.width || 0) - 2 * L)),
                (r.height = Math.floor((r.height || this.height || 0) - 2 * L)),
                g(r.strokeWidth) && (r.strokeWidth = w),
                r
              );
            }
            complexColor(r, w, L) {
              const I = this.renderer;
              let V,
                B,
                x,
                R,
                W,
                X,
                Z,
                E,
                _,
                z,
                J = [],
                tt;
              P(
                this.renderer,
                "complexColor",
                { args: arguments },
                function () {
                  if (
                    (r.radialGradient
                      ? (B = "radialGradient")
                      : r.linearGradient && (B = "linearGradient"),
                    B)
                  ) {
                    if (
                      ((x = r[B]),
                      (W = I.gradients),
                      (X = r.stops),
                      (_ = L.radialReference),
                      j(x) &&
                        (r[B] = x =
                          {
                            x1: x[0],
                            y1: x[1],
                            x2: x[2],
                            y2: x[3],
                            gradientUnits: "userSpaceOnUse",
                          }),
                      B === "radialGradient" &&
                        _ &&
                        !g(x.gradientUnits) &&
                        ((R = x),
                        (x = l(x, I.getRadialAttr(_, R), {
                          gradientUnits: "userSpaceOnUse",
                        }))),
                      o(x, function ($, it) {
                        it !== "id" && J.push(it, $);
                      }),
                      o(X, function ($) {
                        J.push($);
                      }),
                      (J = J.join(",")),
                      W[J])
                    )
                      z = W[J].attr("id");
                    else {
                      x.id = z = s();
                      const $ = (W[J] = I.createElement(B).attr(x).add(I.defs));
                      ($.radAttr = R),
                        ($.stops = []),
                        X.forEach(function (it) {
                          it[1].indexOf("rgba") === 0
                            ? ((V = O.parse(it[1])),
                              (Z = V.get("rgb")),
                              (E = V.get("a")))
                            : ((Z = it[1]), (E = 1)),
                            (it = I.createElement("stop")
                              .attr({
                                offset: it[0],
                                "stop-color": Z,
                                "stop-opacity": E,
                              })
                              .add($)),
                            $.stops.push(it);
                        });
                    }
                    (tt = "url(" + I.url + "#" + z + ")"),
                      L.setAttribute(w, tt),
                      (L.gradient = J),
                      (r.toString = function () {
                        return tt;
                      });
                  }
                }
              );
            }
            css(r) {
              const w = this.styles,
                L = {},
                I = this.element;
              let V,
                B = !w;
              if (
                (w &&
                  o(r, function (x, R) {
                    w && w[R] !== x && ((L[R] = x), (B = !0));
                  }),
                B)
              ) {
                w && (r = C(w, L)),
                  r.width === null || r.width === "auto"
                    ? delete this.textWidth
                    : I.nodeName.toLowerCase() === "text" &&
                      r.width &&
                      (V = this.textWidth = t(r.width)),
                  (this.styles = r),
                  V && !D && this.renderer.forExport && delete r.width;
                const x = l(r);
                I.namespaceURI === this.SVG_NS &&
                  (["textOutline", "textOverflow", "width"].forEach(
                    (R) => x && delete x[R]
                  ),
                  x.color && (x.fill = x.color)),
                  d(I, x);
              }
              return (
                this.added &&
                  (this.element.nodeName === "text" &&
                    this.renderer.buildText(this),
                  r.textOutline && this.applyTextOutline(r.textOutline)),
                this
              );
            }
            dashstyleSetter(r) {
              let w = this["stroke-width"];
              if ((w === "inherit" && (w = 1), (r = r && r.toLowerCase()))) {
                const L = r
                  .replace("shortdashdotdot", "3,1,1,1,1,1,")
                  .replace("shortdashdot", "3,1,1,1")
                  .replace("shortdot", "1,1,")
                  .replace("shortdash", "3,1,")
                  .replace("longdash", "8,3,")
                  .replace(/dot/g, "1,3,")
                  .replace("dash", "4,3,")
                  .replace(/,$/, "")
                  .split(",");
                for (r = L.length; r--; ) L[r] = "" + t(L[r]) * i(w, NaN);
                (r = L.join(",").replace(/NaN/g, "none")),
                  this.element.setAttribute("stroke-dasharray", r);
              }
            }
            destroy() {
              const r = this;
              var w = r.element || {};
              const L = r.renderer;
              var I = w.ownerSVGElement;
              let V = (w.nodeName === "SPAN" && r.parentGroup) || void 0;
              if (
                ((w.onclick =
                  w.onmouseout =
                  w.onmouseover =
                  w.onmousemove =
                  w.point =
                    null),
                Y(r),
                r.clipPath && I)
              ) {
                const B = r.clipPath;
                [].forEach.call(
                  I.querySelectorAll("[clip-path],[CLIP-PATH]"),
                  function (x) {
                    -1 < x.getAttribute("clip-path").indexOf(B.element.id) &&
                      x.removeAttribute("clip-path");
                  }
                ),
                  (r.clipPath = B.destroy());
              }
              if (r.stops) {
                for (I = 0; I < r.stops.length; I++) r.stops[I].destroy();
                (r.stops.length = 0), (r.stops = void 0);
              }
              for (
                r.safeRemoveChild(w);
                V && V.div && V.div.childNodes.length === 0;

              )
                (w = V.parentGroup),
                  r.safeRemoveChild(V.div),
                  delete V.div,
                  (V = w);
              r.alignTo && M(L.alignedObjects, r),
                o(r, function (B, x) {
                  r[x] &&
                    r[x].parentGroup === r &&
                    r[x].destroy &&
                    r[x].destroy(),
                    delete r[x];
                });
            }
            dSetter(r, w, L) {
              j(r) &&
                (typeof r[0] == "string" &&
                  (r = this.renderer.pathToSegments(r)),
                (this.pathArray = r),
                (r = r.reduce(
                  (I, V, B) =>
                    V && V.join
                      ? (B ? I + " " : "") + V.join(" ")
                      : (V || "").toString(),
                  ""
                ))),
                /(NaN| {2}|^$)/.test(r) && (r = "M 0 0"),
                this[w] !== r && (L.setAttribute(w, r), (this[w] = r));
            }
            fadeOut(r) {
              const w = this;
              w.animate(
                { opacity: 0 },
                {
                  duration: i(r, 150),
                  complete: function () {
                    w.hide();
                  },
                }
              );
            }
            fillSetter(r, w, L) {
              typeof r == "string"
                ? L.setAttribute(w, r)
                : r && this.complexColor(r, w, L);
            }
            getBBox(r, w) {
              const {
                  alignValue: L,
                  element: I,
                  renderer: V,
                  styles: B,
                  textStr: x,
                } = this,
                { cache: R, cacheKeys: W } = V;
              var X = I.namespaceURI === this.SVG_NS;
              w = i(w, this.rotation, 0);
              var Z = V.styledMode
                ? I && a.prototype.getStyle.call(I, "font-size")
                : B && B.fontSize;
              let E, _;
              if (
                (g(x) &&
                  ((_ = x.toString()),
                  _.indexOf("<") === -1 && (_ = _.replace(/[0-9]/g, "0")),
                  (_ += [
                    "",
                    V.rootFontSize,
                    Z,
                    w,
                    this.textWidth,
                    L,
                    B && B.textOverflow,
                    B && B.fontWeight,
                  ].join())),
                _ && !r && (E = R[_]),
                !E)
              ) {
                if (X || V.forExport) {
                  try {
                    var z =
                      this.fakeTS &&
                      function (nt) {
                        const rt = I.querySelector(".highcharts-text-outline");
                        rt && d(rt, { display: nt });
                      };
                    m(z) && z("none"),
                      (E = I.getBBox
                        ? C({}, I.getBBox())
                        : {
                            width: I.offsetWidth,
                            height: I.offsetHeight,
                            x: 0,
                            y: 0,
                          }),
                      m(z) && z("");
                  } catch {}
                  (!E || 0 > E.width) &&
                    (E = { x: 0, y: 0, width: 0, height: 0 });
                } else E = this.htmlGetBBox();
                if (
                  ((z = E.width),
                  (r = E.height),
                  X &&
                    (E.height = r =
                      { "11px,17": 14, "13px,20": 16 }[
                        `${Z || ""},${Math.round(r)}`
                      ] || r),
                  w)
                ) {
                  (X = Number(I.getAttribute("y") || 0) - E.y),
                    (Z = { right: 1, center: 0.5 }[L || 0] || 0);
                  var J = w * S,
                    tt = (w - 90) * S,
                    $ = z * Math.cos(J);
                  w = z * Math.sin(J);
                  var it = Math.cos(tt);
                  (J = Math.sin(tt)),
                    (z = E.x + Z * (z - $) + X * it),
                    (tt = z + $),
                    (it = tt - r * it),
                    ($ = it - $),
                    (X = E.y + X - Z * w + X * J),
                    (Z = X + w),
                    (r = Z - r * J),
                    (w = r - w),
                    (E.x = Math.min(z, tt, it, $)),
                    (E.y = Math.min(X, Z, r, w)),
                    (E.width = Math.max(z, tt, it, $) - E.x),
                    (E.height = Math.max(X, Z, r, w) - E.y);
                }
              }
              if (_ && (x === "" || 0 < E.height)) {
                for (; 250 < W.length; ) delete R[W.shift()];
                R[_] || W.push(_), (R[_] = E);
              }
              return E;
            }
            getStyle(r) {
              return p
                .getComputedStyle(this.element || this, "")
                .getPropertyValue(r);
            }
            hasClass(r) {
              return ("" + this.attr("class")).split(" ").indexOf(r) !== -1;
            }
            hide() {
              return this.attr({ visibility: "hidden" });
            }
            htmlGetBBox() {
              return { height: 0, width: 0, x: 0, y: 0 };
            }
            init(r, w) {
              (this.element =
                w === "span" ? n(w) : N.createElementNS(this.SVG_NS, w)),
                (this.renderer = r),
                P(this, "afterInit");
            }
            on(r, w) {
              const { onEvents: L } = this;
              return L[r] && L[r](), (L[r] = f(this.element, r, w)), this;
            }
            opacitySetter(r, w, L) {
              (this.opacity = r = Number(Number(r).toFixed(3))),
                L.setAttribute(w, r);
            }
            removeClass(r) {
              return this.attr(
                "class",
                ("" + this.attr("class"))
                  .replace(v(r) ? new RegExp(`(^| )${r}( |$)`) : r, " ")
                  .replace(/ +/g, " ")
                  .trim()
              );
            }
            removeTextOutline() {
              const r = this.element.querySelector(
                "tspan.highcharts-text-outline"
              );
              r && this.safeRemoveChild(r);
            }
            safeRemoveChild(r) {
              const w = r.parentNode;
              w && w.removeChild(r);
            }
            setRadialReference(r) {
              const w =
                this.element.gradient &&
                this.renderer.gradients[this.element.gradient];
              return (
                (this.element.radialReference = r),
                w &&
                  w.radAttr &&
                  w.animate(this.renderer.getRadialAttr(r, w.radAttr)),
                this
              );
            }
            setTextPath(r, w) {
              w = l(
                !0,
                {
                  enabled: !0,
                  attributes: {
                    dy: -5,
                    startOffset: "50%",
                    textAnchor: "middle",
                  },
                },
                w
              );
              const L = this.renderer.url,
                I = this.text || this,
                V = I.textPath,
                { attributes: B, enabled: x } = w;
              return (
                (r = r || (V && V.path)),
                V && V.undo(),
                r && x
                  ? ((w = f(I, "afterModifyTree", (R) => {
                      if (r && x) {
                        let X = r.attr("id");
                        X || r.attr("id", (X = s()));
                        var W = { x: 0, y: 0 };
                        g(B.dx) && ((W.dx = B.dx), delete B.dx),
                          g(B.dy) && ((W.dy = B.dy), delete B.dy),
                          I.attr(W),
                          this.attr({ transform: "" }),
                          this.box && (this.box = this.box.destroy()),
                          (W = R.nodes.slice(0)),
                          (R.nodes.length = 0),
                          (R.nodes[0] = {
                            tagName: "textPath",
                            attributes: C(B, {
                              "text-anchor": B.textAnchor,
                              href: `${L}#${X}`,
                            }),
                            children: W,
                          });
                      }
                    })),
                    (I.textPath = { path: r, undo: w }))
                  : (I.attr({ dx: 0, dy: 0 }), delete I.textPath),
                this.added && ((I.textCache = ""), this.renderer.buildText(I)),
                this
              );
            }
            shadow(r) {
              var w;
              const { renderer: L } = this,
                I = l(
                  ((w = this.parentGroup) === null || w === void 0
                    ? void 0
                    : w.rotation) === 90
                    ? { offsetX: -1, offsetY: -1 }
                    : {},
                  h(r) ? r : {}
                );
              return (
                (w = L.shadowDefinition(I)),
                this.attr({ filter: r ? `url(${L.url}#${w})` : "none" })
              );
            }
            show(r = !0) {
              return this.attr({ visibility: r ? "inherit" : "visible" });
            }
            "stroke-widthSetter"(r, w, L) {
              (this[w] = r), L.setAttribute(w, r);
            }
            strokeWidth() {
              if (!this.renderer.styledMode) return this["stroke-width"] || 0;
              const r = this.getStyle("stroke-width");
              let w = 0,
                L;
              return (
                r.indexOf("px") === r.length - 2
                  ? (w = t(r))
                  : r !== "" &&
                    ((L = N.createElementNS(c, "rect")),
                    u(L, { width: r, "stroke-width": 0 }),
                    this.element.parentNode.appendChild(L),
                    (w = L.getBBox().width),
                    L.parentNode.removeChild(L)),
                w
              );
            }
            symbolAttr(r) {
              const w = this;
              a.symbolCustomAttribs.forEach(function (L) {
                w[L] = i(r[L], w[L]);
              }),
                w.attr({
                  d: w.renderer.symbols[w.symbolName](
                    w.x,
                    w.y,
                    w.width,
                    w.height,
                    w
                  ),
                });
            }
            textSetter(r) {
              r !== this.textStr &&
                (delete this.textPxLength,
                (this.textStr = r),
                this.added && this.renderer.buildText(this));
            }
            titleSetter(r) {
              const w = this.element,
                L =
                  w.getElementsByTagName("title")[0] ||
                  N.createElementNS(this.SVG_NS, "title");
              w.insertBefore
                ? w.insertBefore(L, w.firstChild)
                : w.appendChild(L),
                (L.textContent = String(i(r, ""))
                  .replace(/<[^>]*>/g, "")
                  .replace(/&lt;/g, "<")
                  .replace(/&gt;/g, ">"));
            }
            toFront() {
              const r = this.element;
              return r.parentNode.appendChild(r), this;
            }
            translate(r, w) {
              return this.attr({ translateX: r, translateY: w });
            }
            updateTransform() {
              const {
                  element: r,
                  matrix: w,
                  rotation: L = 0,
                  scaleX: I,
                  scaleY: V,
                  translateX: B = 0,
                  translateY: x = 0,
                } = this,
                R = ["translate(" + B + "," + x + ")"];
              g(w) && R.push("matrix(" + w.join(",") + ")"),
                L &&
                  R.push(
                    "rotate(" +
                      L +
                      " " +
                      i(this.rotationOriginX, r.getAttribute("x"), 0) +
                      " " +
                      i(this.rotationOriginY, r.getAttribute("y") || 0) +
                      ")"
                  ),
                (g(I) || g(V)) &&
                  R.push("scale(" + i(I, 1) + " " + i(V, 1) + ")"),
                R.length &&
                  !(this.text || this).textPath &&
                  r.setAttribute("transform", R.join(" "));
            }
            visibilitySetter(r, w, L) {
              r === "inherit"
                ? L.removeAttribute(w)
                : this[w] !== r && L.setAttribute(w, r),
                (this[w] = r);
            }
            xGetter(r) {
              return (
                this.element.nodeName === "circle" &&
                  (r === "x" ? (r = "cx") : r === "y" && (r = "cy")),
                this._defaultGetter(r)
              );
            }
            zIndexSetter(r, w) {
              var L = this.renderer,
                I = this.parentGroup;
              const V = (I || L).element || L.box,
                B = this.element;
              L = V === L.box;
              let x = !1,
                R;
              var W = this.added;
              let X;
              if (
                (g(r)
                  ? (B.setAttribute("data-z-index", r),
                    (r = +r),
                    this[w] === r && (W = !1))
                  : g(this[w]) && B.removeAttribute("data-z-index"),
                (this[w] = r),
                W)
              ) {
                for (
                  (r = this.zIndex) && I && (I.handleZ = !0),
                    w = V.childNodes,
                    X = w.length - 1;
                  0 <= X && !x;
                  X--
                )
                  (I = w[X]),
                    (W = I.getAttribute("data-z-index")),
                    (R = !g(W)),
                    I !== B &&
                      (0 > r && R && !L && !X
                        ? (V.insertBefore(B, w[X]), (x = !0))
                        : (t(W) <= r || (R && (!g(r) || 0 <= r))) &&
                          (V.insertBefore(B, w[X + 1]), (x = !0)));
                x || (V.insertBefore(B, w[L ? 3 : 0]), (x = !0));
              }
              return x;
            }
          }
          return (
            (a.symbolCustomAttribs =
              "anchorX anchorY clockwise end height innerR r start width x y".split(
                " "
              )),
            (a.prototype.strokeSetter = a.prototype.fillSetter),
            (a.prototype.yGetter = a.prototype.xGetter),
            (a.prototype.matrixSetter =
              a.prototype.rotationOriginXSetter =
              a.prototype.rotationOriginYSetter =
              a.prototype.rotationSetter =
              a.prototype.scaleXSetter =
              a.prototype.scaleYSetter =
              a.prototype.translateXSetter =
              a.prototype.translateYSetter =
              a.prototype.verticalAlignSetter =
                function (b, r) {
                  (this[r] = b), (this.doTransform = !0);
                }),
            a
          );
        }
      ),
      T(
        y,
        "Core/Renderer/RendererRegistry.js",
        [y["Core/Globals.js"]],
        function (A) {
          var O;
          return (
            (function (F) {
              F.rendererTypes = {};
              let G;
              (F.getRendererType = function (U = G) {
                return F.rendererTypes[U] || F.rendererTypes[G];
              }),
                (F.registerRendererType = function (U, H, Y) {
                  (F.rendererTypes[U] = H),
                    (!G || Y) && ((G = U), (A.Renderer = H));
                });
            })(O || (O = {})),
            O
          );
        }
      ),
      T(
        y,
        "Core/Renderer/SVG/SVGLabel.js",
        [y["Core/Renderer/SVG/SVGElement.js"], y["Core/Utilities.js"]],
        function (A, O) {
          const {
            defined: F,
            extend: G,
            isNumber: U,
            merge: H,
            pick: Y,
            removeEvent: S,
          } = O;
          class N extends A {
            constructor(c, p, f, u, n, d, g, M, C, P) {
              super(),
                (this.paddingRightSetter = this.paddingLeftSetter =
                  this.paddingSetter),
                this.init(c, "g"),
                (this.textStr = p),
                (this.x = f),
                (this.y = u),
                (this.anchorX = d),
                (this.anchorY = g),
                (this.baseline = C),
                (this.className = P),
                this.addClass(
                  P === "button" ? "highcharts-no-tooltip" : "highcharts-label"
                ),
                P && this.addClass("highcharts-" + P),
                (this.text = c.text(void 0, 0, 0, M).attr({ zIndex: 1 }));
              let j;
              typeof n == "string" &&
                ((j = /^url\((.*?)\)$/.test(n)) || this.renderer.symbols[n]) &&
                (this.symbolKey = n),
                (this.bBox = N.emptyBBox),
                (this.padding = 3),
                (this.baselineOffset = 0),
                (this.needsBox = c.styledMode || j),
                (this.deferredAttr = {}),
                (this.alignFactor = 0);
            }
            alignSetter(c) {
              (c = { left: 0, center: 0.5, right: 1 }[c]),
                c !== this.alignFactor &&
                  ((this.alignFactor = c),
                  this.bBox &&
                    U(this.xSetting) &&
                    this.attr({ x: this.xSetting }));
            }
            anchorXSetter(c, p) {
              (this.anchorX = c),
                this.boxAttr(
                  p,
                  Math.round(c) - this.getCrispAdjust() - this.xSetting
                );
            }
            anchorYSetter(c, p) {
              (this.anchorY = c), this.boxAttr(p, c - this.ySetting);
            }
            boxAttr(c, p) {
              this.box ? this.box.attr(c, p) : (this.deferredAttr[c] = p);
            }
            css(c) {
              if (c) {
                const p = {};
                (c = H(c)),
                  N.textProps.forEach((f) => {
                    typeof c[f] < "u" && ((p[f] = c[f]), delete c[f]);
                  }),
                  this.text.css(p),
                  "fontSize" in p || "fontWeight" in p
                    ? this.updateTextPadding()
                    : ("width" in p || "textOverflow" in p) &&
                      this.updateBoxSize();
              }
              return A.prototype.css.call(this, c);
            }
            destroy() {
              S(this.element, "mouseenter"),
                S(this.element, "mouseleave"),
                this.text && this.text.destroy(),
                this.box && (this.box = this.box.destroy()),
                A.prototype.destroy.call(this);
            }
            fillSetter(c, p) {
              c && (this.needsBox = !0), (this.fill = c), this.boxAttr(p, c);
            }
            getBBox() {
              this.textStr &&
                this.bBox.width === 0 &&
                this.bBox.height === 0 &&
                this.updateBoxSize();
              const c = this.padding,
                p = Y(this.paddingLeft, c);
              return {
                width: this.width,
                height: this.height,
                x: this.bBox.x - p,
                y: this.bBox.y - c,
              };
            }
            getCrispAdjust() {
              return this.renderer.styledMode && this.box
                ? (this.box.strokeWidth() % 2) / 2
                : ((this["stroke-width"]
                    ? parseInt(this["stroke-width"], 10)
                    : 0) %
                    2) /
                    2;
            }
            heightSetter(c) {
              this.heightSetting = c;
            }
            onAdd() {
              this.text.add(this),
                this.attr({
                  text: Y(this.textStr, ""),
                  x: this.x || 0,
                  y: this.y || 0,
                }),
                this.box &&
                  F(this.anchorX) &&
                  this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
            }
            paddingSetter(c, p) {
              U(c)
                ? c !== this[p] && ((this[p] = c), this.updateTextPadding())
                : (this[p] = void 0);
            }
            rSetter(c, p) {
              this.boxAttr(p, c);
            }
            strokeSetter(c, p) {
              (this.stroke = c), this.boxAttr(p, c);
            }
            "stroke-widthSetter"(c, p) {
              c && (this.needsBox = !0),
                (this["stroke-width"] = c),
                this.boxAttr(p, c);
            }
            "text-alignSetter"(c) {
              this.textAlign = c;
            }
            textSetter(c) {
              typeof c < "u" && this.text.attr({ text: c }),
                this.updateTextPadding();
            }
            updateBoxSize() {
              var c = this.text;
              const p = {},
                f = this.padding,
                u = (this.bBox =
                  (U(this.widthSetting) &&
                    U(this.heightSetting) &&
                    !this.textAlign) ||
                  !F(c.textStr)
                    ? N.emptyBBox
                    : c.getBBox());
              (this.width = this.getPaddedWidth()),
                (this.height = (this.heightSetting || u.height || 0) + 2 * f);
              const n = this.renderer.fontMetrics(c);
              (this.baselineOffset =
                f +
                Math.min(
                  (this.text.firstLineMetrics || n).b,
                  u.height || 1 / 0
                )),
                this.heightSetting &&
                  (this.baselineOffset += (this.heightSetting - n.h) / 2),
                this.needsBox &&
                  !c.textPath &&
                  (this.box ||
                    ((c = this.box =
                      this.symbolKey
                        ? this.renderer.symbol(this.symbolKey)
                        : this.renderer.rect()),
                    c.addClass(
                      (this.className === "button"
                        ? ""
                        : "highcharts-label-box") +
                        (this.className
                          ? " highcharts-" + this.className + "-box"
                          : "")
                    ),
                    c.add(this)),
                  (c = this.getCrispAdjust()),
                  (p.x = c),
                  (p.y = (this.baseline ? -this.baselineOffset : 0) + c),
                  (p.width = Math.round(this.width)),
                  (p.height = Math.round(this.height)),
                  this.box.attr(G(p, this.deferredAttr)),
                  (this.deferredAttr = {}));
            }
            updateTextPadding() {
              const c = this.text;
              if (!c.textPath) {
                this.updateBoxSize();
                const p = this.baseline ? 0 : this.baselineOffset;
                let f = Y(this.paddingLeft, this.padding);
                F(this.widthSetting) &&
                  this.bBox &&
                  (this.textAlign === "center" || this.textAlign === "right") &&
                  (f +=
                    { center: 0.5, right: 1 }[this.textAlign] *
                    (this.widthSetting - this.bBox.width)),
                  (f !== c.x || p !== c.y) &&
                    (c.attr("x", f),
                    c.hasBoxWidthChanged && (this.bBox = c.getBBox(!0)),
                    typeof p < "u" && c.attr("y", p)),
                  (c.x = f),
                  (c.y = p);
              }
            }
            widthSetter(c) {
              this.widthSetting = U(c) ? c : void 0;
            }
            getPaddedWidth() {
              var c = this.padding;
              const p = Y(this.paddingLeft, c);
              return (
                (c = Y(this.paddingRight, c)),
                (this.widthSetting || this.bBox.width || 0) + p + c
              );
            }
            xSetter(c) {
              (this.x = c),
                this.alignFactor &&
                  ((c -= this.alignFactor * this.getPaddedWidth()),
                  (this["forceAnimate:x"] = !0)),
                (this.xSetting = Math.round(c)),
                this.attr("translateX", this.xSetting);
            }
            ySetter(c) {
              (this.ySetting = this.y = Math.round(c)),
                this.attr("translateY", this.ySetting);
            }
          }
          return (
            (N.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }),
            (N.textProps =
              "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow whiteSpace width".split(
                " "
              )),
            N
          );
        }
      ),
      T(
        y,
        "Core/Renderer/SVG/Symbols.js",
        [y["Core/Utilities.js"]],
        function (A) {
          function O(S, N, D, c, p) {
            const f = [];
            if (p) {
              const u = p.start || 0,
                n = Y(p.r, D);
              (D = Y(p.r, c || D)), (c = (p.end || 0) - 0.001);
              const d = p.innerR,
                g = Y(p.open, 0.001 > Math.abs((p.end || 0) - u - 2 * Math.PI)),
                M = Math.cos(u),
                C = Math.sin(u),
                P = Math.cos(c),
                j = Math.sin(c),
                m = Y(p.longArc, 0.001 > c - u - Math.PI ? 0 : 1);
              let h = [
                "A",
                n,
                D,
                0,
                m,
                Y(p.clockwise, 1),
                S + n * P,
                N + D * j,
              ];
              (h.params = { start: u, end: c, cx: S, cy: N }),
                f.push(["M", S + n * M, N + D * C], h),
                U(d) &&
                  ((h = [
                    "A",
                    d,
                    d,
                    0,
                    m,
                    U(p.clockwise) ? 1 - p.clockwise : 0,
                    S + d * M,
                    N + d * C,
                  ]),
                  (h.params = { start: c, end: u, cx: S, cy: N }),
                  f.push(
                    g
                      ? ["M", S + d * P, N + d * j]
                      : ["L", S + d * P, N + d * j],
                    h
                  )),
                g || f.push(["Z"]);
            }
            return f;
          }
          function F(S, N, D, c, p) {
            return p && p.r
              ? G(S, N, D, c, p)
              : [
                  ["M", S, N],
                  ["L", S + D, N],
                  ["L", S + D, N + c],
                  ["L", S, N + c],
                  ["Z"],
                ];
          }
          function G(S, N, D, c, p) {
            return (
              (p = (p == null ? void 0 : p.r) || 0),
              [
                ["M", S + p, N],
                ["L", S + D - p, N],
                ["A", p, p, 0, 0, 1, S + D, N + p],
                ["L", S + D, N + c - p],
                ["A", p, p, 0, 0, 1, S + D - p, N + c],
                ["L", S + p, N + c],
                ["A", p, p, 0, 0, 1, S, N + c - p],
                ["L", S, N + p],
                ["A", p, p, 0, 0, 1, S + p, N],
                ["Z"],
              ]
            );
          }
          const { defined: U, isNumber: H, pick: Y } = A;
          return {
            arc: O,
            callout: function (S, N, D, c, p) {
              const f = Math.min((p && p.r) || 0, D, c),
                u = f + 6,
                n = p && p.anchorX;
              p = (p && p.anchorY) || 0;
              const d = G(S, N, D, c, { r: f });
              return (
                H(n) &&
                  (S + n >= D
                    ? p > N + u && p < N + c - u
                      ? d.splice(
                          3,
                          1,
                          ["L", S + D, p - 6],
                          ["L", S + D + 6, p],
                          ["L", S + D, p + 6],
                          ["L", S + D, N + c - f]
                        )
                      : d.splice(
                          3,
                          1,
                          ["L", S + D, c / 2],
                          ["L", n, p],
                          ["L", S + D, c / 2],
                          ["L", S + D, N + c - f]
                        )
                    : 0 >= S + n
                    ? p > N + u && p < N + c - u
                      ? d.splice(
                          7,
                          1,
                          ["L", S, p + 6],
                          ["L", S - 6, p],
                          ["L", S, p - 6],
                          ["L", S, N + f]
                        )
                      : d.splice(
                          7,
                          1,
                          ["L", S, c / 2],
                          ["L", n, p],
                          ["L", S, c / 2],
                          ["L", S, N + f]
                        )
                    : p && p > c && n > S + u && n < S + D - u
                    ? d.splice(
                        5,
                        1,
                        ["L", n + 6, N + c],
                        ["L", n, N + c + 6],
                        ["L", n - 6, N + c],
                        ["L", S + f, N + c]
                      )
                    : p &&
                      0 > p &&
                      n > S + u &&
                      n < S + D - u &&
                      d.splice(
                        1,
                        1,
                        ["L", n - 6, N],
                        ["L", n, N - 6],
                        ["L", n + 6, N],
                        ["L", D - f, N]
                      )),
                d
              );
            },
            circle: function (S, N, D, c) {
              return O(S + D / 2, N + c / 2, D / 2, c / 2, {
                start: 0.5 * Math.PI,
                end: 2.5 * Math.PI,
                open: !1,
              });
            },
            diamond: function (S, N, D, c) {
              return [
                ["M", S + D / 2, N],
                ["L", S + D, N + c / 2],
                ["L", S + D / 2, N + c],
                ["L", S, N + c / 2],
                ["Z"],
              ];
            },
            rect: F,
            roundedRect: G,
            square: F,
            triangle: function (S, N, D, c) {
              return [
                ["M", S + D / 2, N],
                ["L", S + D, N + c],
                ["L", S, N + c],
                ["Z"],
              ];
            },
            "triangle-down": function (S, N, D, c) {
              return [
                ["M", S, N],
                ["L", S + D, N],
                ["L", S + D / 2, N + c],
                ["Z"],
              ];
            },
          };
        }
      ),
      T(
        y,
        "Core/Renderer/SVG/TextBuilder.js",
        [
          y["Core/Renderer/HTML/AST.js"],
          y["Core/Globals.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { doc: G, SVG_NS: U, win: H } = O,
            {
              attr: Y,
              extend: S,
              fireEvent: N,
              isString: D,
              objectEach: c,
              pick: p,
            } = F;
          class f {
            constructor(n) {
              const d = n.styles;
              (this.renderer = n.renderer),
                (this.svgElement = n),
                (this.width = n.textWidth),
                (this.textLineHeight = d && d.lineHeight),
                (this.textOutline = d && d.textOutline),
                (this.ellipsis = !(!d || d.textOverflow !== "ellipsis")),
                (this.noWrap = !(!d || d.whiteSpace !== "nowrap"));
            }
            buildSVG() {
              const n = this.svgElement,
                d = n.element;
              var g = n.renderer,
                M = p(n.textStr, "").toString();
              const C = M.indexOf("<") !== -1,
                P = d.childNodes;
              g = !n.added && g.box;
              const j = /<br.*?>/g;
              var m = [
                M,
                this.ellipsis,
                this.noWrap,
                this.textLineHeight,
                this.textOutline,
                n.getStyle("font-size"),
                this.width,
              ].join();
              if (m !== n.textCache) {
                for (n.textCache = m, delete n.actualWidth, m = P.length; m--; )
                  d.removeChild(P[m]);
                C ||
                this.ellipsis ||
                this.width ||
                n.textPath ||
                (M.indexOf(" ") !== -1 && (!this.noWrap || j.test(M)))
                  ? M !== "" &&
                    (g && g.appendChild(d),
                    (M = new A(M)),
                    this.modifyTree(M.nodes),
                    M.addToDOM(d),
                    this.modifyDOM(),
                    this.ellipsis &&
                      (d.textContent || "").indexOf("…") !== -1 &&
                      n.attr(
                        "title",
                        this.unescapeEntities(n.textStr || "", ["&lt;", "&gt;"])
                      ),
                    g && g.removeChild(d))
                  : d.appendChild(G.createTextNode(this.unescapeEntities(M))),
                  D(this.textOutline) &&
                    n.applyTextOutline &&
                    n.applyTextOutline(this.textOutline);
              }
            }
            modifyDOM() {
              const n = this.svgElement,
                d = Y(n.element, "x");
              n.firstLineMetrics = void 0;
              let g;
              for (
                ;
                (g = n.element.firstChild) &&
                /^[\s\u200B]*$/.test(g.textContent || " ");

              )
                n.element.removeChild(g);
              [].forEach.call(
                n.element.querySelectorAll("tspan.highcharts-br"),
                (j, m) => {
                  j.nextSibling &&
                    j.previousSibling &&
                    (m === 0 &&
                      j.previousSibling.nodeType === 1 &&
                      (n.firstLineMetrics = n.renderer.fontMetrics(
                        j.previousSibling
                      )),
                    Y(j, { dy: this.getLineHeight(j.nextSibling), x: d }));
                }
              );
              const M = this.width || 0;
              if (M) {
                var C = (j, m) => {
                    var h = j.textContent || "";
                    const v = h.replace(/([^\^])-/g, "$1- ").split(" ");
                    var l =
                      !this.noWrap &&
                      (1 < v.length || 1 < n.element.childNodes.length);
                    const o = this.getLineHeight(m);
                    let i = 0,
                      t = n.actualWidth;
                    if (this.ellipsis)
                      h &&
                        this.truncate(
                          j,
                          h,
                          void 0,
                          0,
                          Math.max(0, M - 0.8 * o),
                          (e, s) => e.substring(0, s) + "…"
                        );
                    else if (l) {
                      for (h = [], l = []; m.firstChild && m.firstChild !== j; )
                        l.push(m.firstChild), m.removeChild(m.firstChild);
                      for (; v.length; )
                        v.length &&
                          !this.noWrap &&
                          0 < i &&
                          (h.push(j.textContent || ""),
                          (j.textContent = v.join(" ").replace(/- /g, "-"))),
                          this.truncate(
                            j,
                            void 0,
                            v,
                            (i === 0 && t) || 0,
                            M,
                            (e, s) =>
                              v.slice(0, s).join(" ").replace(/- /g, "-")
                          ),
                          (t = n.actualWidth),
                          i++;
                      l.forEach((e) => {
                        m.insertBefore(e, j);
                      }),
                        h.forEach((e) => {
                          m.insertBefore(G.createTextNode(e), j),
                            (e = G.createElementNS(U, "tspan")),
                            (e.textContent = "​"),
                            Y(e, { dy: o, x: d }),
                            m.insertBefore(e, j);
                        });
                    }
                  },
                  P = (j) => {
                    [].slice.call(j.childNodes).forEach((m) => {
                      m.nodeType === H.Node.TEXT_NODE
                        ? C(m, j)
                        : (m.className.baseVal.indexOf("highcharts-br") !==
                            -1 && (n.actualWidth = 0),
                          P(m));
                    });
                  };
                P(n.element);
              }
            }
            getLineHeight(n) {
              return (
                (n = n.nodeType === H.Node.TEXT_NODE ? n.parentElement : n),
                this.textLineHeight
                  ? parseInt(this.textLineHeight.toString(), 10)
                  : this.renderer.fontMetrics(n || this.svgElement.element).h
              );
            }
            modifyTree(n) {
              const d = (g, M) => {
                const {
                    attributes: C = {},
                    children: P,
                    style: j = {},
                    tagName: m,
                  } = g,
                  h = this.renderer.styledMode;
                m === "b" || m === "strong"
                  ? h
                    ? (C.class = "highcharts-strong")
                    : (j.fontWeight = "bold")
                  : (m === "i" || m === "em") &&
                    (h
                      ? (C.class = "highcharts-emphasized")
                      : (j.fontStyle = "italic")),
                  j && j.color && (j.fill = j.color),
                  m === "br"
                    ? ((C.class = "highcharts-br"),
                      (g.textContent = "​"),
                      (M = n[M + 1]) &&
                        M.textContent &&
                        (M.textContent = M.textContent.replace(/^ +/gm, "")))
                    : m === "a" &&
                      P &&
                      P.some((v) => v.tagName === "#text") &&
                      (g.children = [{ children: P, tagName: "tspan" }]),
                  m !== "#text" && m !== "a" && (g.tagName = "tspan"),
                  S(g, { attributes: C, style: j }),
                  P && P.filter((v) => v.tagName !== "#text").forEach(d);
              };
              n.forEach(d), N(this.svgElement, "afterModifyTree", { nodes: n });
            }
            truncate(n, d, g, M, C, P) {
              const j = this.svgElement,
                { rotation: m } = j,
                h = [];
              let v = g ? 1 : 0,
                l = (d || g || "").length,
                o = l,
                i,
                t;
              const e = function (s, a) {
                if (
                  ((s = a || s),
                  (a = n.parentNode) &&
                    typeof h[s] > "u" &&
                    a.getSubStringLength)
                )
                  try {
                    h[s] = M + a.getSubStringLength(0, g ? s + 1 : s);
                  } catch {}
                return h[s];
              };
              if (
                ((j.rotation = 0), (t = e(n.textContent.length)), M + t > C)
              ) {
                for (; v <= l; )
                  (o = Math.ceil((v + l) / 2)),
                    g && (i = P(g, o)),
                    (t = e(o, i && i.length - 1)),
                    v === l ? (v = l + 1) : t > C ? (l = o - 1) : (v = o);
                l === 0
                  ? (n.textContent = "")
                  : (d && l === d.length - 1) ||
                    (n.textContent = i || P(d || g, o));
              }
              g && g.splice(0, o), (j.actualWidth = t), (j.rotation = m);
            }
            unescapeEntities(n, d) {
              return (
                c(this.renderer.escapes, function (g, M) {
                  (d && d.indexOf(g) !== -1) ||
                    (n = n.toString().replace(new RegExp(g, "g"), M));
                }),
                n
              );
            }
          }
          return f;
        }
      ),
      T(
        y,
        "Core/Renderer/SVG/SVGRenderer.js",
        [
          y["Core/Renderer/HTML/AST.js"],
          y["Core/Color/Color.js"],
          y["Core/Globals.js"],
          y["Core/Renderer/RendererRegistry.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Renderer/SVG/SVGLabel.js"],
          y["Core/Renderer/SVG/Symbols.js"],
          y["Core/Renderer/SVG/TextBuilder.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y, S, N) {
          const {
              charts: D,
              deg2rad: c,
              doc: p,
              isFirefox: f,
              isMS: u,
              isWebKit: n,
              noop: d,
              SVG_NS: g,
              symbolSizes: M,
              win: C,
            } = F,
            {
              addEvent: P,
              attr: j,
              createElement: m,
              css: h,
              defined: v,
              destroyObjectProperties: l,
              extend: o,
              isArray: i,
              isNumber: t,
              isObject: e,
              isString: s,
              merge: a,
              pick: b,
              pInt: r,
              uniqueKey: w,
            } = N;
          let L;
          class I {
            constructor(B, x, R, W, X, Z, E) {
              (this.width =
                this.url =
                this.style =
                this.imgCount =
                this.height =
                this.gradients =
                this.globalAnimation =
                this.defs =
                this.chartIndex =
                this.cacheKeys =
                this.cache =
                this.boxWrapper =
                this.box =
                this.alignedObjects =
                  void 0),
                this.init(B, x, R, W, X, Z, E);
            }
            init(B, x, R, W, X, Z, E) {
              const _ = this.createElement("svg").attr({
                  version: "1.1",
                  class: "highcharts-root",
                }),
                z = _.element;
              E || _.css(this.getStyle(W)),
                B.appendChild(z),
                j(B, "dir", "ltr"),
                B.innerHTML.indexOf("xmlns") === -1 &&
                  j(z, "xmlns", this.SVG_NS),
                (this.box = z),
                (this.boxWrapper = _),
                (this.alignedObjects = []),
                (this.url = this.getReferenceURL()),
                this.createElement("desc")
                  .add()
                  .element.appendChild(
                    p.createTextNode("Created with Highcharts 11.1.0")
                  ),
                (this.defs = this.createElement("defs").add()),
                (this.allowHTML = Z),
                (this.forExport = X),
                (this.styledMode = E),
                (this.gradients = {}),
                (this.cache = {}),
                (this.cacheKeys = []),
                (this.imgCount = 0),
                (this.rootFontSize = _.getStyle("font-size")),
                this.setSize(x, R, !1);
              let J;
              f &&
                B.getBoundingClientRect &&
                ((x = function () {
                  h(B, { left: 0, top: 0 }),
                    (J = B.getBoundingClientRect()),
                    h(B, {
                      left: Math.ceil(J.left) - J.left + "px",
                      top: Math.ceil(J.top) - J.top + "px",
                    });
                }),
                x(),
                (this.unSubPixelFix = P(C, "resize", x)));
            }
            definition(B) {
              return new A([B]).addToDOM(this.defs.element);
            }
            getReferenceURL() {
              if ((f || n) && p.getElementsByTagName("base").length) {
                if (!v(L)) {
                  var B = w();
                  (B = new A([
                    {
                      tagName: "svg",
                      attributes: { width: 8, height: 8 },
                      children: [
                        {
                          tagName: "defs",
                          children: [
                            {
                              tagName: "clipPath",
                              attributes: { id: B },
                              children: [
                                {
                                  tagName: "rect",
                                  attributes: { width: 4, height: 4 },
                                },
                              ],
                            },
                          ],
                        },
                        {
                          tagName: "rect",
                          attributes: {
                            id: "hitme",
                            width: 8,
                            height: 8,
                            "clip-path": `url(#${B})`,
                            fill: "rgba(0,0,0,0.001)",
                          },
                        },
                      ],
                    },
                  ]).addToDOM(p.body)),
                    h(B, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
                  const x = p.elementFromPoint(6, 6);
                  (L = (x && x.id) === "hitme"), p.body.removeChild(B);
                }
                if (L)
                  return C.location.href
                    .split("#")[0]
                    .replace(/<[^>]*>/g, "")
                    .replace(/([\('\)])/g, "\\$1")
                    .replace(/ /g, "%20");
              }
              return "";
            }
            getStyle(B) {
              return (this.style = o(
                {
                  fontFamily: "Helvetica, Arial, sans-serif",
                  fontSize: "1rem",
                },
                B
              ));
            }
            setStyle(B) {
              this.boxWrapper.css(this.getStyle(B));
            }
            isHidden() {
              return !this.boxWrapper.getBBox().width;
            }
            destroy() {
              const B = this.defs;
              return (
                (this.box = null),
                (this.boxWrapper = this.boxWrapper.destroy()),
                l(this.gradients || {}),
                (this.gradients = null),
                (this.defs = B.destroy()),
                this.unSubPixelFix && this.unSubPixelFix(),
                (this.alignedObjects = null)
              );
            }
            createElement(B) {
              const x = new this.Element();
              return x.init(this, B), x;
            }
            getRadialAttr(B, x) {
              return {
                cx: B[0] - B[2] / 2 + (x.cx || 0) * B[2],
                cy: B[1] - B[2] / 2 + (x.cy || 0) * B[2],
                r: (x.r || 0) * B[2],
              };
            }
            shadowDefinition(B) {
              const x = [
                  `highcharts-drop-shadow-${this.chartIndex}`,
                  ...Object.keys(B).map((W) => B[W]),
                ]
                  .join("-")
                  .replace(/[^a-z0-9\-]/g, ""),
                R = a(
                  {
                    color: "#000000",
                    offsetX: 1,
                    offsetY: 1,
                    opacity: 0.15,
                    width: 5,
                  },
                  B
                );
              return (
                this.defs.element.querySelector(`#${x}`) ||
                  this.definition({
                    tagName: "filter",
                    attributes: { id: x },
                    children: [
                      {
                        tagName: "feDropShadow",
                        attributes: {
                          dx: R.offsetX,
                          dy: R.offsetY,
                          "flood-color": R.color,
                          "flood-opacity": Math.min(5 * R.opacity, 1),
                          stdDeviation: R.width / 2,
                        },
                      },
                    ],
                  }),
                x
              );
            }
            buildText(B) {
              new S(B).buildSVG();
            }
            getContrast(B) {
              return (
                (B = O.parse(B).rgba.map(
                  (x) => (
                    (x /= 255),
                    0.03928 >= x
                      ? x / 12.92
                      : Math.pow((x + 0.055) / 1.055, 2.4)
                  )
                )),
                (B = 0.2126 * B[0] + 0.7152 * B[1] + 0.0722 * B[2]),
                1.05 / (B + 0.05) > (B + 0.05) / 0.05 ? "#FFFFFF" : "#000000"
              );
            }
            button(B, x, R, W, X = {}, Z, E, _, z, J) {
              const tt = this.label(
                  B,
                  x,
                  R,
                  z,
                  void 0,
                  void 0,
                  J,
                  void 0,
                  "button"
                ),
                $ = this.styledMode;
              B = X.states || {};
              let it = 0;
              (X = a(X)), delete X.states;
              const nt = a(
                {
                  color: "#333333",
                  cursor: "pointer",
                  fontSize: "0.8em",
                  fontWeight: "normal",
                },
                X.style
              );
              delete X.style;
              let rt = A.filterUserAttributes(X);
              tt.attr(a({ padding: 8, r: 2 }, rt));
              let at, ct, Q;
              return (
                $ ||
                  ((rt = a(
                    { fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 },
                    rt
                  )),
                  (Z = a(
                    rt,
                    { fill: "#e6e6e6" },
                    A.filterUserAttributes(Z || B.hover || {})
                  )),
                  (at = Z.style),
                  delete Z.style,
                  (E = a(
                    rt,
                    {
                      fill: "#e6e9ff",
                      style: { color: "#000000", fontWeight: "bold" },
                    },
                    A.filterUserAttributes(E || B.select || {})
                  )),
                  (ct = E.style),
                  delete E.style,
                  (_ = a(
                    rt,
                    { style: { color: "#cccccc" } },
                    A.filterUserAttributes(_ || B.disabled || {})
                  )),
                  (Q = _.style),
                  delete _.style),
                P(tt.element, u ? "mouseover" : "mouseenter", function () {
                  it !== 3 && tt.setState(1);
                }),
                P(tt.element, u ? "mouseout" : "mouseleave", function () {
                  it !== 3 && tt.setState(it);
                }),
                (tt.setState = function (K) {
                  K !== 1 && (tt.state = it = K),
                    tt
                      .removeClass(
                        /highcharts-button-(normal|hover|pressed|disabled)/
                      )
                      .addClass(
                        "highcharts-button-" +
                          ["normal", "hover", "pressed", "disabled"][K || 0]
                      ),
                    $ ||
                      (tt.attr([rt, Z, E, _][K || 0]),
                      (K = [nt, at, ct, Q][K || 0]),
                      e(K) && tt.css(K));
                }),
                $ ||
                  (tt.attr(rt).css(o({ cursor: "default" }, nt)),
                  J && tt.text.css({ pointerEvents: "none" })),
                tt
                  .on("touchstart", (K) => K.stopPropagation())
                  .on("click", function (K) {
                    it !== 3 && W.call(tt, K);
                  })
              );
            }
            crispLine(B, x, R = "round") {
              const W = B[0],
                X = B[1];
              return (
                v(W[1]) &&
                  W[1] === X[1] &&
                  (W[1] = X[1] = Math[R](W[1]) - (x % 2) / 2),
                v(W[2]) &&
                  W[2] === X[2] &&
                  (W[2] = X[2] = Math[R](W[2]) + (x % 2) / 2),
                B
              );
            }
            path(B) {
              const x = this.styledMode ? {} : { fill: "none" };
              return (
                i(B) ? (x.d = B) : e(B) && o(x, B),
                this.createElement("path").attr(x)
              );
            }
            circle(B, x, R) {
              return (
                (B = e(B) ? B : typeof B > "u" ? {} : { x: B, y: x, r: R }),
                (x = this.createElement("circle")),
                (x.xSetter = x.ySetter =
                  function (W, X, Z) {
                    Z.setAttribute("c" + X, W);
                  }),
                x.attr(B)
              );
            }
            arc(B, x, R, W, X, Z) {
              return (
                e(B)
                  ? ((W = B), (x = W.y), (R = W.r), (B = W.x))
                  : (W = { innerR: W, start: X, end: Z }),
                (B = this.symbol("arc", B, x, R, R, W)),
                (B.r = R),
                B
              );
            }
            rect(B, x, R, W, X, Z) {
              B = e(B)
                ? B
                : typeof B > "u"
                ? {}
                : {
                    x: B,
                    y: x,
                    r: X,
                    width: Math.max(R || 0, 0),
                    height: Math.max(W || 0, 0),
                  };
              const E = this.createElement("rect");
              return (
                this.styledMode ||
                  (typeof Z < "u" &&
                    ((B["stroke-width"] = Z), o(B, E.crisp(B))),
                  (B.fill = "none")),
                (E.rSetter = function (_, z, J) {
                  (E.r = _), j(J, { rx: _, ry: _ });
                }),
                (E.rGetter = function () {
                  return E.r || 0;
                }),
                E.attr(B)
              );
            }
            roundedRect(B) {
              return this.symbol("roundedRect").attr(B);
            }
            setSize(B, x, R) {
              (this.width = B),
                (this.height = x),
                this.boxWrapper.animate(
                  { width: B, height: x },
                  {
                    step: function () {
                      this.attr({
                        viewBox:
                          "0 0 " +
                          this.attr("width") +
                          " " +
                          this.attr("height"),
                      });
                    },
                    duration: b(R, !0) ? void 0 : 0,
                  }
                ),
                this.alignElements();
            }
            g(B) {
              const x = this.createElement("g");
              return B ? x.attr({ class: "highcharts-" + B }) : x;
            }
            image(B, x, R, W, X, Z) {
              const E = { preserveAspectRatio: "none" };
              t(x) && (E.x = x),
                t(R) && (E.y = R),
                t(W) && (E.width = W),
                t(X) && (E.height = X);
              const _ = this.createElement("image").attr(E);
              return (
                (x = function (z) {
                  _.attr({ href: B }), Z.call(_, z);
                }),
                Z
                  ? (_.attr({
                      href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",
                    }),
                    (R = new C.Image()),
                    P(R, "load", x),
                    (R.src = B),
                    R.complete && x({}))
                  : _.attr({ href: B }),
                _
              );
            }
            symbol(B, x, R, W, X, Z) {
              const E = this,
                _ = /^url\((.*?)\)$/,
                z = _.test(B),
                J = !z && (this.symbols[B] ? B : "circle"),
                tt = J && this.symbols[J];
              let $, it, nt, rt;
              if (tt)
                typeof x == "number" &&
                  (it = tt.call(
                    this.symbols,
                    Math.round(x || 0),
                    Math.round(R || 0),
                    W || 0,
                    X || 0,
                    Z
                  )),
                  ($ = this.path(it)),
                  E.styledMode || $.attr("fill", "none"),
                  o($, {
                    symbolName: J || void 0,
                    x,
                    y: R,
                    width: W,
                    height: X,
                  }),
                  Z && o($, Z);
              else if (z) {
                nt = B.match(_)[1];
                const at = ($ = this.image(nt));
                (at.imgwidth = b(Z && Z.width, M[nt] && M[nt].width)),
                  (at.imgheight = b(Z && Z.height, M[nt] && M[nt].height)),
                  (rt = (ct) =>
                    ct.attr({ width: ct.width, height: ct.height })),
                  ["width", "height"].forEach(function (ct) {
                    at[ct + "Setter"] = function (Q, K) {
                      this[K] = Q;
                      const {
                        alignByTranslate: st,
                        element: et,
                        width: ot,
                        height: lt,
                        imgwidth: ht,
                        imgheight: mt,
                      } = this;
                      if (((Q = this["img" + K]), v(Q))) {
                        let yt = 1;
                        Z && Z.backgroundSize === "within" && ot && lt
                          ? ((yt = Math.min(ot / ht, lt / mt)),
                            j(et, {
                              width: Math.round(ht * yt),
                              height: Math.round(mt * yt),
                            }))
                          : et && et.setAttribute(K, Q),
                          st ||
                            this.translate(
                              ((ot || 0) - ht * yt) / 2,
                              ((lt || 0) - mt * yt) / 2
                            );
                      }
                    };
                  }),
                  v(x) && at.attr({ x, y: R }),
                  (at.isImg = !0),
                  v(at.imgwidth) && v(at.imgheight)
                    ? rt(at)
                    : (at.attr({ width: 0, height: 0 }),
                      m("img", {
                        onload: function () {
                          const ct = D[E.chartIndex];
                          this.width === 0 &&
                            (h(this, { position: "absolute", top: "-999em" }),
                            p.body.appendChild(this)),
                            (M[nt] = {
                              width: this.width,
                              height: this.height,
                            }),
                            (at.imgwidth = this.width),
                            (at.imgheight = this.height),
                            at.element && rt(at),
                            this.parentNode &&
                              this.parentNode.removeChild(this),
                            E.imgCount--,
                            !E.imgCount && ct && !ct.hasLoaded && ct.onload();
                        },
                        src: nt,
                      }),
                      this.imgCount++);
              }
              return $;
            }
            clipRect(B, x, R, W) {
              const X = w() + "-",
                Z = this.createElement("clipPath")
                  .attr({ id: X })
                  .add(this.defs);
              return (
                (B = this.rect(B, x, R, W, 0).add(Z)),
                (B.id = X),
                (B.clipPath = Z),
                (B.count = 0),
                B
              );
            }
            text(B, x, R, W) {
              const X = {};
              return W && (this.allowHTML || !this.forExport)
                ? this.html(B, x, R)
                : ((X.x = Math.round(x || 0)),
                  R && (X.y = Math.round(R)),
                  v(B) && (X.text = B),
                  (B = this.createElement("text").attr(X)),
                  (!W || (this.forExport && !this.allowHTML)) &&
                    (B.xSetter = function (Z, E, _) {
                      const z = _.getElementsByTagName("tspan"),
                        J = _.getAttribute(E);
                      for (let tt = 0, $; tt < z.length; tt++)
                        ($ = z[tt]),
                          $.getAttribute(E) === J && $.setAttribute(E, Z);
                      _.setAttribute(E, Z);
                    }),
                  B);
            }
            fontMetrics(B) {
              B = r(U.prototype.getStyle.call(B, "font-size") || 0);
              const x = 24 > B ? B + 3 : Math.round(1.2 * B);
              return { h: x, b: Math.round(0.8 * x), f: B };
            }
            rotCorr(B, x, R) {
              let W = B;
              return (
                x && R && (W = Math.max(W * Math.cos(x * c), 4)),
                { x: (-B / 3) * Math.sin(x * c), y: W }
              );
            }
            pathToSegments(B) {
              const x = [],
                R = [],
                W = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
              for (let X = 0; X < B.length; X++)
                s(R[0]) &&
                  t(B[X]) &&
                  R.length === W[R[0].toUpperCase()] &&
                  B.splice(X, 0, R[0].replace("M", "L").replace("m", "l")),
                  typeof B[X] == "string" &&
                    (R.length && x.push(R.slice(0)), (R.length = 0)),
                  R.push(B[X]);
              return x.push(R.slice(0)), x;
            }
            label(B, x, R, W, X, Z, E, _, z) {
              return new H(this, B, x, R, W, X, Z, E, _, z);
            }
            alignElements() {
              this.alignedObjects.forEach((B) => B.align());
            }
          }
          return (
            o(I.prototype, {
              Element: U,
              SVG_NS: g,
              escapes: {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                "'": "&#39;",
                '"': "&quot;",
              },
              symbols: Y,
              draw: d,
            }),
            G.registerRendererType("svg", I, !0),
            I
          );
        }
      ),
      T(
        y,
        "Core/Renderer/HTML/HTMLElement.js",
        [
          y["Core/Globals.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { isFirefox: G, isMS: U, isWebKit: H, win: Y } = A,
            { css: S, defined: N, extend: D, pick: c, pInt: p } = F,
            f = [];
          class u extends O {
            static compose(d) {
              if (F.pushUnique(f, d)) {
                const g = u.prototype,
                  M = d.prototype;
                (M.getSpanCorrection = g.getSpanCorrection),
                  (M.htmlCss = g.htmlCss),
                  (M.htmlGetBBox = g.htmlGetBBox),
                  (M.htmlUpdateTransform = g.htmlUpdateTransform),
                  (M.setSpanRotation = g.setSpanRotation);
              }
              return d;
            }
            getSpanCorrection(d, g, M) {
              (this.xCorr = -d * M), (this.yCorr = -g);
            }
            htmlCss(d) {
              const g = this.element.tagName === "SPAN" && d && "width" in d,
                M = c(g && d.width, void 0);
              let C;
              return (
                g && (delete d.width, (this.textWidth = M), (C = !0)),
                d &&
                  d.textOverflow === "ellipsis" &&
                  ((d.whiteSpace = "nowrap"), (d.overflow = "hidden")),
                (this.styles = D(this.styles, d)),
                S(this.element, d),
                C && this.htmlUpdateTransform(),
                this
              );
            }
            htmlGetBBox() {
              const d = this.element;
              return {
                x: d.offsetLeft,
                y: d.offsetTop,
                width: d.offsetWidth,
                height: d.offsetHeight,
              };
            }
            htmlUpdateTransform() {
              if (this.added) {
                var d = this.renderer,
                  g = this.element,
                  M = this.x || 0,
                  C = this.y || 0,
                  P = this.textAlign || "left",
                  j = { left: 0, center: 0.5, right: 1 }[P],
                  m = this.styles,
                  h = m && m.whiteSpace;
                if (
                  (S(g, {
                    marginLeft: this.translateX || 0,
                    marginTop: this.translateY || 0,
                  }),
                  g.tagName === "SPAN")
                ) {
                  m = this.rotation;
                  const l = this.textWidth && p(this.textWidth),
                    o = [
                      m,
                      P,
                      g.innerHTML,
                      this.textWidth,
                      this.textAlign,
                    ].join();
                  let i = !1;
                  if (l !== this.oldTextWidth) {
                    if (this.textPxLength) var v = this.textPxLength;
                    else
                      S(g, { width: "", whiteSpace: h || "nowrap" }),
                        (v = g.offsetWidth);
                    (l > this.oldTextWidth || v > l) &&
                      (/[ \-]/.test(g.textContent || g.innerText) ||
                        g.style.textOverflow === "ellipsis") &&
                      (S(g, {
                        width: v > l || m ? l + "px" : "auto",
                        display: "block",
                        whiteSpace: h || "normal",
                      }),
                      (this.oldTextWidth = l),
                      (i = !0));
                  }
                  (this.hasBoxWidthChanged = i),
                    o !== this.cTT &&
                      ((d = d.fontMetrics(g).b),
                      !N(m) ||
                        (m === (this.oldRotation || 0) &&
                          P === this.oldAlign) ||
                        this.setSpanRotation(m, j, d),
                      this.getSpanCorrection(
                        (!N(m) && this.textPxLength) || g.offsetWidth,
                        d,
                        j,
                        m,
                        P
                      )),
                    S(g, {
                      left: M + (this.xCorr || 0) + "px",
                      top: C + (this.yCorr || 0) + "px",
                    }),
                    (this.cTT = o),
                    (this.oldRotation = m),
                    (this.oldAlign = P);
                }
              } else this.alignOnAdd = !0;
            }
            setSpanRotation(d, g, M) {
              const C = {},
                P =
                  U && !/Edge/.test(Y.navigator.userAgent)
                    ? "-ms-transform"
                    : H
                    ? "-webkit-transform"
                    : G
                    ? "MozTransform"
                    : Y.opera
                    ? "-o-transform"
                    : void 0;
              P &&
                ((C[P] = C.transform = "rotate(" + d + "deg)"),
                (C[P + (G ? "Origin" : "-origin")] = C.transformOrigin =
                  100 * g + "% " + M + "px"),
                S(this.element, C));
            }
          }
          return u;
        }
      ),
      T(
        y,
        "Core/Renderer/HTML/HTMLRenderer.js",
        [
          y["Core/Renderer/HTML/AST.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Renderer/SVG/SVGRenderer.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          const { attr: U, createElement: H, extend: Y, pick: S } = G,
            N = [];
          class D extends F {
            static compose(p) {
              return (
                G.pushUnique(N, p) && (p.prototype.html = D.prototype.html), p
              );
            }
            html(p, f, u) {
              const n = this.createElement("span"),
                d = n.element,
                g = n.renderer,
                M = function (C, P) {
                  ["opacity", "visibility"].forEach(function (j) {
                    C[j + "Setter"] = function (m, h, v) {
                      const l = C.div ? C.div.style : P;
                      O.prototype[j + "Setter"].call(this, m, h, v),
                        l && (l[h] = m);
                    };
                  }),
                    (C.addedSetters = !0);
                };
              return (
                (n.textSetter = function (C) {
                  C !== this.textStr &&
                    (delete this.bBox,
                    delete this.oldTextWidth,
                    A.setElementHTML(this.element, S(C, "")),
                    (this.textStr = C),
                    (n.doTransform = !0));
                }),
                M(n, n.element.style),
                (n.xSetter =
                  n.ySetter =
                  n.alignSetter =
                  n.rotationSetter =
                    function (C, P) {
                      P === "align"
                        ? (n.alignValue = n.textAlign = C)
                        : (n[P] = C),
                        (n.doTransform = !0);
                    }),
                (n.afterSetters = function () {
                  this.doTransform &&
                    (this.htmlUpdateTransform(), (this.doTransform = !1));
                }),
                n
                  .attr({ text: p, x: Math.round(f), y: Math.round(u) })
                  .css({ position: "absolute" }),
                g.styledMode ||
                  n.css({
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize,
                  }),
                (d.style.whiteSpace = "nowrap"),
                (n.css = n.htmlCss),
                (n.add = function (C) {
                  const P = g.box.parentNode,
                    j = [];
                  let m;
                  if ((this.parentGroup = C)) {
                    if (((m = C.div), !m)) {
                      for (; C; ) j.push(C), (C = C.parentGroup);
                      j.reverse().forEach(function (h) {
                        function v(t, e) {
                          (h[e] = t),
                            e === "translateX"
                              ? (i.left = t + "px")
                              : (i.top = t + "px"),
                            (h.doTransform = !0);
                        }
                        const l = U(h.element, "class"),
                          o = h.styles || {};
                        m = h.div =
                          h.div ||
                          H(
                            "div",
                            l ? { className: l } : void 0,
                            {
                              position: "absolute",
                              left: (h.translateX || 0) + "px",
                              top: (h.translateY || 0) + "px",
                              display: h.display,
                              opacity: h.opacity,
                              visibility: h.visibility,
                            },
                            m || P
                          );
                        const i = m.style;
                        Y(h, {
                          classSetter: (function (t) {
                            return function (e) {
                              this.element.setAttribute("class", e),
                                (t.className = e);
                            };
                          })(m),
                          css: function (t) {
                            return (
                              n.css.call(h, t),
                              ["cursor", "pointerEvents"].forEach((e) => {
                                t[e] && (i[e] = t[e]);
                              }),
                              h
                            );
                          },
                          on: function () {
                            return (
                              j[0].div &&
                                n.on.apply(
                                  { element: j[0].div, onEvents: h.onEvents },
                                  arguments
                                ),
                              h
                            );
                          },
                          translateXSetter: v,
                          translateYSetter: v,
                        }),
                          h.addedSetters || M(h),
                          h.css(o);
                      });
                    }
                  } else m = P;
                  return (
                    m.appendChild(d),
                    (n.added = !0),
                    n.alignOnAdd && n.htmlUpdateTransform(),
                    n
                  );
                }),
                n
              );
            }
          }
          return D;
        }
      ),
      T(y, "Core/Axis/AxisDefaults.js", [], function () {
        var A;
        return (
          (function (O) {
            (O.defaultXAxisOptions = {
              alignTicks: !0,
              allowDecimals: void 0,
              panningEnabled: !0,
              zIndex: 2,
              zoomEnabled: !0,
              dateTimeLabelFormats: {
                millisecond: { main: "%H:%M:%S.%L", range: !1 },
                second: { main: "%H:%M:%S", range: !1 },
                minute: { main: "%H:%M", range: !1 },
                hour: { main: "%H:%M", range: !1 },
                day: { main: "%e %b" },
                week: { main: "%e %b" },
                month: { main: "%b '%y" },
                year: { main: "%Y" },
              },
              endOnTick: !1,
              gridLineDashStyle: "Solid",
              gridZIndex: 1,
              labels: {
                autoRotation: void 0,
                autoRotationLimit: 80,
                distance: 15,
                enabled: !0,
                indentation: 10,
                overflow: "justify",
                padding: 5,
                reserveSpace: void 0,
                rotation: void 0,
                staggerLines: 0,
                step: 0,
                useHTML: !1,
                zIndex: 7,
                style: {
                  color: "#333333",
                  cursor: "default",
                  fontSize: "0.8em",
                },
              },
              maxPadding: 0.01,
              minorGridLineDashStyle: "Solid",
              minorTickLength: 2,
              minorTickPosition: "outside",
              minorTicksPerMajor: 5,
              minPadding: 0.01,
              offset: void 0,
              opposite: !1,
              reversed: void 0,
              reversedStacks: !1,
              showEmpty: !0,
              showFirstLabel: !0,
              showLastLabel: !0,
              startOfWeek: 1,
              startOnTick: !1,
              tickLength: 10,
              tickPixelInterval: 100,
              tickmarkPlacement: "between",
              tickPosition: "outside",
              title: {
                align: "middle",
                rotation: 0,
                useHTML: !1,
                x: 0,
                y: 0,
                style: { color: "#666666", fontSize: "0.8em" },
              },
              type: "linear",
              uniqueNames: !0,
              visible: !0,
              minorGridLineColor: "#f2f2f2",
              minorGridLineWidth: 1,
              minorTickColor: "#999999",
              lineColor: "#333333",
              lineWidth: 1,
              gridLineColor: "#e6e6e6",
              gridLineWidth: void 0,
              tickColor: "#333333",
            }),
              (O.defaultYAxisOptions = {
                reversedStacks: !0,
                endOnTick: !0,
                maxPadding: 0.05,
                minPadding: 0.05,
                tickPixelInterval: 72,
                showLastLabel: !0,
                labels: { x: void 0 },
                startOnTick: !0,
                title: { rotation: 270, text: "Values" },
                stackLabels: {
                  animation: {},
                  allowOverlap: !1,
                  enabled: !1,
                  crop: !0,
                  overflow: "justify",
                  formatter: function () {
                    const { numberFormatter: F } = this.axis.chart;
                    return F(this.total || 0, -1);
                  },
                  style: {
                    color: "#000000",
                    fontSize: "0.7em",
                    fontWeight: "bold",
                    textOutline: "1px contrast",
                  },
                },
                gridLineWidth: 1,
                lineWidth: 0,
              }),
              (O.defaultLeftAxisOptions = { title: { rotation: 270 } }),
              (O.defaultRightAxisOptions = { title: { rotation: 90 } }),
              (O.defaultBottomAxisOptions = {
                labels: { autoRotation: [-45] },
                margin: 15,
                title: { rotation: 0 },
              }),
              (O.defaultTopAxisOptions = {
                labels: { autoRotation: [-45] },
                margin: 15,
                title: { rotation: 0 },
              });
          })(A || (A = {})),
          A
        );
      }),
      T(y, "Core/Foundation.js", [y["Core/Utilities.js"]], function (A) {
        const { addEvent: O, isFunction: F, objectEach: G, removeEvent: U } = A;
        var H;
        return (
          (function (Y) {
            Y.registerEventOptions = function (S, N) {
              (S.eventOptions = S.eventOptions || {}),
                G(N.events, function (D, c) {
                  S.eventOptions[c] !== D &&
                    (S.eventOptions[c] &&
                      (U(S, c, S.eventOptions[c]), delete S.eventOptions[c]),
                    F(D) &&
                      ((S.eventOptions[c] = D), O(S, c, D, { order: 0 })));
                });
            };
          })(H || (H = {})),
          H
        );
      }),
      T(
        y,
        "Core/Axis/Tick.js",
        [y["Core/Templating.js"], y["Core/Globals.js"], y["Core/Utilities.js"]],
        function (A, O, F) {
          const { deg2rad: G } = O,
            {
              clamp: U,
              correctFloat: H,
              defined: Y,
              destroyObjectProperties: S,
              extend: N,
              fireEvent: D,
              isNumber: c,
              merge: p,
              objectEach: f,
              pick: u,
            } = F;
          class n {
            constructor(g, M, C, P, j) {
              (this.isNewLabel = this.isNew = !0),
                (this.axis = g),
                (this.pos = M),
                (this.type = C || ""),
                (this.parameters = j || {}),
                (this.tickmarkOffset = this.parameters.tickmarkOffset),
                (this.options = this.parameters.options),
                D(this, "init"),
                C || P || this.addLabel();
            }
            addLabel() {
              const g = this,
                M = g.axis;
              var C = M.options;
              const P = M.chart;
              var j = M.categories;
              const m = M.logarithmic,
                h = M.names,
                v = g.pos,
                l = u(g.options && g.options.labels, C.labels);
              var o = M.tickPositions;
              const i = v === o[0],
                t = v === o[o.length - 1],
                e = (!l.step || l.step === 1) && M.tickInterval === 1;
              o = o.info;
              let s = g.label,
                a,
                b,
                r;
              (j = this.parameters.category || (j ? u(j[v], h[v], v) : v)),
                m && c(j) && (j = H(m.lin2log(j))),
                M.dateTime &&
                  (o
                    ? ((b = P.time.resolveDTLFormat(
                        C.dateTimeLabelFormats[
                          (!C.grid && o.higherRanks[v]) || o.unitName
                        ]
                      )),
                      (a = b.main))
                    : c(j) &&
                      (a = M.dateTime.getXDateFormat(
                        j,
                        C.dateTimeLabelFormats || {}
                      ))),
                (g.isFirst = i),
                (g.isLast = t);
              const w = {
                axis: M,
                chart: P,
                dateTimeLabelFormat: a,
                isFirst: i,
                isLast: t,
                pos: v,
                tick: g,
                tickPositionInfo: o,
                value: j,
              };
              D(this, "labelFormat", w);
              const L = (V) =>
                l.formatter
                  ? l.formatter.call(V, V)
                  : l.format
                  ? ((V.text = M.defaultLabelFormatter.call(V, V)),
                    A.format(l.format, V, P))
                  : M.defaultLabelFormatter.call(V, V);
              C = L.call(w, w);
              const I = b && b.list;
              (g.shortenLabel = I
                ? function () {
                    for (r = 0; r < I.length; r++)
                      if (
                        (N(w, { dateTimeLabelFormat: I[r] }),
                        s.attr({ text: L.call(w, w) }),
                        s.getBBox().width < M.getSlotWidth(g) - 2 * l.padding)
                      )
                        return;
                    s.attr({ text: "" });
                  }
                : void 0),
                e && M._addedPlotLB && g.moveLabel(C, l),
                Y(s) || g.movedLabel
                  ? s &&
                    s.textStr !== C &&
                    !e &&
                    (!s.textWidth ||
                      l.style.width ||
                      s.styles.width ||
                      s.css({ width: null }),
                    s.attr({ text: C }),
                    (s.textPxLength = s.getBBox().width))
                  : ((g.label = s = g.createLabel({ x: 0, y: 0 }, C, l)),
                    (g.rotation = 0));
            }
            createLabel(g, M, C) {
              const P = this.axis,
                j = P.chart;
              return (
                (g =
                  Y(M) && C.enabled
                    ? j.renderer.text(M, g.x, g.y, C.useHTML).add(P.labelGroup)
                    : null) &&
                  (j.styledMode || g.css(p(C.style)),
                  (g.textPxLength = g.getBBox().width)),
                g
              );
            }
            destroy() {
              S(this, this.axis);
            }
            getPosition(g, M, C, P) {
              const j = this.axis,
                m = j.chart,
                h = (P && m.oldChartHeight) || m.chartHeight;
              return (
                (g = {
                  x: g
                    ? H(j.translate(M + C, void 0, void 0, P) + j.transB)
                    : j.left +
                      j.offset +
                      (j.opposite
                        ? ((P && m.oldChartWidth) || m.chartWidth) -
                          j.right -
                          j.left
                        : 0),
                  y: g
                    ? h - j.bottom + j.offset - (j.opposite ? j.height : 0)
                    : H(h - j.translate(M + C, void 0, void 0, P) - j.transB),
                }),
                (g.y = U(g.y, -1e5, 1e5)),
                D(this, "afterGetPosition", { pos: g }),
                g
              );
            }
            getLabelPosition(g, M, C, P, j, m, h, v) {
              const l = this.axis,
                o = l.transA,
                i =
                  l.isLinked && l.linkedParent
                    ? l.linkedParent.reversed
                    : l.reversed,
                t = l.staggerLines,
                e = l.tickRotCorr || { x: 0, y: 0 },
                s =
                  P || l.reserveSpaceDefault
                    ? 0
                    : -l.labelOffset * (l.labelAlign === "center" ? 0.5 : 1),
                a = j.distance,
                b = {};
              return (
                (C =
                  l.side === 0
                    ? C.rotation
                      ? -a
                      : -C.getBBox().height
                    : l.side === 2
                    ? e.y + a
                    : Math.cos(C.rotation * G) *
                      (e.y - C.getBBox(!1, 0).height / 2)),
                Y(j.y) && (C = l.side === 0 && l.horiz ? j.y + C : j.y),
                (g =
                  g +
                  u(j.x, [0, 1, 0, -1][l.side] * a) +
                  s +
                  e.x -
                  (m && P ? m * o * (i ? -1 : 1) : 0)),
                (M = M + C - (m && !P ? m * o * (i ? 1 : -1) : 0)),
                t &&
                  ((P = (h / (v || 1)) % t),
                  l.opposite && (P = t - P - 1),
                  (M += (l.labelOffset / t) * P)),
                (b.x = g),
                (b.y = Math.round(M)),
                D(this, "afterGetLabelPosition", {
                  pos: b,
                  tickmarkOffset: m,
                  index: h,
                }),
                b
              );
            }
            getLabelSize() {
              return this.label
                ? this.label.getBBox()[this.axis.horiz ? "height" : "width"]
                : 0;
            }
            getMarkPath(g, M, C, P, j, m) {
              return m.crispLine(
                [
                  ["M", g, M],
                  ["L", g + (j ? 0 : -C), M + (j ? C : 0)],
                ],
                P
              );
            }
            handleOverflow(g) {
              const M = this.axis,
                C = M.options.labels,
                P = g.x;
              var j = M.chart.chartWidth,
                m = M.chart.spacing;
              const h = u(M.labelLeft, Math.min(M.pos, m[3]));
              m = u(
                M.labelRight,
                Math.max(M.isRadial ? 0 : M.pos + M.len, j - m[1])
              );
              const v = this.label,
                l = this.rotation,
                o = { left: 0, center: 0.5, right: 1 }[
                  M.labelAlign || v.attr("align")
                ],
                i = v.getBBox().width,
                t = M.getSlotWidth(this),
                e = {};
              let s = t,
                a = 1,
                b;
              l || C.overflow !== "justify"
                ? 0 > l && P - o * i < h
                  ? (b = Math.round(P / Math.cos(l * G) - h))
                  : 0 < l &&
                    P + o * i > m &&
                    (b = Math.round((j - P) / Math.cos(l * G)))
                : ((j = P + (1 - o) * i),
                  P - o * i < h
                    ? (s = g.x + s * (1 - o) - h)
                    : j > m && ((s = m - g.x + s * o), (a = -1)),
                  (s = Math.min(t, s)),
                  s < t &&
                    M.labelAlign === "center" &&
                    (g.x += a * (t - s - o * (t - Math.min(i, s)))),
                  (i > s || (M.autoRotation && (v.styles || {}).width)) &&
                    (b = s)),
                b &&
                  (this.shortenLabel
                    ? this.shortenLabel()
                    : ((e.width = Math.floor(b) + "px"),
                      (C.style || {}).textOverflow ||
                        (e.textOverflow = "ellipsis"),
                      v.css(e)));
            }
            moveLabel(g, M) {
              const C = this;
              var P = C.label;
              const j = C.axis;
              let m = !1;
              P && P.textStr === g
                ? ((C.movedLabel = P), (m = !0), delete C.label)
                : f(j.ticks, function (h) {
                    m ||
                      h.isNew ||
                      h === C ||
                      !h.label ||
                      h.label.textStr !== g ||
                      ((C.movedLabel = h.label),
                      (m = !0),
                      (h.labelPos = C.movedLabel.xy),
                      delete h.label);
                  }),
                m ||
                  (!C.labelPos && !P) ||
                  ((P = C.labelPos || P.xy),
                  (C.movedLabel = C.createLabel(P, g, M)),
                  C.movedLabel && C.movedLabel.attr({ opacity: 0 }));
            }
            render(g, M, C) {
              var P = this.axis,
                j = P.horiz,
                m = this.pos,
                h = u(this.tickmarkOffset, P.tickmarkOffset);
              (m = this.getPosition(j, m, h, M)), (h = m.x);
              const v = m.y;
              (P = (j && h === P.pos + P.len) || (!j && v === P.pos) ? -1 : 1),
                (j = u(C, this.label && this.label.newOpacity, 1)),
                (C = u(C, 1)),
                (this.isActive = !0),
                this.renderGridLine(M, C, P),
                this.renderMark(m, C, P),
                this.renderLabel(m, M, j, g),
                (this.isNew = !1),
                D(this, "afterRender");
            }
            renderGridLine(g, M, C) {
              const P = this.axis,
                j = P.options,
                m = {},
                h = this.pos,
                v = this.type,
                l = u(this.tickmarkOffset, P.tickmarkOffset),
                o = P.chart.renderer;
              let i = this.gridLine,
                t = j.gridLineWidth,
                e = j.gridLineColor,
                s = j.gridLineDashStyle;
              this.type === "minor" &&
                ((t = j.minorGridLineWidth),
                (e = j.minorGridLineColor),
                (s = j.minorGridLineDashStyle)),
                i ||
                  (P.chart.styledMode ||
                    ((m.stroke = e),
                    (m["stroke-width"] = t || 0),
                    (m.dashstyle = s)),
                  v || (m.zIndex = 1),
                  g && (M = 0),
                  (this.gridLine = i =
                    o
                      .path()
                      .attr(m)
                      .addClass(
                        "highcharts-" + (v ? v + "-" : "") + "grid-line"
                      )
                      .add(P.gridGroup))),
                i &&
                  (C = P.getPlotLinePath({
                    value: h + l,
                    lineWidth: i.strokeWidth() * C,
                    force: "pass",
                    old: g,
                    acrossPanes: !1,
                  })) &&
                  i[g || this.isNew ? "attr" : "animate"]({ d: C, opacity: M });
            }
            renderMark(g, M, C) {
              const P = this.axis;
              var j = P.options;
              const m = P.chart.renderer,
                h = this.type,
                v = P.tickSize(h ? h + "Tick" : "tick"),
                l = g.x;
              g = g.y;
              const o = u(
                j[h !== "minor" ? "tickWidth" : "minorTickWidth"],
                !h && P.isXAxis ? 1 : 0
              );
              j = j[h !== "minor" ? "tickColor" : "minorTickColor"];
              let i = this.mark;
              const t = !i;
              v &&
                (P.opposite && (v[0] = -v[0]),
                i ||
                  ((this.mark = i =
                    m
                      .path()
                      .addClass("highcharts-" + (h ? h + "-" : "") + "tick")
                      .add(P.axisGroup)),
                  P.chart.styledMode ||
                    i.attr({ stroke: j, "stroke-width": o })),
                i[t ? "attr" : "animate"]({
                  d: this.getMarkPath(
                    l,
                    g,
                    v[0],
                    i.strokeWidth() * C,
                    P.horiz,
                    m
                  ),
                  opacity: M,
                }));
            }
            renderLabel(g, M, C, P) {
              var j = this.axis;
              const m = j.horiz,
                h = j.options,
                v = this.label,
                l = h.labels,
                o = l.step;
              j = u(this.tickmarkOffset, j.tickmarkOffset);
              const i = g.x;
              g = g.y;
              let t = !0;
              v &&
                c(i) &&
                ((v.xy = g = this.getLabelPosition(i, g, v, m, l, j, P, o)),
                (this.isFirst && !this.isLast && !h.showFirstLabel) ||
                (this.isLast && !this.isFirst && !h.showLastLabel)
                  ? (t = !1)
                  : !m ||
                    l.step ||
                    l.rotation ||
                    M ||
                    C === 0 ||
                    this.handleOverflow(g),
                o && P % o && (t = !1),
                t && c(g.y)
                  ? ((g.opacity = C),
                    v[this.isNewLabel ? "attr" : "animate"](g).show(!0),
                    (this.isNewLabel = !1))
                  : (v.hide(), (this.isNewLabel = !0)));
            }
            replaceMovedLabel() {
              const g = this.label,
                M = this.axis;
              g &&
                !this.isNew &&
                (g.animate({ opacity: 0 }, void 0, g.destroy),
                delete this.label),
                (M.isDirty = !0),
                (this.label = this.movedLabel),
                delete this.movedLabel;
            }
          }
          return n;
        }
      ),
      T(
        y,
        "Core/Axis/Axis.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Axis/AxisDefaults.js"],
          y["Core/Color/Color.js"],
          y["Core/Defaults.js"],
          y["Core/Foundation.js"],
          y["Core/Globals.js"],
          y["Core/Axis/Tick.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y, S) {
          const { animObject: N } = A,
            { defaultOptions: D } = G,
            { registerEventOptions: c } = U,
            { deg2rad: p } = H,
            {
              arrayMax: f,
              arrayMin: u,
              clamp: n,
              correctFloat: d,
              defined: g,
              destroyObjectProperties: M,
              erase: C,
              error: P,
              extend: j,
              fireEvent: m,
              getClosestDistance: h,
              insertItem: v,
              isArray: l,
              isNumber: o,
              isString: i,
              merge: t,
              normalizeTickInterval: e,
              objectEach: s,
              pick: a,
              relativeLength: b,
              removeEvent: r,
              splat: w,
              syncTimeout: L,
            } = S,
            I = (B, x) =>
              e(
                x,
                void 0,
                void 0,
                a(B.options.allowDecimals, 0.5 > x || B.tickAmount !== void 0),
                !!B.tickAmount
              );
          class V {
            constructor(x, R, W) {
              (this.zoomEnabled =
                this.width =
                this.visible =
                this.userOptions =
                this.translationSlope =
                this.transB =
                this.transA =
                this.top =
                this.ticks =
                this.tickRotCorr =
                this.tickPositions =
                this.tickmarkOffset =
                this.tickInterval =
                this.tickAmount =
                this.side =
                this.series =
                this.right =
                this.positiveValuesOnly =
                this.pos =
                this.pointRangePadding =
                this.pointRange =
                this.plotLinesAndBandsGroups =
                this.plotLinesAndBands =
                this.paddedTicks =
                this.overlap =
                this.options =
                this.offset =
                this.names =
                this.minPixelPadding =
                this.minorTicks =
                this.minorTickInterval =
                this.min =
                this.maxLabelLength =
                this.max =
                this.len =
                this.left =
                this.labelFormatter =
                this.labelEdge =
                this.isLinked =
                this.index =
                this.height =
                this.hasVisibleSeries =
                this.hasNames =
                this.eventOptions =
                this.coll =
                this.closestPointRange =
                this.chart =
                this.bottom =
                this.alternateBands =
                  void 0),
                this.init(x, R, W);
            }
            init(x, R, W = this.coll) {
              const X = W === "xAxis";
              (this.chart = x),
                (this.horiz = this.isZAxis || (x.inverted ? !X : X)),
                (this.isXAxis = X),
                (this.coll = W),
                m(this, "init", { userOptions: R }),
                (this.opposite = a(R.opposite, this.opposite)),
                (this.side = a(
                  R.side,
                  this.side,
                  this.horiz ? (this.opposite ? 0 : 2) : this.opposite ? 1 : 3
                )),
                this.setOptions(R),
                (W = this.options);
              const Z = W.labels,
                E = W.type;
              (this.userOptions = R),
                (this.minPixelPadding = 0),
                (this.reversed = a(W.reversed, this.reversed)),
                (this.visible = W.visible),
                (this.zoomEnabled = W.zoomEnabled),
                (this.hasNames = E === "category" || W.categories === !0),
                (this.categories =
                  W.categories || (this.hasNames ? [] : void 0)),
                this.names || ((this.names = []), (this.names.keys = {})),
                (this.plotLinesAndBandsGroups = {}),
                (this.positiveValuesOnly = !!this.logarithmic),
                (this.isLinked = g(W.linkedTo)),
                (this.ticks = {}),
                (this.labelEdge = []),
                (this.minorTicks = {}),
                (this.plotLinesAndBands = []),
                (this.alternateBands = {}),
                (this.len = 0),
                (this.minRange = this.userMinRange = W.minRange || W.maxZoom),
                (this.range = W.range),
                (this.offset = W.offset || 0),
                (this.min = this.max = null),
                (R = a(
                  W.crosshair,
                  w(x.options.tooltip.crosshairs)[X ? 0 : 1]
                )),
                (this.crosshair = R === !0 ? {} : R),
                x.axes.indexOf(this) === -1 &&
                  (X
                    ? x.axes.splice(x.xAxis.length, 0, this)
                    : x.axes.push(this),
                  v(this, x[this.coll])),
                x.orderItems(this.coll),
                (this.series = this.series || []),
                x.inverted &&
                  !this.isZAxis &&
                  X &&
                  typeof this.reversed > "u" &&
                  (this.reversed = !0),
                (this.labelRotation = o(Z.rotation) ? Z.rotation : void 0),
                c(this, W),
                m(this, "afterInit");
            }
            setOptions(x) {
              (this.options = t(
                O.defaultXAxisOptions,
                this.coll === "yAxis" && O.defaultYAxisOptions,
                [
                  O.defaultTopAxisOptions,
                  O.defaultRightAxisOptions,
                  O.defaultBottomAxisOptions,
                  O.defaultLeftAxisOptions,
                ][this.side],
                t(D[this.coll], x)
              )),
                m(this, "afterSetOptions", { userOptions: x });
            }
            defaultLabelFormatter(x) {
              var R = this.axis;
              ({ numberFormatter: x } = this.chart);
              const W = o(this.value) ? this.value : NaN,
                X = R.chart.time,
                Z = this.dateTimeLabelFormat;
              var E = D.lang;
              const _ = E.numericSymbols;
              E = E.numericSymbolMagnitude || 1e3;
              const z = R.logarithmic ? Math.abs(W) : R.tickInterval;
              let J = _ && _.length,
                tt;
              if (R.categories) tt = `${this.value}`;
              else if (Z) tt = X.dateFormat(Z, W);
              else if (J && 1e3 <= z)
                for (; J-- && typeof tt > "u"; )
                  (R = Math.pow(E, J + 1)),
                    z >= R &&
                      (10 * W) % R === 0 &&
                      _[J] !== null &&
                      W !== 0 &&
                      (tt = x(W / R, -1) + _[J]);
              return (
                typeof tt > "u" &&
                  (tt = 1e4 <= Math.abs(W) ? x(W, -1) : x(W, -1, void 0, "")),
                tt
              );
            }
            getSeriesExtremes() {
              const x = this,
                R = x.chart;
              let W;
              m(this, "getSeriesExtremes", null, function () {
                (x.hasVisibleSeries = !1),
                  (x.dataMin = x.dataMax = x.threshold = null),
                  (x.softThreshold = !x.isXAxis),
                  x.series.forEach(function (X) {
                    if (X.visible || !R.options.chart.ignoreHiddenSeries) {
                      var Z = X.options;
                      let E = Z.threshold,
                        _,
                        z;
                      (x.hasVisibleSeries = !0),
                        x.positiveValuesOnly && 0 >= E && (E = null),
                        x.isXAxis
                          ? (Z = X.xData) &&
                            Z.length &&
                            ((Z = x.logarithmic ? Z.filter((J) => 0 < J) : Z),
                            (W = X.getXExtremes(Z)),
                            (_ = W.min),
                            (z = W.max),
                            o(_) ||
                              _ instanceof Date ||
                              ((Z = Z.filter(o)),
                              (W = X.getXExtremes(Z)),
                              (_ = W.min),
                              (z = W.max)),
                            Z.length &&
                              ((x.dataMin = Math.min(a(x.dataMin, _), _)),
                              (x.dataMax = Math.max(a(x.dataMax, z), z))))
                          : ((X = X.applyExtremes()),
                            o(X.dataMin) &&
                              ((_ = X.dataMin),
                              (x.dataMin = Math.min(a(x.dataMin, _), _))),
                            o(X.dataMax) &&
                              ((z = X.dataMax),
                              (x.dataMax = Math.max(a(x.dataMax, z), z))),
                            g(E) && (x.threshold = E),
                            (!Z.softThreshold || x.positiveValuesOnly) &&
                              (x.softThreshold = !1));
                    }
                  });
              }),
                m(this, "afterGetSeriesExtremes");
            }
            translate(x, R, W, X, Z, E) {
              const _ = this.linkedParent || this,
                z = X && _.old ? _.old.min : _.min;
              if (!o(z)) return NaN;
              const J = _.minPixelPadding;
              Z =
                (_.isOrdinal ||
                  (_.brokenAxis && _.brokenAxis.hasBreaks) ||
                  (_.logarithmic && Z)) &&
                _.lin2val;
              let tt = 1,
                $ = 0;
              return (
                (X = X && _.old ? _.old.transA : _.transA),
                X || (X = _.transA),
                W && ((tt *= -1), ($ = _.len)),
                _.reversed && ((tt *= -1), ($ -= tt * (_.sector || _.len))),
                R
                  ? ((E = (x * tt + $ - J) / X + z), Z && (E = _.lin2val(E)))
                  : (Z && (x = _.val2lin(x)),
                    (x = tt * (x - z) * X),
                    (E =
                      (_.isRadial ? x : d(x)) +
                      $ +
                      tt * J +
                      (o(E) ? X * E : 0))),
                E
              );
            }
            toPixels(x, R) {
              return (
                this.translate(x, !1, !this.horiz, void 0, !0) +
                (R ? 0 : this.pos)
              );
            }
            toValue(x, R) {
              return this.translate(
                x - (R ? 0 : this.pos),
                !0,
                !this.horiz,
                void 0,
                !0
              );
            }
            getPlotLinePath(x) {
              function R(et, ot, lt) {
                return (
                  rt !== "pass" &&
                    (et < ot || et > lt) &&
                    (rt ? (et = n(et, ot, lt)) : (st = !0)),
                  et
                );
              }
              const W = this,
                X = W.chart,
                Z = W.left,
                E = W.top,
                _ = x.old,
                z = x.value,
                J = x.lineWidth,
                tt = (_ && X.oldChartHeight) || X.chartHeight,
                $ = (_ && X.oldChartWidth) || X.chartWidth,
                it = W.transB;
              let nt = x.translatedValue,
                rt = x.force,
                at,
                ct,
                Q,
                K,
                st;
              return (
                (x = {
                  value: z,
                  lineWidth: J,
                  old: _,
                  force: rt,
                  acrossPanes: x.acrossPanes,
                  translatedValue: nt,
                }),
                m(this, "getPlotLinePath", x, function (et) {
                  (nt = a(nt, W.translate(z, void 0, void 0, _))),
                    (nt = n(nt, -1e5, 1e5)),
                    (at = Q = Math.round(nt + it)),
                    (ct = K = Math.round(tt - nt - it)),
                    o(nt)
                      ? W.horiz
                        ? ((ct = E),
                          (K = tt - W.bottom),
                          (at = Q = R(at, Z, Z + W.width)))
                        : ((at = Z),
                          (Q = $ - W.right),
                          (ct = K = R(ct, E, E + W.height)))
                      : ((st = !0), (rt = !1)),
                    (et.path =
                      st && !rt
                        ? null
                        : X.renderer.crispLine(
                            [
                              ["M", at, ct],
                              ["L", Q, K],
                            ],
                            J || 1
                          ));
                }),
                x.path
              );
            }
            getLinearTickPositions(x, R, W) {
              const X = d(Math.floor(R / x) * x);
              W = d(Math.ceil(W / x) * x);
              const Z = [];
              let E, _;
              if ((d(X + x) === X && (_ = 20), this.single)) return [R];
              for (R = X; R <= W && (Z.push(R), (R = d(R + x, _)), R !== E); )
                E = R;
              return Z;
            }
            getMinorTickInterval() {
              const x = this.options;
              return x.minorTicks === !0
                ? a(x.minorTickInterval, "auto")
                : x.minorTicks === !1
                ? null
                : x.minorTickInterval;
            }
            getMinorTickPositions() {
              var x = this.options;
              const R = this.tickPositions,
                W = this.minorTickInterval;
              var X = this.pointRangePadding || 0;
              const Z = this.min - X;
              X = this.max + X;
              const E = X - Z;
              let _ = [];
              if (E && E / W < this.len / 3) {
                const z = this.logarithmic;
                if (z)
                  this.paddedTicks.forEach(function (J, tt, $) {
                    tt &&
                      _.push.apply(
                        _,
                        z.getLogTickPositions(W, $[tt - 1], $[tt], !0)
                      );
                  });
                else if (
                  this.dateTime &&
                  this.getMinorTickInterval() === "auto"
                )
                  _ = _.concat(
                    this.getTimeTicks(
                      this.dateTime.normalizeTimeTickInterval(W),
                      Z,
                      X,
                      x.startOfWeek
                    )
                  );
                else
                  for (x = Z + ((R[0] - Z) % W); x <= X && x !== _[0]; x += W)
                    _.push(x);
              }
              return _.length !== 0 && this.trimTicks(_), _;
            }
            adjustForMinRange() {
              const x = this.options,
                R = this.logarithmic;
              let W = this.min;
              var X = this.max;
              let Z, E;
              if (this.isXAxis && typeof this.minRange > "u" && !R)
                if (g(x.min) || g(x.max) || g(x.floor) || g(x.ceiling))
                  this.minRange = null;
                else {
                  var _ =
                    h(
                      this.series.map((z) => {
                        var J;
                        return (
                          (z.xIncrement
                            ? (J = z.xData) === null || J === void 0
                              ? void 0
                              : J.slice(0, 2)
                            : z.xData) || []
                        );
                      })
                    ) || 0;
                  this.minRange = Math.min(5 * _, this.dataMax - this.dataMin);
                }
              X - W < this.minRange &&
                ((_ = this.dataMax - this.dataMin >= this.minRange),
                (E = this.minRange),
                (X = (E - X + W) / 2),
                (Z = [W - X, a(x.min, W - X)]),
                _ && (Z[2] = R ? R.log2lin(this.dataMin) : this.dataMin),
                (W = f(Z)),
                (X = [W + E, a(x.max, W + E)]),
                _ && (X[2] = R ? R.log2lin(this.dataMax) : this.dataMax),
                (X = u(X)),
                X - W < E &&
                  ((Z[0] = X - E), (Z[1] = a(x.min, X - E)), (W = f(Z)))),
                (this.min = W),
                (this.max = X);
            }
            getClosest() {
              let x, R;
              if (this.categories) R = 1;
              else {
                const W = [];
                this.series.forEach(function (X) {
                  var Z;
                  const E = X.closestPointRange,
                    _ = X.visible || !X.chart.options.chart.ignoreHiddenSeries;
                  ((Z = X.xData) === null || Z === void 0
                    ? void 0
                    : Z.length) === 1
                    ? W.push(X.xData[0])
                    : !X.noSharedTooltip &&
                      g(E) &&
                      _ &&
                      (R = g(R) ? Math.min(R, E) : E);
                }),
                  W.length && (W.sort((X, Z) => X - Z), (x = h([W])));
              }
              return x && R ? Math.min(x, R) : x || R;
            }
            nameToX(x) {
              const R = l(this.options.categories),
                W = R ? this.categories : this.names;
              let X = x.options.x,
                Z;
              return (
                (x.series.requireSorting = !1),
                g(X) ||
                  (X =
                    this.options.uniqueNames && W
                      ? R
                        ? W.indexOf(x.name)
                        : a(W.keys[x.name], -1)
                      : x.series.autoIncrement()),
                X === -1 ? !R && W && (Z = W.length) : (Z = X),
                typeof Z < "u"
                  ? ((this.names[Z] = x.name), (this.names.keys[x.name] = Z))
                  : x.x && (Z = x.x),
                Z
              );
            }
            updateNames() {
              const x = this,
                R = this.names;
              0 < R.length &&
                (Object.keys(R.keys).forEach(function (W) {
                  delete R.keys[W];
                }),
                (R.length = 0),
                (this.minRange = this.userMinRange),
                (this.series || []).forEach(function (W) {
                  (W.xIncrement = null),
                    (!W.points || W.isDirtyData) &&
                      ((x.max = Math.max(x.max, W.xData.length - 1)),
                      W.processData(),
                      W.generatePoints()),
                    W.data.forEach(function (X, Z) {
                      let E;
                      X &&
                        X.options &&
                        typeof X.name < "u" &&
                        ((E = x.nameToX(X)),
                        typeof E < "u" &&
                          E !== X.x &&
                          ((X.x = E), (W.xData[Z] = E)));
                    });
                }));
            }
            setAxisTranslation() {
              const x = this,
                R = x.max - x.min;
              var W = x.linkedParent;
              const X = !!x.categories,
                Z = x.isXAxis;
              let E = x.axisPointRange || 0,
                _,
                z = 0,
                J = 0,
                tt = x.transA;
              (Z || X || E) &&
                ((_ = x.getClosest()),
                W
                  ? ((z = W.minPointOffset), (J = W.pointRangePadding))
                  : x.series.forEach(function ($) {
                      const it = X
                          ? 1
                          : Z
                          ? a($.options.pointRange, _, 0)
                          : x.axisPointRange || 0,
                        nt = $.options.pointPlacement;
                      (E = Math.max(E, it)),
                        (!x.single || X) &&
                          (($ = $.is("xrange") ? !Z : Z),
                          (z = Math.max(z, $ && i(nt) ? 0 : it / 2)),
                          (J = Math.max(J, $ && nt === "on" ? 0 : it)));
                    }),
                (W =
                  x.ordinal && x.ordinal.slope && _ ? x.ordinal.slope / _ : 1),
                (x.minPointOffset = z *= W),
                (x.pointRangePadding = J *= W),
                (x.pointRange = Math.min(E, x.single && X ? 1 : R)),
                Z && _ && (x.closestPointRange = _)),
                (x.translationSlope =
                  x.transA =
                  tt =
                    x.staticScale || x.len / (R + J || 1)),
                (x.transB = x.horiz ? x.left : x.bottom),
                (x.minPixelPadding = tt * z),
                m(this, "afterSetAxisTranslation");
            }
            minFromRange() {
              return this.max - this.range;
            }
            setTickInterval(x) {
              var R = this.chart;
              const W = this.logarithmic,
                X = this.options,
                Z = this.isXAxis,
                E = this.isLinked,
                _ = X.tickPixelInterval,
                z = this.categories,
                J = this.softThreshold;
              let tt = X.maxPadding,
                $ = X.minPadding,
                it =
                  o(X.tickInterval) && 0 <= X.tickInterval
                    ? X.tickInterval
                    : void 0,
                nt = o(this.threshold) ? this.threshold : null,
                rt,
                at,
                ct;
              if (
                (this.dateTime || z || E || this.getTickAmount(),
                (at = a(this.userMin, X.min)),
                (ct = a(this.userMax, X.max)),
                E)
              ) {
                this.linkedParent = R[this.coll][X.linkedTo];
                var Q = this.linkedParent.getExtremes();
                (this.min = a(Q.min, Q.dataMin)),
                  (this.max = a(Q.max, Q.dataMax)),
                  X.type !== this.linkedParent.options.type && P(11, 1, R);
              } else
                J &&
                  g(nt) &&
                  (this.dataMin >= nt
                    ? ((Q = nt), ($ = 0))
                    : this.dataMax <= nt && ((rt = nt), (tt = 0))),
                  (this.min = a(at, Q, this.dataMin)),
                  (this.max = a(ct, rt, this.dataMax));
              if (
                (W &&
                  (this.positiveValuesOnly &&
                    !x &&
                    0 >= Math.min(this.min, a(this.dataMin, this.min)) &&
                    P(10, 1, R),
                  (this.min = d(W.log2lin(this.min), 16)),
                  (this.max = d(W.log2lin(this.max), 16))),
                this.range &&
                  g(this.max) &&
                  ((this.userMin =
                    this.min =
                    at =
                      Math.max(this.dataMin, this.minFromRange())),
                  (this.userMax = ct = this.max),
                  (this.range = null)),
                m(this, "foundExtremes"),
                this.beforePadding && this.beforePadding(),
                this.adjustForMinRange(),
                !o(this.userMin) &&
                  o(X.softMin) &&
                  X.softMin < this.min &&
                  (this.min = at = X.softMin),
                !o(this.userMax) &&
                  o(X.softMax) &&
                  X.softMax > this.max &&
                  (this.max = ct = X.softMax),
                !(
                  z ||
                  this.axisPointRange ||
                  (this.stacking && this.stacking.usePercentage) ||
                  E
                ) &&
                  g(this.min) &&
                  g(this.max) &&
                  (R = this.max - this.min) &&
                  (!g(at) && $ && (this.min -= R * $),
                  !g(ct) && tt && (this.max += R * tt)),
                !o(this.userMin) &&
                  o(X.floor) &&
                  (this.min = Math.max(this.min, X.floor)),
                !o(this.userMax) &&
                  o(X.ceiling) &&
                  (this.max = Math.min(this.max, X.ceiling)),
                J &&
                  g(this.dataMin) &&
                  ((nt = nt || 0),
                  !g(at) && this.min < nt && this.dataMin >= nt
                    ? (this.min = this.options.minRange
                        ? Math.min(nt, this.max - this.minRange)
                        : nt)
                    : !g(ct) &&
                      this.max > nt &&
                      this.dataMax <= nt &&
                      (this.max = this.options.minRange
                        ? Math.max(nt, this.min + this.minRange)
                        : nt)),
                o(this.min) &&
                  o(this.max) &&
                  !this.chart.polar &&
                  this.min > this.max &&
                  (g(this.options.min)
                    ? (this.max = this.min)
                    : g(this.options.max) && (this.min = this.max)),
                (this.tickInterval =
                  this.min === this.max ||
                  typeof this.min > "u" ||
                  typeof this.max > "u"
                    ? 1
                    : E &&
                      this.linkedParent &&
                      !it &&
                      _ === this.linkedParent.options.tickPixelInterval
                    ? (it = this.linkedParent.tickInterval)
                    : a(
                        it,
                        this.tickAmount
                          ? (this.max - this.min) /
                              Math.max(this.tickAmount - 1, 1)
                          : void 0,
                        z
                          ? 1
                          : ((this.max - this.min) * _) / Math.max(this.len, _)
                      )),
                Z && !x)
              ) {
                const K =
                  this.min !== (this.old && this.old.min) ||
                  this.max !== (this.old && this.old.max);
                this.series.forEach(function (st) {
                  (st.forceCrop = st.forceCropping && st.forceCropping()),
                    st.processData(K);
                }),
                  m(this, "postProcessData", { hasExtremesChanged: K });
              }
              this.setAxisTranslation(),
                m(this, "initialAxisTranslation"),
                this.pointRange &&
                  !it &&
                  (this.tickInterval = Math.max(
                    this.pointRange,
                    this.tickInterval
                  )),
                (x = a(
                  X.minTickInterval,
                  this.dateTime && !this.series.some((K) => K.noSharedTooltip)
                    ? this.closestPointRange
                    : 0
                )),
                !it && this.tickInterval < x && (this.tickInterval = x),
                this.dateTime ||
                  this.logarithmic ||
                  it ||
                  (this.tickInterval = I(this, this.tickInterval)),
                this.tickAmount || (this.tickInterval = this.unsquish()),
                this.setTickPositions();
            }
            setTickPositions() {
              var x = this.options;
              const R = x.tickPositions,
                W = x.tickPositioner;
              var X = this.getMinorTickInterval(),
                Z = this.hasVerticalPanning(),
                E = this.coll === "colorAxis";
              const _ = (E || !Z) && x.startOnTick;
              (Z = (E || !Z) && x.endOnTick), (E = []);
              let z;
              if (
                ((this.tickmarkOffset =
                  this.categories &&
                  x.tickmarkPlacement === "between" &&
                  this.tickInterval === 1
                    ? 0.5
                    : 0),
                (this.minorTickInterval =
                  X === "auto" && this.tickInterval
                    ? this.tickInterval / x.minorTicksPerMajor
                    : X),
                (this.single =
                  this.min === this.max &&
                  g(this.min) &&
                  !this.tickAmount &&
                  (parseInt(this.min, 10) === this.min ||
                    x.allowDecimals !== !1)),
                R)
              )
                E = R.slice();
              else if (o(this.min) && o(this.max)) {
                if (
                  (this.ordinal && this.ordinal.positions) ||
                  !(
                    (this.max - this.min) / this.tickInterval >
                    Math.max(2 * this.len, 200)
                  )
                )
                  if (this.dateTime)
                    E = this.getTimeTicks(
                      this.dateTime.normalizeTimeTickInterval(
                        this.tickInterval,
                        x.units
                      ),
                      this.min,
                      this.max,
                      x.startOfWeek,
                      this.ordinal && this.ordinal.positions,
                      this.closestPointRange,
                      !0
                    );
                  else if (this.logarithmic)
                    E = this.logarithmic.getLogTickPositions(
                      this.tickInterval,
                      this.min,
                      this.max
                    );
                  else
                    for (
                      X = x = this.tickInterval;
                      X <= 2 * x &&
                      ((E = this.getLinearTickPositions(
                        this.tickInterval,
                        this.min,
                        this.max
                      )),
                      this.tickAmount && E.length > this.tickAmount);

                    )
                      this.tickInterval = I(this, (X *= 1.1));
                else (E = [this.min, this.max]), P(19, !1, this.chart);
                E.length > this.len &&
                  ((E = [E[0], E[E.length - 1]]),
                  E[0] === E[1] && (E.length = 1)),
                  W &&
                    ((this.tickPositions = E),
                    (z = W.apply(this, [this.min, this.max])) && (E = z));
              }
              (this.tickPositions = E),
                (this.paddedTicks = E.slice(0)),
                this.trimTicks(E, _, Z),
                !this.isLinked &&
                  o(this.min) &&
                  o(this.max) &&
                  (this.single &&
                    2 > E.length &&
                    !this.categories &&
                    !this.series.some(
                      (J) =>
                        J.is("heatmap") &&
                        J.options.pointPlacement === "between"
                    ) &&
                    ((this.min -= 0.5), (this.max += 0.5)),
                  R || z || this.adjustTickAmount()),
                m(this, "afterSetTickPositions");
            }
            trimTicks(x, R, W) {
              const X = x[0],
                Z = x[x.length - 1],
                E = (!this.isOrdinal && this.minPointOffset) || 0;
              if ((m(this, "trimTicks"), !this.isLinked)) {
                if (R && X !== -1 / 0) this.min = X;
                else for (; this.min - E > x[0]; ) x.shift();
                if (W) this.max = Z;
                else for (; this.max + E < x[x.length - 1]; ) x.pop();
                x.length === 0 &&
                  g(X) &&
                  !this.options.tickPositions &&
                  x.push((Z + X) / 2);
              }
            }
            alignToOthers() {
              const x = this,
                R = [this],
                W = x.options,
                X =
                  this.coll === "yAxis" &&
                  this.chart.options.chart.alignThresholds,
                Z = [];
              let E;
              if (
                ((x.thresholdAlignment = void 0),
                ((this.chart.options.chart.alignTicks !== !1 && W.alignTicks) ||
                  X) &&
                  W.startOnTick !== !1 &&
                  W.endOnTick !== !1 &&
                  !x.logarithmic)
              ) {
                const _ = (J) => {
                    const { horiz: tt, options: $ } = J;
                    return [
                      tt ? $.left : $.top,
                      $.width,
                      $.height,
                      $.pane,
                    ].join();
                  },
                  z = _(this);
                this.chart[this.coll].forEach(function (J) {
                  const { series: tt } = J;
                  tt.length &&
                    tt.some(($) => $.visible) &&
                    J !== x &&
                    _(J) === z &&
                    ((E = !0), R.push(J));
                });
              }
              if (E && X) {
                R.forEach((z) => {
                  (z = z.getThresholdAlignment(x)), o(z) && Z.push(z);
                });
                const _ =
                  1 < Z.length
                    ? Z.reduce((z, J) => z + J, 0) / Z.length
                    : void 0;
                R.forEach((z) => {
                  z.thresholdAlignment = _;
                });
              }
              return E;
            }
            getThresholdAlignment(x) {
              if (
                ((!o(this.dataMin) ||
                  (this !== x &&
                    this.series.some((R) => R.isDirty || R.isDirtyData))) &&
                  this.getSeriesExtremes(),
                o(this.threshold))
              )
                return (
                  (x = n(
                    (this.threshold - (this.dataMin || 0)) /
                      ((this.dataMax || 0) - (this.dataMin || 0)),
                    0,
                    1
                  )),
                  this.options.reversed && (x = 1 - x),
                  x
                );
            }
            getTickAmount() {
              const x = this.options,
                R = x.tickPixelInterval;
              let W = x.tickAmount;
              !g(x.tickInterval) &&
                !W &&
                this.len < R &&
                !this.isRadial &&
                !this.logarithmic &&
                x.startOnTick &&
                x.endOnTick &&
                (W = 2),
                !W && this.alignToOthers() && (W = Math.ceil(this.len / R) + 1),
                4 > W && ((this.finalTickAmt = W), (W = 5)),
                (this.tickAmount = W);
            }
            adjustTickAmount() {
              const x = this,
                {
                  finalTickAmt: R,
                  max: W,
                  min: X,
                  options: Z,
                  tickPositions: E,
                  tickAmount: _,
                  thresholdAlignment: z,
                } = x,
                J = E && E.length;
              var tt = a(x.threshold, x.softThreshold ? 0 : null),
                $ = x.tickInterval;
              let it;
              if (
                (o(z) &&
                  ((it =
                    0.5 > z ? Math.ceil(z * (_ - 1)) : Math.floor(z * (_ - 1))),
                  Z.reversed && (it = _ - 1 - it)),
                x.hasData() && o(X) && o(W))
              ) {
                const nt = () => {
                  (x.transA *= (J - 1) / (_ - 1)),
                    (x.min = Z.startOnTick ? E[0] : Math.min(X, E[0])),
                    (x.max = Z.endOnTick
                      ? E[E.length - 1]
                      : Math.max(W, E[E.length - 1]));
                };
                if (o(it) && o(x.threshold)) {
                  for (
                    ;
                    E[it] !== tt ||
                    E.length !== _ ||
                    E[0] > X ||
                    E[E.length - 1] < W;

                  ) {
                    for (E.length = 0, E.push(x.threshold); E.length < _; )
                      E[it] === void 0 || E[it] > x.threshold
                        ? E.unshift(d(E[0] - $))
                        : E.push(d(E[E.length - 1] + $));
                    if ($ > 8 * x.tickInterval) break;
                    $ *= 2;
                  }
                  nt();
                } else if (J < _) {
                  for (; E.length < _; )
                    E.length % 2 || X === tt
                      ? E.push(d(E[E.length - 1] + $))
                      : E.unshift(d(E[0] - $));
                  nt();
                }
                if (g(R)) {
                  for ($ = tt = E.length; $--; )
                    ((R === 3 && $ % 2 === 1) ||
                      (2 >= R && 0 < $ && $ < tt - 1)) &&
                      E.splice($, 1);
                  x.finalTickAmt = void 0;
                }
              }
            }
            setScale() {
              let x = !1,
                R = !1;
              this.series.forEach(function (X) {
                (x = x || X.isDirtyData || X.isDirty),
                  (R = R || (X.xAxis && X.xAxis.isDirty) || !1);
              }),
                this.setAxisSize();
              const W = this.len !== (this.old && this.old.len);
              W ||
              x ||
              R ||
              this.isLinked ||
              this.forceRedraw ||
              this.userMin !== (this.old && this.old.userMin) ||
              this.userMax !== (this.old && this.old.userMax) ||
              this.alignToOthers()
                ? (this.stacking &&
                    (this.stacking.resetStacks(), this.stacking.buildStacks()),
                  (this.forceRedraw = !1),
                  this.userMinRange || (this.minRange = void 0),
                  this.getSeriesExtremes(),
                  this.setTickInterval(),
                  this.isDirty ||
                    (this.isDirty =
                      W ||
                      this.min !== (this.old && this.old.min) ||
                      this.max !== (this.old && this.old.max)))
                : this.stacking && this.stacking.cleanStacks(),
                x && this.panningState && (this.panningState.isDirty = !0),
                m(this, "afterSetScale");
            }
            setExtremes(x, R, W, X, Z) {
              const E = this,
                _ = E.chart;
              (W = a(W, !0)),
                E.series.forEach(function (z) {
                  delete z.kdTree;
                }),
                (Z = j(Z, { min: x, max: R })),
                m(E, "setExtremes", Z, function () {
                  (E.userMin = x),
                    (E.userMax = R),
                    (E.eventArgs = Z),
                    W && _.redraw(X);
                });
            }
            zoom(x, R) {
              const W = this,
                X = this.dataMin,
                Z = this.dataMax,
                E = this.options,
                _ = Math.min(X, a(E.min, X)),
                z = Math.max(Z, a(E.max, Z));
              return (
                (x = { newMin: x, newMax: R }),
                m(this, "zoom", x, function (J) {
                  let tt = J.newMin,
                    $ = J.newMax;
                  (tt !== W.min || $ !== W.max) &&
                    (W.allowZoomOutside ||
                      (g(X) && (tt < _ && (tt = _), tt > z && (tt = z)),
                      g(Z) && ($ < _ && ($ = _), $ > z && ($ = z))),
                    (W.displayBtn = typeof tt < "u" || typeof $ < "u"),
                    W.setExtremes(tt, $, !1, void 0, { trigger: "zoom" })),
                    (J.zoomed = !0);
                }),
                x.zoomed
              );
            }
            setAxisSize() {
              const x = this.chart;
              var R = this.options;
              const W = R.offsets || [0, 0, 0, 0],
                X = this.horiz,
                Z = (this.width = Math.round(
                  b(a(R.width, x.plotWidth - W[3] + W[1]), x.plotWidth)
                )),
                E = (this.height = Math.round(
                  b(a(R.height, x.plotHeight - W[0] + W[2]), x.plotHeight)
                )),
                _ = (this.top = Math.round(
                  b(a(R.top, x.plotTop + W[0]), x.plotHeight, x.plotTop)
                ));
              (R = this.left =
                Math.round(
                  b(a(R.left, x.plotLeft + W[3]), x.plotWidth, x.plotLeft)
                )),
                (this.bottom = x.chartHeight - E - _),
                (this.right = x.chartWidth - Z - R),
                (this.len = Math.max(X ? Z : E, 0)),
                (this.pos = X ? R : _);
            }
            getExtremes() {
              const x = this.logarithmic;
              return {
                min: x ? d(x.lin2log(this.min)) : this.min,
                max: x ? d(x.lin2log(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax,
              };
            }
            getThreshold(x) {
              var R = this.logarithmic;
              const W = R ? R.lin2log(this.min) : this.min;
              return (
                (R = R ? R.lin2log(this.max) : this.max),
                x === null || x === -1 / 0
                  ? (x = W)
                  : x === 1 / 0
                  ? (x = R)
                  : W > x
                  ? (x = W)
                  : R < x && (x = R),
                this.translate(x, 0, 1, 0, 1)
              );
            }
            autoLabelAlign(x) {
              const R = (a(x, 0) - 90 * this.side + 720) % 360;
              return (
                (x = { align: "center" }),
                m(this, "autoLabelAlign", x, function (W) {
                  15 < R && 165 > R
                    ? (W.align = "right")
                    : 195 < R && 345 > R && (W.align = "left");
                }),
                x.align
              );
            }
            tickSize(x) {
              const R = this.options,
                W = a(
                  R[x === "tick" ? "tickWidth" : "minorTickWidth"],
                  x === "tick" && this.isXAxis && !this.categories ? 1 : 0
                );
              let X = R[x === "tick" ? "tickLength" : "minorTickLength"],
                Z;
              return (
                W &&
                  X &&
                  (R[x + "Position"] === "inside" && (X = -X), (Z = [X, W])),
                (x = { tickSize: Z }),
                m(this, "afterTickSize", x),
                x.tickSize
              );
            }
            labelMetrics() {
              const x = this.chart.renderer;
              var R = this.ticks;
              return (
                (R = R[Object.keys(R)[0]] || {}),
                this.chart.renderer.fontMetrics(
                  R.label || R.movedLabel || x.box
                )
              );
            }
            unsquish() {
              const x = this.options.labels;
              var R = this.horiz;
              const W = this.tickInterval,
                X =
                  this.len /
                  (((this.categories ? 1 : 0) + this.max - this.min) / W),
                Z = x.rotation,
                E = 0.75 * this.labelMetrics().h,
                _ = Math.max(this.max - this.min, 0),
                z = function (nt) {
                  let rt = nt / (X || 1);
                  return (
                    (rt = 1 < rt ? Math.ceil(rt) : 1),
                    rt * W > _ &&
                      nt !== 1 / 0 &&
                      X !== 1 / 0 &&
                      _ &&
                      (rt = Math.ceil(_ / W)),
                    d(rt * W)
                  );
                };
              let J = W,
                tt,
                $ = Number.MAX_VALUE,
                it;
              if (R) {
                if (
                  (x.staggerLines ||
                    (o(Z)
                      ? (it = [Z])
                      : X < x.autoRotationLimit && (it = x.autoRotation)),
                  it)
                ) {
                  let nt;
                  for (const rt of it)
                    (rt === Z || (rt && -90 <= rt && 90 >= rt)) &&
                      ((R = z(Math.abs(E / Math.sin(p * rt)))),
                      (nt = R + Math.abs(rt / 360)),
                      nt < $ && (($ = nt), (tt = rt), (J = R)));
                }
              } else J = z(E);
              return (
                (this.autoRotation = it),
                (this.labelRotation = a(tt, o(Z) ? Z : 0)),
                x.step ? W : J
              );
            }
            getSlotWidth(x) {
              const R = this.chart,
                W = this.horiz,
                X = this.options.labels,
                Z = Math.max(
                  this.tickPositions.length - (this.categories ? 0 : 1),
                  1
                ),
                E = R.margin[3];
              if (x && o(x.slotWidth)) return x.slotWidth;
              if (W && 2 > X.step)
                return X.rotation
                  ? 0
                  : ((this.staggerLines || 1) * this.len) / Z;
              if (!W) {
                if (((x = X.style.width), x !== void 0))
                  return parseInt(String(x), 10);
                if (E) return E - R.spacing[3];
              }
              return 0.33 * R.chartWidth;
            }
            renderUnsquish() {
              const x = this.chart,
                R = x.renderer,
                W = this.tickPositions,
                X = this.ticks,
                Z = this.options.labels,
                E = Z.style,
                _ = this.horiz,
                z = this.getSlotWidth();
              var J = Math.max(1, Math.round(z - 2 * Z.padding));
              const tt = {},
                $ = this.labelMetrics(),
                it = E.textOverflow;
              let nt,
                rt,
                at = 0;
              if (
                (i(Z.rotation) || (tt.rotation = Z.rotation || 0),
                W.forEach(function (Q) {
                  (Q = X[Q]),
                    Q.movedLabel && Q.replaceMovedLabel(),
                    Q &&
                      Q.label &&
                      Q.label.textPxLength > at &&
                      (at = Q.label.textPxLength);
                }),
                (this.maxLabelLength = at),
                this.autoRotation)
              )
                at > J && at > $.h
                  ? (tt.rotation = this.labelRotation)
                  : (this.labelRotation = 0);
              else if (z && ((nt = J), !it))
                for (rt = "clip", J = W.length; !_ && J--; ) {
                  var ct = W[J];
                  (ct = X[ct].label) &&
                    (ct.styles && ct.styles.textOverflow === "ellipsis"
                      ? ct.css({ textOverflow: "clip" })
                      : ct.textPxLength > z && ct.css({ width: z + "px" }),
                    ct.getBBox().height > this.len / W.length - ($.h - $.f) &&
                      (ct.specificTextOverflow = "ellipsis"));
                }
              tt.rotation &&
                ((nt = at > 0.5 * x.chartHeight ? 0.33 * x.chartHeight : at),
                it || (rt = "ellipsis")),
                (this.labelAlign =
                  Z.align || this.autoLabelAlign(this.labelRotation)) &&
                  (tt.align = this.labelAlign),
                W.forEach(function (Q) {
                  const K = (Q = X[Q]) && Q.label,
                    st = E.width,
                    et = {};
                  K &&
                    (K.attr(tt),
                    Q.shortenLabel
                      ? Q.shortenLabel()
                      : nt &&
                        !st &&
                        E.whiteSpace !== "nowrap" &&
                        (nt < K.textPxLength || K.element.tagName === "SPAN")
                      ? ((et.width = nt + "px"),
                        it || (et.textOverflow = K.specificTextOverflow || rt),
                        K.css(et))
                      : K.styles &&
                        K.styles.width &&
                        !et.width &&
                        !st &&
                        K.css({ width: null }),
                    delete K.specificTextOverflow,
                    (Q.rotation = tt.rotation));
                }, this),
                (this.tickRotCorr = R.rotCorr(
                  $.b,
                  this.labelRotation || 0,
                  this.side !== 0
                ));
            }
            hasData() {
              return (
                this.series.some(function (x) {
                  return x.hasData();
                }) ||
                (this.options.showEmpty && g(this.min) && g(this.max))
              );
            }
            addTitle(x) {
              const R = this.chart.renderer,
                W = this.horiz,
                X = this.opposite,
                Z = this.options.title,
                E = this.chart.styledMode;
              let _;
              this.axisTitle ||
                ((_ = Z.textAlign) ||
                  (_ = (
                    W
                      ? { low: "left", middle: "center", high: "right" }
                      : {
                          low: X ? "right" : "left",
                          middle: "center",
                          high: X ? "left" : "right",
                        }
                  )[Z.align]),
                (this.axisTitle = R.text(Z.text || "", 0, 0, Z.useHTML)
                  .attr({ zIndex: 7, rotation: Z.rotation, align: _ })
                  .addClass("highcharts-axis-title")),
                E || this.axisTitle.css(t(Z.style)),
                this.axisTitle.add(this.axisGroup),
                (this.axisTitle.isNew = !0)),
                E ||
                  Z.style.width ||
                  this.isRadial ||
                  this.axisTitle.css({ width: this.len + "px" }),
                this.axisTitle[x ? "show" : "hide"](x);
            }
            generateTick(x) {
              const R = this.ticks;
              R[x] ? R[x].addLabel() : (R[x] = new Y(this, x));
            }
            getOffset() {
              const x = this,
                {
                  chart: R,
                  horiz: W,
                  options: X,
                  side: Z,
                  ticks: E,
                  tickPositions: _,
                  coll: z,
                  axisParent: J,
                } = x,
                tt = R.renderer,
                $ = R.inverted && !x.isZAxis ? [1, 0, 3, 2][Z] : Z;
              var it = x.hasData();
              const nt = X.title;
              var rt = X.labels;
              const at = o(X.crossing);
              var ct = R.axisOffset;
              const Q = R.clipOffset,
                K = [-1, 1, 1, -1][Z],
                st = X.className;
              let et,
                ot = 0,
                lt;
              var ht = 0;
              let mt = 0;
              if (
                ((x.showAxis = et = it || X.showEmpty),
                (x.staggerLines = (x.horiz && rt.staggerLines) || void 0),
                !x.axisGroup)
              ) {
                const yt = (gt, ft, St) =>
                  tt
                    .g(gt)
                    .attr({ zIndex: St })
                    .addClass(
                      `highcharts-${z.toLowerCase()}${ft} ` +
                        (this.isRadial ? `highcharts-radial-axis${ft} ` : "") +
                        (st || "")
                    )
                    .add(J);
                (x.gridGroup = yt("grid", "-grid", X.gridZIndex)),
                  (x.axisGroup = yt("axis", "", X.zIndex)),
                  (x.labelGroup = yt("axis-labels", "-labels", rt.zIndex));
              }
              it || x.isLinked
                ? (_.forEach(function (yt) {
                    x.generateTick(yt);
                  }),
                  x.renderUnsquish(),
                  (x.reserveSpaceDefault =
                    Z === 0 ||
                    Z === 2 ||
                    { 1: "left", 3: "right" }[Z] === x.labelAlign),
                  a(
                    rt.reserveSpace,
                    at ? !1 : null,
                    x.labelAlign === "center" ? !0 : null,
                    x.reserveSpaceDefault
                  ) &&
                    _.forEach(function (yt) {
                      mt = Math.max(E[yt].getLabelSize(), mt);
                    }),
                  x.staggerLines && (mt *= x.staggerLines),
                  (x.labelOffset = mt * (x.opposite ? -1 : 1)))
                : s(E, function (yt, gt) {
                    yt.destroy(), delete E[gt];
                  }),
                nt &&
                  nt.text &&
                  nt.enabled !== !1 &&
                  (x.addTitle(et),
                  et &&
                    !at &&
                    nt.reserveSpace !== !1 &&
                    ((x.titleOffset = ot =
                      x.axisTitle.getBBox()[W ? "height" : "width"]),
                    (lt = nt.offset),
                    (ht = g(lt) ? 0 : a(nt.margin, W ? 5 : 10)))),
                x.renderLine(),
                (x.offset =
                  K * a(X.offset, ct[Z] ? ct[Z] + (X.margin || 0) : 0)),
                (x.tickRotCorr = x.tickRotCorr || { x: 0, y: 0 }),
                (it =
                  Z === 0
                    ? -x.labelMetrics().h
                    : Z === 2
                    ? x.tickRotCorr.y
                    : 0),
                (ht = Math.abs(mt) + ht),
                mt &&
                  (ht =
                    ht -
                    it +
                    K *
                      (W
                        ? a(rt.y, x.tickRotCorr.y + K * rt.distance)
                        : a(rt.x, K * rt.distance))),
                (x.axisTitleMargin = a(lt, ht)),
                x.getMaxLabelDimensions &&
                  (x.maxLabelDimensions = x.getMaxLabelDimensions(E, _)),
                z !== "colorAxis" &&
                  ((rt = this.tickSize("tick")),
                  (ct[Z] = Math.max(
                    ct[Z],
                    (x.axisTitleMargin || 0) + ot + K * x.offset,
                    ht,
                    _ && _.length && rt ? rt[0] + K * x.offset : 0
                  )),
                  (ct =
                    !x.axisLine || X.offset
                      ? 0
                      : 2 * Math.floor(x.axisLine.strokeWidth() / 2)),
                  (Q[$] = Math.max(Q[$], ct))),
                m(this, "afterGetOffset");
            }
            getLinePath(x) {
              const R = this.chart,
                W = this.opposite;
              var X = this.offset;
              const Z = this.horiz,
                E = this.left + (W ? this.width : 0) + X;
              return (
                (X = R.chartHeight - this.bottom - (W ? this.height : 0) + X),
                W && (x *= -1),
                R.renderer.crispLine(
                  [
                    ["M", Z ? this.left : E, Z ? X : this.top],
                    [
                      "L",
                      Z ? R.chartWidth - this.right : E,
                      Z ? X : R.chartHeight - this.bottom,
                    ],
                  ],
                  x
                )
              );
            }
            renderLine() {
              this.axisLine ||
                ((this.axisLine = this.chart.renderer
                  .path()
                  .addClass("highcharts-axis-line")
                  .add(this.axisGroup)),
                this.chart.styledMode ||
                  this.axisLine.attr({
                    stroke: this.options.lineColor,
                    "stroke-width": this.options.lineWidth,
                    zIndex: 7,
                  }));
            }
            getTitlePosition(x) {
              var R = this.horiz,
                W = this.left;
              const X = this.top;
              var Z = this.len;
              const E = this.options.title,
                _ = R ? W : X,
                z = this.opposite,
                J = this.offset,
                tt = E.x,
                $ = E.y,
                it = this.chart.renderer.fontMetrics(x);
              return (
                (x = x ? Math.max(x.getBBox(!1, 0).height - it.h - 1, 0) : 0),
                (Z = {
                  low: _ + (R ? 0 : Z),
                  middle: _ + Z / 2,
                  high: _ + (R ? Z : 0),
                }[E.align]),
                (W =
                  (R ? X + this.height : W) +
                  (R ? 1 : -1) * (z ? -1 : 1) * (this.axisTitleMargin || 0) +
                  [-x, x, it.f, -x][this.side]),
                (R = {
                  x: R ? Z + tt : W + (z ? this.width : 0) + J + tt,
                  y: R ? W + $ - (z ? this.height : 0) + J : Z + $,
                }),
                m(this, "afterGetTitlePosition", { titlePosition: R }),
                R
              );
            }
            renderMinorTick(x, R) {
              const W = this.minorTicks;
              W[x] || (W[x] = new Y(this, x, "minor")),
                R && W[x].isNew && W[x].render(null, !0),
                W[x].render(null, !1, 1);
            }
            renderTick(x, R, W) {
              const X = this.ticks;
              (!this.isLinked ||
                (x >= this.min && x <= this.max) ||
                (this.grid && this.grid.isColumn)) &&
                (X[x] || (X[x] = new Y(this, x)),
                W && X[x].isNew && X[x].render(R, !0, -1),
                X[x].render(R));
            }
            render() {
              const x = this,
                R = x.chart,
                W = x.logarithmic,
                X = x.options,
                Z = x.isLinked,
                E = x.tickPositions,
                _ = x.axisTitle,
                z = x.ticks,
                J = x.minorTicks,
                tt = x.alternateBands,
                $ = X.stackLabels,
                it = X.alternateGridColor;
              var nt = X.crossing;
              const rt = x.tickmarkOffset,
                at = x.axisLine,
                ct = x.showAxis,
                Q = N(R.renderer.globalAnimation);
              let K, st;
              if (
                ((x.labelEdge.length = 0),
                (x.overlap = !1),
                [z, J, tt].forEach(function (et) {
                  s(et, function (ot) {
                    ot.isActive = !1;
                  });
                }),
                o(nt))
              ) {
                const et = this.isXAxis ? R.yAxis[0] : R.xAxis[0],
                  ot = [1, -1, -1, 1][this.side];
                et &&
                  ((nt = et.toPixels(nt, !0)),
                  x.horiz && (nt = et.len - nt),
                  (x.offset = ot * nt));
              }
              if (x.hasData() || Z) {
                const et = x.chart.hasRendered && x.old && o(x.old.min);
                x.minorTickInterval &&
                  !x.categories &&
                  x.getMinorTickPositions().forEach(function (ot) {
                    x.renderMinorTick(ot, et);
                  }),
                  E.length &&
                    (E.forEach(function (ot, lt) {
                      x.renderTick(ot, lt, et);
                    }),
                    rt &&
                      (x.min === 0 || x.single) &&
                      (z[-1] || (z[-1] = new Y(x, -1, null, !0)),
                      z[-1].render(-1))),
                  it &&
                    E.forEach(function (ot, lt) {
                      (st =
                        typeof E[lt + 1] < "u" ? E[lt + 1] + rt : x.max - rt),
                        lt % 2 === 0 &&
                          ot < x.max &&
                          st <= x.max + (R.polar ? -rt : rt) &&
                          (tt[ot] || (tt[ot] = new H.PlotLineOrBand(x)),
                          (K = ot + rt),
                          (tt[ot].options = {
                            from: W ? W.lin2log(K) : K,
                            to: W ? W.lin2log(st) : st,
                            color: it,
                            className: "highcharts-alternate-grid",
                          }),
                          tt[ot].render(),
                          (tt[ot].isActive = !0));
                    }),
                  x._addedPlotLB ||
                    ((x._addedPlotLB = !0),
                    (X.plotLines || [])
                      .concat(X.plotBands || [])
                      .forEach(function (ot) {
                        x.addPlotBandOrLine(ot);
                      }));
              }
              [z, J, tt].forEach(function (et) {
                const ot = [],
                  lt = Q.duration;
                s(et, function (ht, mt) {
                  ht.isActive ||
                    (ht.render(mt, !1, 0), (ht.isActive = !1), ot.push(mt));
                }),
                  L(
                    function () {
                      let ht = ot.length;
                      for (; ht--; )
                        et[ot[ht]] &&
                          !et[ot[ht]].isActive &&
                          (et[ot[ht]].destroy(), delete et[ot[ht]]);
                    },
                    et !== tt && R.hasRendered && lt ? lt : 0
                  );
              }),
                at &&
                  (at[at.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(at.strokeWidth()),
                  }),
                  (at.isPlaced = !0),
                  at[ct ? "show" : "hide"](ct)),
                _ &&
                  ct &&
                  (_[_.isNew ? "attr" : "animate"](x.getTitlePosition(_)),
                  (_.isNew = !1)),
                $ && $.enabled && x.stacking && x.stacking.renderStackTotals(),
                (x.old = {
                  len: x.len,
                  max: x.max,
                  min: x.min,
                  transA: x.transA,
                  userMax: x.userMax,
                  userMin: x.userMin,
                }),
                (x.isDirty = !1),
                m(this, "afterRender");
            }
            redraw() {
              this.visible &&
                (this.render(),
                this.plotLinesAndBands.forEach(function (x) {
                  x.render();
                })),
                this.series.forEach(function (x) {
                  x.isDirty = !0;
                });
            }
            getKeepProps() {
              return this.keepProps || V.keepProps;
            }
            destroy(x) {
              const R = this,
                W = R.plotLinesAndBands,
                X = this.eventOptions;
              if (
                (m(this, "destroy", { keepEvents: x }),
                x || r(R),
                [R.ticks, R.minorTicks, R.alternateBands].forEach(function (Z) {
                  M(Z);
                }),
                W)
              )
                for (x = W.length; x--; ) W[x].destroy();
              "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar"
                .split(" ")
                .forEach(function (Z) {
                  R[Z] && (R[Z] = R[Z].destroy());
                });
              for (const Z in R.plotLinesAndBandsGroups)
                R.plotLinesAndBandsGroups[Z] =
                  R.plotLinesAndBandsGroups[Z].destroy();
              s(R, function (Z, E) {
                R.getKeepProps().indexOf(E) === -1 && delete R[E];
              }),
                (this.eventOptions = X);
            }
            drawCrosshair(x, R) {
              const W = this.crosshair;
              var X = a(W && W.snap, !0);
              const Z = this.chart;
              let E,
                _ = this.cross;
              if (
                (m(this, "drawCrosshair", { e: x, point: R }),
                x || (x = this.cross && this.cross.e),
                W && (g(R) || !X) !== !1)
              ) {
                if (
                  (X
                    ? g(R) &&
                      (E = a(
                        this.coll !== "colorAxis" ? R.crosshairPos : null,
                        this.isXAxis ? R.plotX : this.len - R.plotY
                      ))
                    : (E =
                        x &&
                        (this.horiz
                          ? x.chartX - this.pos
                          : this.len - x.chartY + this.pos)),
                  g(E))
                ) {
                  var z = {
                    value: R && (this.isXAxis ? R.x : a(R.stackY, R.y)),
                    translatedValue: E,
                  };
                  Z.polar &&
                    j(z, {
                      isCrosshair: !0,
                      chartX: x && x.chartX,
                      chartY: x && x.chartY,
                      point: R,
                    }),
                    (z = this.getPlotLinePath(z) || null);
                }
                if (!g(z)) {
                  this.hideCrosshair();
                  return;
                }
                (X = this.categories && !this.isRadial),
                  _ ||
                    ((this.cross = _ =
                      Z.renderer
                        .path()
                        .addClass(
                          "highcharts-crosshair highcharts-crosshair-" +
                            (X ? "category " : "thin ") +
                            (W.className || "")
                        )
                        .attr({ zIndex: a(W.zIndex, 2) })
                        .add()),
                    Z.styledMode ||
                      (_.attr({
                        stroke:
                          W.color ||
                          (X
                            ? F.parse("#ccd3ff").setOpacity(0.25).get()
                            : "#cccccc"),
                        "stroke-width": a(W.width, 1),
                      }).css({ "pointer-events": "none" }),
                      W.dashStyle && _.attr({ dashstyle: W.dashStyle }))),
                  _.show().attr({ d: z }),
                  X && !W.width && _.attr({ "stroke-width": this.transA }),
                  (this.cross.e = x);
              } else this.hideCrosshair();
              m(this, "afterDrawCrosshair", { e: x, point: R });
            }
            hideCrosshair() {
              this.cross && this.cross.hide(), m(this, "afterHideCrosshair");
            }
            hasVerticalPanning() {
              const x = this.chart.options.chart.panning;
              return !!(x && x.enabled && /y/.test(x.type));
            }
            update(x, R) {
              const W = this.chart;
              (x = t(this.userOptions, x)),
                this.destroy(!0),
                this.init(W, x),
                (W.isDirtyBox = !0),
                a(R, !0) && W.redraw();
            }
            remove(x) {
              const R = this.chart,
                W = this.coll,
                X = this.series;
              let Z = X.length;
              for (; Z--; ) X[Z] && X[Z].remove(!1);
              C(R.axes, this),
                C(R[W] || [], this),
                R.orderItems(W),
                this.destroy(),
                (R.isDirtyBox = !0),
                a(x, !0) && R.redraw();
            }
            setTitle(x, R) {
              this.update({ title: x }, R);
            }
            setCategories(x, R) {
              this.update({ categories: x }, R);
            }
          }
          return (
            (V.defaultOptions = O.defaultXAxisOptions),
            (V.keepProps =
              "coll extKey hcEvents names series userMax userMin".split(" ")),
            V
          );
        }
      ),
      T(y, "Core/Axis/DateTimeAxis.js", [y["Core/Utilities.js"]], function (A) {
        const {
          addEvent: O,
          getMagnitude: F,
          normalizeTickInterval: G,
          timeUnits: U,
        } = A;
        var H;
        return (
          (function (Y) {
            function S() {
              return this.chart.time.getTimeTicks.apply(
                this.chart.time,
                arguments
              );
            }
            function N(p) {
              p.userOptions.type !== "datetime"
                ? (this.dateTime = void 0)
                : this.dateTime || (this.dateTime = new c(this));
            }
            const D = [];
            Y.compose = function (p) {
              return (
                A.pushUnique(D, p) &&
                  (p.keepProps.push("dateTime"),
                  (p.prototype.getTimeTicks = S),
                  O(p, "init", N)),
                p
              );
            };
            class c {
              constructor(f) {
                this.axis = f;
              }
              normalizeTimeTickInterval(f, u) {
                const n = u || [
                  ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
                  ["second", [1, 2, 5, 10, 15, 30]],
                  ["minute", [1, 2, 5, 10, 15, 30]],
                  ["hour", [1, 2, 3, 4, 6, 8, 12]],
                  ["day", [1, 2]],
                  ["week", [1, 2]],
                  ["month", [1, 2, 3, 4, 6]],
                  ["year", null],
                ];
                u = n[n.length - 1];
                let d = U[u[0]],
                  g = u[1],
                  M;
                for (
                  M = 0;
                  M < n.length &&
                  ((u = n[M]),
                  (d = U[u[0]]),
                  (g = u[1]),
                  !(
                    n[M + 1] && f <= (d * g[g.length - 1] + U[n[M + 1][0]]) / 2
                  ));
                  M++
                );
                return (
                  d === U.year && f < 5 * d && (g = [1, 2, 5]),
                  (f = G(
                    f / d,
                    g,
                    u[0] === "year" ? Math.max(F(f / d), 1) : 1
                  )),
                  { unitRange: d, count: f, unitName: u[0] }
                );
              }
              getXDateFormat(f, u) {
                const { axis: n } = this,
                  d = n.chart.time;
                return n.closestPointRange
                  ? d.getDateFormat(
                      n.closestPointRange,
                      f,
                      n.options.startOfWeek,
                      u
                    ) || d.resolveDTLFormat(u.year).main
                  : d.resolveDTLFormat(u.day).main;
              }
            }
            Y.Additions = c;
          })(H || (H = {})),
          H
        );
      }),
      T(
        y,
        "Core/Axis/LogarithmicAxis.js",
        [y["Core/Utilities.js"]],
        function (A) {
          const { addEvent: O, normalizeTickInterval: F, pick: G } = A;
          var U;
          return (
            (function (H) {
              function Y(c) {
                let p = this.logarithmic;
                c.userOptions.type !== "logarithmic"
                  ? (this.logarithmic = void 0)
                  : p || (this.logarithmic = new D(this));
              }
              function S() {
                const c = this.logarithmic;
                c &&
                  ((this.lin2val = function (p) {
                    return c.lin2log(p);
                  }),
                  (this.val2lin = function (p) {
                    return c.log2lin(p);
                  }));
              }
              const N = [];
              H.compose = function (c) {
                return (
                  A.pushUnique(N, c) &&
                    (c.keepProps.push("logarithmic"),
                    O(c, "init", Y),
                    O(c, "afterInit", S)),
                  c
                );
              };
              class D {
                constructor(p) {
                  this.axis = p;
                }
                getLogTickPositions(p, f, u, n) {
                  const d = this.axis;
                  var g = d.len,
                    M = d.options;
                  let C = [];
                  if ((n || (this.minorAutoInterval = void 0), 0.5 <= p))
                    (p = Math.round(p)),
                      (C = d.getLinearTickPositions(p, f, u));
                  else if (0.08 <= p) {
                    M = Math.floor(f);
                    let P, j, m, h, v;
                    for (
                      g =
                        0.3 < p
                          ? [1, 2, 4]
                          : 0.15 < p
                          ? [1, 2, 4, 6, 8]
                          : [1, 2, 3, 4, 5, 6, 7, 8, 9];
                      M < u + 1 && !v;
                      M++
                    )
                      for (j = g.length, P = 0; P < j && !v; P++)
                        (m = this.log2lin(this.lin2log(M) * g[P])),
                          m > f &&
                            (!n || h <= u) &&
                            typeof h < "u" &&
                            C.push(h),
                          h > u && (v = !0),
                          (h = m);
                  } else
                    (f = this.lin2log(f)),
                      (u = this.lin2log(u)),
                      (p = n ? d.getMinorTickInterval() : M.tickInterval),
                      (p = G(
                        p === "auto" ? null : p,
                        this.minorAutoInterval,
                        ((M.tickPixelInterval / (n ? 5 : 1)) * (u - f)) /
                          ((n ? g / d.tickPositions.length : g) || 1)
                      )),
                      (p = F(p)),
                      (C = d.getLinearTickPositions(p, f, u).map(this.log2lin)),
                      n || (this.minorAutoInterval = p / 5);
                  return n || (d.tickInterval = p), C;
                }
                lin2log(p) {
                  return Math.pow(10, p);
                }
                log2lin(p) {
                  return Math.log(p) / Math.LN10;
                }
              }
              H.Additions = D;
            })(U || (U = {})),
            U
          );
        }
      ),
      T(
        y,
        "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js",
        [y["Core/Utilities.js"]],
        function (A) {
          const { erase: O, extend: F, isNumber: G } = A;
          var U;
          return (
            (function (H) {
              function Y(d) {
                return this.addPlotBandOrLine(d, "plotBands");
              }
              function S(d, g) {
                const M = this.userOptions;
                let C = new n(this, d);
                if ((this.visible && (C = C.render()), C)) {
                  if (
                    (this._addedPlotLB ||
                      ((this._addedPlotLB = !0),
                      (M.plotLines || [])
                        .concat(M.plotBands || [])
                        .forEach((P) => {
                          this.addPlotBandOrLine(P);
                        })),
                    g)
                  ) {
                    const P = M[g] || [];
                    P.push(d), (M[g] = P);
                  }
                  this.plotLinesAndBands.push(C);
                }
                return C;
              }
              function N(d) {
                return this.addPlotBandOrLine(d, "plotLines");
              }
              function D(d, g, M = this.options) {
                const C = this.getPlotLinePath({
                    value: g,
                    force: !0,
                    acrossPanes: M.acrossPanes,
                  }),
                  P = [],
                  j = this.horiz;
                (g =
                  !G(this.min) ||
                  !G(this.max) ||
                  (d < this.min && g < this.min) ||
                  (d > this.max && g > this.max)),
                  (d = this.getPlotLinePath({
                    value: d,
                    force: !0,
                    acrossPanes: M.acrossPanes,
                  })),
                  (M = 1);
                let m;
                if (d && C)
                  for (
                    g && ((m = d.toString() === C.toString()), (M = 0)), g = 0;
                    g < d.length;
                    g += 2
                  ) {
                    const h = d[g],
                      v = d[g + 1],
                      l = C[g],
                      o = C[g + 1];
                    (h[0] !== "M" && h[0] !== "L") ||
                      (v[0] !== "M" && v[0] !== "L") ||
                      (l[0] !== "M" && l[0] !== "L") ||
                      (o[0] !== "M" && o[0] !== "L") ||
                      (j && l[1] === h[1]
                        ? ((l[1] += M), (o[1] += M))
                        : j || l[2] !== h[2] || ((l[2] += M), (o[2] += M)),
                      P.push(
                        ["M", h[1], h[2]],
                        ["L", v[1], v[2]],
                        ["L", o[1], o[2]],
                        ["L", l[1], l[2]],
                        ["Z"]
                      )),
                      (P.isFlat = m);
                  }
                return P;
              }
              function c(d) {
                this.removePlotBandOrLine(d);
              }
              function p(d) {
                const g = this.plotLinesAndBands,
                  M = this.options,
                  C = this.userOptions;
                if (g) {
                  let P = g.length;
                  for (; P--; ) g[P].id === d && g[P].destroy();
                  [
                    M.plotLines || [],
                    C.plotLines || [],
                    M.plotBands || [],
                    C.plotBands || [],
                  ].forEach(function (j) {
                    for (P = j.length; P--; )
                      (j[P] || {}).id === d && O(j, j[P]);
                  });
                }
              }
              function f(d) {
                this.removePlotBandOrLine(d);
              }
              const u = [];
              let n;
              H.compose = function (d, g) {
                return (
                  n || (n = d),
                  A.pushUnique(u, g) &&
                    F(g.prototype, {
                      addPlotBand: Y,
                      addPlotLine: N,
                      addPlotBandOrLine: S,
                      getPlotBandPath: D,
                      removePlotBand: c,
                      removePlotLine: f,
                      removePlotBandOrLine: p,
                    }),
                  g
                );
              };
            })(U || (U = {})),
            U
          );
        }
      ),
      T(
        y,
        "Core/Axis/PlotLineOrBand/PlotLineOrBand.js",
        [
          y["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O) {
          const {
            arrayMax: F,
            arrayMin: G,
            defined: U,
            destroyObjectProperties: H,
            erase: Y,
            fireEvent: S,
            merge: N,
            objectEach: D,
            pick: c,
          } = O;
          class p {
            static compose(u) {
              return A.compose(p, u);
            }
            constructor(u, n) {
              (this.axis = u), n && ((this.options = n), (this.id = n.id));
            }
            render() {
              S(this, "render");
              const u = this,
                n = u.axis,
                d = n.horiz;
              var g = n.logarithmic;
              const M = u.options,
                C = M.color,
                P = c(M.zIndex, 0),
                j = M.events,
                m = {},
                h = n.chart.renderer;
              let v = M.label,
                l = u.label,
                o = M.to,
                i = M.from,
                t = M.value,
                e = u.svgElem;
              var s = [];
              const a = U(i) && U(o);
              s = U(t);
              const b = !e,
                r = {
                  class:
                    "highcharts-plot-" +
                    (a ? "band " : "line ") +
                    (M.className || ""),
                };
              let w = a ? "bands" : "lines";
              if (
                (g &&
                  ((i = g.log2lin(i)), (o = g.log2lin(o)), (t = g.log2lin(t))),
                n.chart.styledMode ||
                  (s
                    ? ((r.stroke = C || "#999999"),
                      (r["stroke-width"] = c(M.width, 1)),
                      M.dashStyle && (r.dashstyle = M.dashStyle))
                    : a &&
                      ((r.fill = C || "#e6e9ff"),
                      M.borderWidth &&
                        ((r.stroke = M.borderColor),
                        (r["stroke-width"] = M.borderWidth)))),
                (m.zIndex = P),
                (w += "-" + P),
                (g = n.plotLinesAndBandsGroups[w]) ||
                  (n.plotLinesAndBandsGroups[w] = g =
                    h
                      .g("plot-" + w)
                      .attr(m)
                      .add()),
                b && (u.svgElem = e = h.path().attr(r).add(g)),
                s)
              )
                s = n.getPlotLinePath({
                  value: t,
                  lineWidth: e.strokeWidth(),
                  acrossPanes: M.acrossPanes,
                });
              else if (a) s = n.getPlotBandPath(i, o, M);
              else return;
              return (
                !u.eventsAdded &&
                  j &&
                  (D(j, function (L, I) {
                    e.on(I, function (V) {
                      j[I].apply(u, [V]);
                    });
                  }),
                  (u.eventsAdded = !0)),
                (b || !e.d) && s && s.length
                  ? e.attr({ d: s })
                  : e &&
                    (s
                      ? (e.show(), e.animate({ d: s }))
                      : e.d && (e.hide(), l && (u.label = l = l.destroy()))),
                v &&
                (U(v.text) || U(v.formatter)) &&
                s &&
                s.length &&
                0 < n.width &&
                0 < n.height &&
                !s.isFlat
                  ? ((v = N(
                      {
                        align: d && a && "center",
                        x: d ? !a && 4 : 10,
                        verticalAlign: !d && a && "middle",
                        y: d ? (a ? 16 : 10) : a ? 6 : -4,
                        rotation: d && !a && 90,
                      },
                      v
                    )),
                    this.renderLabel(v, s, a, P))
                  : l && l.hide(),
                u
              );
            }
            renderLabel(u, n, d, g) {
              const M = this.axis;
              var C = M.chart.renderer;
              let P = this.label;
              P ||
                ((this.label = P =
                  C.text(this.getLabelText(u), 0, 0, u.useHTML)
                    .attr({
                      align: u.textAlign || u.align,
                      rotation: u.rotation,
                      class:
                        "highcharts-plot-" +
                        (d ? "band" : "line") +
                        "-label " +
                        (u.className || ""),
                      zIndex: g,
                    })
                    .add()),
                M.chart.styledMode ||
                  P.css(
                    N({ fontSize: "0.8em", textOverflow: "ellipsis" }, u.style)
                  )),
                (g = n.xBounds || [n[0][1], n[1][1], d ? n[2][1] : n[0][1]]),
                (n = n.yBounds || [n[0][2], n[1][2], d ? n[2][2] : n[0][2]]),
                (d = G(g)),
                (C = G(n)),
                P.align(u, !1, {
                  x: d,
                  y: C,
                  width: F(g) - d,
                  height: F(n) - C,
                }),
                (P.alignValue && P.alignValue !== "left") ||
                  ((u = u.clip ? M.width : M.chart.chartWidth),
                  P.css({
                    width:
                      (P.rotation === 90
                        ? M.height - (P.alignAttr.y - M.top)
                        : u - (P.alignAttr.x - M.left)) + "px",
                  })),
                P.show(!0);
            }
            getLabelText(u) {
              return U(u.formatter) ? u.formatter.call(this) : u.text;
            }
            destroy() {
              Y(this.axis.plotLinesAndBands, this), delete this.axis, H(this);
            }
          }
          return p;
        }
      ),
      T(
        y,
        "Core/Tooltip.js",
        [
          y["Core/Templating.js"],
          y["Core/Globals.js"],
          y["Core/Renderer/RendererUtilities.js"],
          y["Core/Renderer/RendererRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U) {
          const { format: H } = A,
            { doc: Y, isSafari: S } = O,
            { distribute: N } = F,
            {
              addEvent: D,
              clamp: c,
              css: p,
              discardElement: f,
              extend: u,
              fireEvent: n,
              isArray: d,
              isNumber: g,
              isString: M,
              merge: C,
              pick: P,
              splat: j,
              syncTimeout: m,
            } = U;
          class h {
            constructor(l, o) {
              (this.allowShared = !0),
                (this.container = void 0),
                (this.crosshairs = []),
                (this.distance = 0),
                (this.isHidden = !0),
                (this.isSticky = !1),
                (this.now = {}),
                (this.options = {}),
                (this.outside = !1),
                (this.chart = l),
                this.init(l, o);
            }
            bodyFormatter(l) {
              return l.map(function (o) {
                const i = o.series.tooltipOptions;
                return (
                  i[(o.point.formatPrefix || "point") + "Formatter"] ||
                  o.point.tooltipFormatter
                ).call(
                  o.point,
                  i[(o.point.formatPrefix || "point") + "Format"] || ""
                );
              });
            }
            cleanSplit(l) {
              this.chart.series.forEach(function (o) {
                const i = o && o.tt;
                i &&
                  (!i.isActive || l ? (o.tt = i.destroy()) : (i.isActive = !1));
              });
            }
            defaultFormatter(l) {
              const o = this.points || j(this);
              let i;
              return (
                (i = [l.tooltipFooterHeaderFormatter(o[0])]),
                (i = i.concat(l.bodyFormatter(o))),
                i.push(l.tooltipFooterHeaderFormatter(o[0], !0)),
                i
              );
            }
            destroy() {
              this.label && (this.label = this.label.destroy()),
                this.split &&
                  (this.cleanSplit(!0),
                  this.tt && (this.tt = this.tt.destroy())),
                this.renderer &&
                  ((this.renderer = this.renderer.destroy()),
                  f(this.container)),
                U.clearTimeout(this.hideTimer),
                U.clearTimeout(this.tooltipTimeout);
            }
            getAnchor(l, o) {
              var i = this.chart;
              const t = i.pointer,
                e = i.inverted,
                s = i.plotTop;
              if (
                ((i = i.plotLeft),
                (l = j(l)),
                l[0].series &&
                  l[0].series.yAxis &&
                  !l[0].series.yAxis.options.reversedStacks &&
                  (l = l.slice().reverse()),
                this.followPointer && o)
              )
                typeof o.chartX > "u" && (o = t.normalize(o)),
                  (l = [o.chartX - i, o.chartY - s]);
              else if (l[0].tooltipPos) l = l[0].tooltipPos;
              else {
                let a = 0,
                  b = 0;
                l.forEach(function (r) {
                  (r = r.pos(!0)) && ((a += r[0]), (b += r[1]));
                }),
                  (a /= l.length),
                  (b /= l.length),
                  this.shared &&
                    1 < l.length &&
                    o &&
                    (e ? (a = o.chartX) : (b = o.chartY)),
                  (l = [a - i, b - s]);
              }
              return l.map(Math.round);
            }
            getClassName(l, o, i) {
              const t = l.series,
                e = t.options;
              return [
                this.options.className,
                "highcharts-label",
                i && "highcharts-tooltip-header",
                o ? "highcharts-tooltip-box" : "highcharts-tooltip",
                !i && "highcharts-color-" + P(l.colorIndex, t.colorIndex),
                e && e.className,
              ]
                .filter(M)
                .join(" ");
            }
            getLabel() {
              const l = this,
                o = this.chart.styledMode,
                i = this.options,
                t = this.split && this.allowShared,
                e =
                  i.style.pointerEvents ||
                  (this.shouldStickOnContact() ? "auto" : "none");
              let s,
                a = this.chart.renderer;
              if (this.label) {
                var b = !this.label.hasClass("highcharts-label");
                ((!t && b) || (t && !b)) && this.destroy();
              }
              if (!this.label) {
                if (this.outside) {
                  b = this.chart.options.chart.style;
                  const r = G.getRendererType();
                  (this.container = s = O.doc.createElement("div")),
                    (s.className = "highcharts-tooltip-container"),
                    p(s, {
                      position: "absolute",
                      top: "1px",
                      pointerEvents: e,
                      zIndex: Math.max(
                        this.options.style.zIndex || 0,
                        ((b && b.zIndex) || 0) + 3
                      ),
                    }),
                    O.doc.body.appendChild(s),
                    (this.renderer = a =
                      new r(s, 0, 0, b, void 0, void 0, a.styledMode));
                }
                if (
                  (t
                    ? (this.label = a.g("tooltip"))
                    : ((this.label = a
                        .label(
                          "",
                          0,
                          0,
                          i.shape,
                          void 0,
                          void 0,
                          i.useHTML,
                          void 0,
                          "tooltip"
                        )
                        .attr({ padding: i.padding, r: i.borderRadius })),
                      o ||
                        this.label
                          .attr({
                            fill: i.backgroundColor,
                            "stroke-width": i.borderWidth || 0,
                          })
                          .css(i.style)
                          .css({ pointerEvents: e })),
                  l.outside)
                ) {
                  const r = this.label,
                    { xSetter: w, ySetter: L } = r;
                  (r.xSetter = function (I) {
                    w.call(r, l.distance), (s.style.left = I + "px");
                  }),
                    (r.ySetter = function (I) {
                      L.call(r, l.distance), (s.style.top = I + "px");
                    });
                }
                this.label.attr({ zIndex: 8 }).shadow(i.shadow).add();
              }
              return this.label;
            }
            getPlayingField() {
              const { body: l, documentElement: o } = Y,
                { chart: i, distance: t, outside: e } = this;
              return {
                width: e
                  ? Math.max(
                      l.scrollWidth,
                      o.scrollWidth,
                      l.offsetWidth,
                      o.offsetWidth,
                      o.clientWidth
                    ) -
                    2 * t
                  : i.chartWidth,
                height: e
                  ? Math.max(
                      l.scrollHeight,
                      o.scrollHeight,
                      l.offsetHeight,
                      o.offsetHeight,
                      o.clientHeight
                    )
                  : i.chartHeight,
              };
            }
            getPosition(l, o, i) {
              const t = this.chart,
                e = this.distance,
                s = {},
                a = (t.inverted && i.h) || 0,
                b = this.outside;
              var r = this.getPlayingField();
              const w = r.width,
                L = r.height,
                I = t.pointer.getChartPosition();
              r = (_) => {
                const z = _ === "x";
                return [_, z ? w : L, z ? l : o].concat(
                  b
                    ? [
                        z ? l * I.scaleX : o * I.scaleY,
                        z
                          ? I.left - e + (i.plotX + t.plotLeft) * I.scaleX
                          : I.top - e + (i.plotY + t.plotTop) * I.scaleY,
                        0,
                        z ? w : L,
                      ]
                    : [
                        z ? l : o,
                        z ? i.plotX + t.plotLeft : i.plotY + t.plotTop,
                        z ? t.plotLeft : t.plotTop,
                        z ? t.plotLeft + t.plotWidth : t.plotTop + t.plotHeight,
                      ]
                );
              };
              let V = r("y"),
                B = r("x"),
                x;
              (r = !!i.negative),
                !t.polar &&
                  t.hoverSeries &&
                  t.hoverSeries.yAxis &&
                  t.hoverSeries.yAxis.reversed &&
                  (r = !r);
              const R = !this.followPointer && P(i.ttBelow, !t.inverted === r),
                W = function (_, z, J, tt, $, it, nt) {
                  const rt = b ? (_ === "y" ? e * I.scaleY : e * I.scaleX) : e,
                    at = (J - tt) / 2,
                    ct = tt < $ - e,
                    Q = $ + e + tt < z,
                    K = $ - rt - J + at;
                  if ((($ = $ + rt - at), R && Q)) s[_] = $;
                  else if (!R && ct) s[_] = K;
                  else if (ct) s[_] = Math.min(nt - tt, 0 > K - a ? K : K - a);
                  else if (Q) s[_] = Math.max(it, $ + a + J > z ? $ : $ + a);
                  else return !1;
                },
                X = function (_, z, J, tt, $) {
                  let it;
                  return (
                    $ < e || $ > z - e
                      ? (it = !1)
                      : (s[_] =
                          $ < J / 2
                            ? 1
                            : $ > z - tt / 2
                            ? z - tt - 2
                            : $ - J / 2),
                    it
                  );
                },
                Z = function (_) {
                  const z = V;
                  (V = B), (B = z), (x = _);
                },
                E = function () {
                  W.apply(0, V) !== !1
                    ? X.apply(0, B) !== !1 || x || (Z(!0), E())
                    : x
                    ? (s.x = s.y = 0)
                    : (Z(!0), E());
                };
              return (t.inverted || 1 < this.len) && Z(), E(), s;
            }
            hide(l) {
              const o = this;
              U.clearTimeout(this.hideTimer),
                (l = P(l, this.options.hideDelay)),
                this.isHidden ||
                  (this.hideTimer = m(function () {
                    o.getLabel().fadeOut(l && void 0), (o.isHidden = !0);
                  }, l));
            }
            init(l, o) {
              (this.chart = l),
                (this.options = o),
                (this.crosshairs = []),
                (this.now = { x: 0, y: 0 }),
                (this.isHidden = !0),
                (this.split = o.split && !l.inverted && !l.polar),
                (this.shared = o.shared || this.split),
                (this.outside = P(
                  o.outside,
                  !(!l.scrollablePixelsX && !l.scrollablePixelsY)
                ));
            }
            shouldStickOnContact(l) {
              return !(
                this.followPointer ||
                !this.options.stickOnContact ||
                (l &&
                  !this.chart.pointer.inClass(l.target, "highcharts-tooltip"))
              );
            }
            move(l, o, i, t) {
              const e = this,
                s = e.now,
                a =
                  e.options.animation !== !1 &&
                  !e.isHidden &&
                  (1 < Math.abs(l - s.x) || 1 < Math.abs(o - s.y)),
                b = e.followPointer || 1 < e.len;
              u(s, {
                x: a ? (2 * s.x + l) / 3 : l,
                y: a ? (s.y + o) / 2 : o,
                anchorX: b ? void 0 : a ? (2 * s.anchorX + i) / 3 : i,
                anchorY: b ? void 0 : a ? (s.anchorY + t) / 2 : t,
              }),
                e.getLabel().attr(s),
                e.drawTracker(),
                a &&
                  (U.clearTimeout(this.tooltipTimeout),
                  (this.tooltipTimeout = setTimeout(function () {
                    e && e.move(l, o, i, t);
                  }, 32)));
            }
            refresh(l, o) {
              const i = this.chart,
                t = this.options,
                e = i.pointer,
                s = j(l),
                a = s[0],
                b = [];
              var r = t.format,
                w = t.formatter || this.defaultFormatter;
              const L = this.shared,
                I = i.styledMode;
              let V = {};
              if (t.enabled && a.series) {
                U.clearTimeout(this.hideTimer),
                  (this.allowShared = !(
                    !d(l) &&
                    l.series &&
                    l.series.noSharedTooltip
                  )),
                  (this.followPointer =
                    !this.split && a.series.tooltipOptions.followPointer),
                  (l = this.getAnchor(l, o));
                var B = l[0],
                  x = l[1];
                if (
                  (L && this.allowShared
                    ? (e.applyInactiveState(s),
                      s.forEach(function (R) {
                        R.setState("hover"), b.push(R.getLabelConfig());
                      }),
                      (V = a.getLabelConfig()),
                      (V.points = b))
                    : (V = a.getLabelConfig()),
                  (this.len = b.length),
                  (r = M(r) ? H(r, V, i) : w.call(V, this)),
                  (w = a.series),
                  (this.distance = P(w.tooltipOptions.distance, 16)),
                  r === !1)
                )
                  this.hide();
                else {
                  if (this.split && this.allowShared) this.renderSplit(r, s);
                  else {
                    let R = B,
                      W = x;
                    if (
                      (o &&
                        e.isDirectTouch &&
                        ((R = o.chartX - i.plotLeft),
                        (W = o.chartY - i.plotTop)),
                      i.polar ||
                        w.options.clip === !1 ||
                        s.some(
                          (X) =>
                            e.isDirectTouch || X.series.shouldShowTooltip(R, W)
                        ))
                    )
                      (o = this.getLabel()),
                        (t.style.width && !I) ||
                          o.css({
                            width:
                              (this.outside
                                ? this.getPlayingField()
                                : i.spacingBox
                              ).width + "px",
                          }),
                        o.attr({ text: r && r.join ? r.join("") : r }),
                        o.addClass(this.getClassName(a), !0),
                        I ||
                          o.attr({
                            stroke:
                              t.borderColor || a.color || w.color || "#666666",
                          }),
                        this.updatePosition({
                          plotX: B,
                          plotY: x,
                          negative: a.negative,
                          ttBelow: a.ttBelow,
                          h: l[2] || 0,
                        });
                    else {
                      this.hide();
                      return;
                    }
                  }
                  this.isHidden &&
                    this.label &&
                    this.label.attr({ opacity: 1 }).show(),
                    (this.isHidden = !1);
                }
                n(this, "refresh");
              }
            }
            renderSplit(l, o) {
              function i(et, ot, lt, ht, mt = !0) {
                return (
                  lt
                    ? ((ot = J ? 0 : rt),
                      (et = c(
                        et - ht / 2,
                        E.left,
                        E.right - ht - (t.outside ? tt : 0)
                      )))
                    : ((ot -= it),
                      (et = mt ? et - ht - W : et + W),
                      (et = c(et, mt ? et : E.left, E.right))),
                  { x: et, y: ot }
                );
              }
              const t = this,
                {
                  chart: e,
                  chart: {
                    chartWidth: s,
                    chartHeight: a,
                    plotHeight: b,
                    plotLeft: r,
                    plotTop: w,
                    pointer: L,
                    scrollablePixelsY: I = 0,
                    scrollablePixelsX: V,
                    scrollingContainer: { scrollLeft: B, scrollTop: x } = {
                      scrollLeft: 0,
                      scrollTop: 0,
                    },
                    styledMode: R,
                  },
                  distance: W,
                  options: X,
                  options: { positioner: Z },
                } = t,
                E =
                  t.outside && typeof V != "number"
                    ? Y.documentElement.getBoundingClientRect()
                    : { left: B, right: B + s, top: x, bottom: x + a },
                _ = t.getLabel(),
                z = this.renderer || e.renderer,
                J = !(!e.xAxis[0] || !e.xAxis[0].opposite),
                { left: tt, top: $ } = L.getChartPosition();
              let it = w + x,
                nt = 0,
                rt = b - I;
              M(l) && (l = [!1, l]),
                (l = l.slice(0, o.length + 1).reduce(function (et, ot, lt) {
                  if (ot !== !1 && ot !== "") {
                    lt = o[lt - 1] || {
                      isHeader: !0,
                      plotX: o[0].plotX,
                      plotY: b,
                      series: {},
                    };
                    const St = lt.isHeader;
                    var ht = St ? t : lt.series,
                      mt;
                    {
                      var yt = lt;
                      ot = ot.toString();
                      var gt = ht.tt;
                      const { isHeader: Ct, series: ut } = yt;
                      gt ||
                        ((gt = { padding: X.padding, r: X.borderRadius }),
                        R ||
                          ((gt.fill = X.backgroundColor),
                          (gt["stroke-width"] =
                            (mt = X.borderWidth) !== null && mt !== void 0
                              ? mt
                              : 1)),
                        (gt = z
                          .label(
                            "",
                            0,
                            0,
                            X[Ct ? "headerShape" : "shape"],
                            void 0,
                            void 0,
                            X.useHTML
                          )
                          .addClass(t.getClassName(yt, !0, Ct))
                          .attr(gt)
                          .add(_))),
                        (gt.isActive = !0),
                        gt.attr({ text: ot }),
                        R ||
                          gt
                            .css(X.style)
                            .attr({
                              stroke:
                                X.borderColor ||
                                yt.color ||
                                ut.color ||
                                "#333333",
                            }),
                        (mt = gt);
                    }
                    (mt = ht.tt = mt),
                      (yt = mt.getBBox()),
                      (ht = yt.width + mt.strokeWidth()),
                      St && ((nt = yt.height), (rt += nt), J && (it -= nt));
                    {
                      const {
                        isHeader: Ct,
                        plotX: ut = 0,
                        plotY: Tt = 0,
                        series: Rt,
                      } = lt;
                      if (Ct) {
                        ot = r + ut;
                        var ft = w + b / 2;
                      } else {
                        const { xAxis: Yt, yAxis: It } = Rt;
                        (ot = Yt.pos + c(ut, -W, Yt.len + W)),
                          Rt.shouldShowTooltip(0, It.pos - w + Tt, {
                            ignoreX: !0,
                          }) && (ft = It.pos + Tt);
                      }
                      (ot = c(ot, E.left - W, E.right + W)),
                        (ft = { anchorX: ot, anchorY: ft });
                    }
                    const { anchorX: bt, anchorY: kt } = ft;
                    typeof kt == "number"
                      ? ((ft = yt.height + 1),
                        (yt = Z ? Z.call(t, ht, ft, lt) : i(bt, kt, St, ht)),
                        et.push({
                          align: Z ? 0 : void 0,
                          anchorX: bt,
                          anchorY: kt,
                          boxWidth: ht,
                          point: lt,
                          rank: P(yt.rank, St ? 1 : 0),
                          size: ft,
                          target: yt.y,
                          tt: mt,
                          x: yt.x,
                        }))
                      : (mt.isActive = !1);
                  }
                  return et;
                }, [])),
                !Z &&
                  l.some((et) => {
                    var { outside: ot } = t;
                    return (
                      (ot = (ot ? tt : 0) + et.anchorX),
                      ot < E.left && ot + et.boxWidth < E.right
                        ? !0
                        : ot < tt - E.left + et.boxWidth && E.right - ot > ot
                    );
                  }) &&
                  (l = l.map((et) => {
                    const { x: ot, y: lt } = i(
                      et.anchorX,
                      et.anchorY,
                      et.point.isHeader,
                      et.boxWidth,
                      !1
                    );
                    return u(et, { target: lt, x: ot });
                  })),
                t.cleanSplit(),
                N(l, rt);
              var at = tt,
                ct = tt;
              l.forEach(function (et) {
                const { x: ot, boxWidth: lt, isHeader: ht } = et;
                ht ||
                  (t.outside && tt + ot < at && (at = tt + ot),
                  !ht && t.outside && at + lt > ct && (ct = tt + ot));
              }),
                l.forEach(function (et) {
                  const {
                      x: ot,
                      anchorX: lt,
                      anchorY: ht,
                      pos: mt,
                      point: { isHeader: yt },
                    } = et,
                    gt = {
                      visibility: typeof mt > "u" ? "hidden" : "inherit",
                      x: ot,
                      y: (mt || 0) + it,
                      anchorX: lt,
                      anchorY: ht,
                    };
                  if (t.outside && ot < lt) {
                    const ft = tt - at;
                    0 < ft &&
                      (yt || ((gt.x = ot + ft), (gt.anchorX = lt + ft)),
                      yt && ((gt.x = (ct - at) / 2), (gt.anchorX = lt + ft)));
                  }
                  et.tt.attr(gt);
                });
              const { container: Q, outside: K, renderer: st } = t;
              if (K && Q && st) {
                const { width: et, height: ot, x: lt, y: ht } = _.getBBox();
                st.setSize(et + lt, ot + ht, !1),
                  (Q.style.left = at + "px"),
                  (Q.style.top = $ + "px");
              }
              S && _.attr({ opacity: _.opacity === 1 ? 0.999 : 1 });
            }
            drawTracker() {
              if (this.shouldStickOnContact()) {
                var l = this.chart,
                  o = this.label,
                  i = this.shared ? l.hoverPoints : l.hoverPoint;
                if (o && i) {
                  var t = { x: 0, y: 0, width: 0, height: 0 };
                  i = this.getAnchor(i);
                  var e = o.getBBox();
                  (i[0] += l.plotLeft - o.translateX),
                    (i[1] += l.plotTop - o.translateY),
                    (t.x = Math.min(0, i[0])),
                    (t.y = Math.min(0, i[1])),
                    (t.width =
                      0 > i[0]
                        ? Math.max(Math.abs(i[0]), e.width - i[0])
                        : Math.max(Math.abs(i[0]), e.width)),
                    (t.height =
                      0 > i[1]
                        ? Math.max(Math.abs(i[1]), e.height - Math.abs(i[1]))
                        : Math.max(Math.abs(i[1]), e.height)),
                    this.tracker
                      ? this.tracker.attr(t)
                      : ((this.tracker = o.renderer
                          .rect(t)
                          .addClass("highcharts-tracker")
                          .add(o)),
                        l.styledMode ||
                          this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
                }
              } else this.tracker && (this.tracker = this.tracker.destroy());
            }
            styledModeFormat(l) {
              return l
                .replace(
                  'style="font-size: 0.8em"',
                  'class="highcharts-header"'
                )
                .replace(
                  /style="color:{(point|series)\.color}"/g,
                  'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"'
                );
            }
            tooltipFooterHeaderFormatter(l, o) {
              const i = l.series,
                t = i.tooltipOptions;
              var e = i.xAxis;
              const s = e && e.dateTime;
              e = { isFooter: o, labelConfig: l };
              let a = t.xDateFormat,
                b = t[o ? "footerFormat" : "headerFormat"];
              return (
                n(this, "headerFormatter", e, function (r) {
                  s &&
                    !a &&
                    g(l.key) &&
                    (a = s.getXDateFormat(l.key, t.dateTimeLabelFormats)),
                    s &&
                      a &&
                      ((l.point && l.point.tooltipDateKeys) || ["key"]).forEach(
                        function (w) {
                          b = b.replace(
                            "{point." + w + "}",
                            "{point." + w + ":" + a + "}"
                          );
                        }
                      ),
                    i.chart.styledMode && (b = this.styledModeFormat(b)),
                    (r.text = H(b, { point: l, series: i }, this.chart));
                }),
                e.text
              );
            }
            update(l) {
              this.destroy(), this.init(this.chart, C(!0, this.options, l));
            }
            updatePosition(l) {
              const { chart: o, distance: i, options: t } = this;
              var e = o.pointer;
              const s = this.getLabel(),
                {
                  left: a,
                  top: b,
                  scaleX: r,
                  scaleY: w,
                } = e.getChartPosition();
              e = (t.positioner || this.getPosition).call(
                this,
                s.width,
                s.height,
                l
              );
              let L = (l.plotX || 0) + o.plotLeft;
              l = (l.plotY || 0) + o.plotTop;
              let I;
              this.outside &&
                (t.positioner && ((e.x += a - i), (e.y += b - i)),
                (I = (t.borderWidth || 0) + 2 * i),
                this.renderer.setSize(s.width + I, s.height + I, !1),
                (r !== 1 || w !== 1) &&
                  (p(this.container, { transform: `scale(${r}, ${w})` }),
                  (L *= r),
                  (l *= w)),
                (L += a - e.x),
                (l += b - e.y)),
                this.move(Math.round(e.x), Math.round(e.y || 0), L, l);
            }
          }
          return (
            (function (v) {
              const l = [];
              v.compose = function (o) {
                U.pushUnique(l, o) &&
                  D(o, "afterInit", function () {
                    const i = this.chart;
                    i.options.tooltip &&
                      (i.tooltip = new v(i, i.options.tooltip));
                  });
              };
            })(h || (h = {})),
            h
          );
        }
      ),
      T(
        y,
        "Core/Series/Point.js",
        [
          y["Core/Renderer/HTML/AST.js"],
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Defaults.js"],
          y["Core/Templating.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U) {
          const { animObject: H } = O,
            { defaultOptions: Y } = F,
            { format: S } = G,
            {
              addEvent: N,
              defined: D,
              erase: c,
              extend: p,
              fireEvent: f,
              getNestedProperty: u,
              isArray: n,
              isFunction: d,
              isNumber: g,
              isObject: M,
              merge: C,
              objectEach: P,
              pick: j,
              syncTimeout: m,
              removeEvent: h,
              uniqueKey: v,
            } = U;
          class l {
            constructor() {
              (this.category = void 0),
                (this.destroyed = !1),
                (this.formatPrefix = "point"),
                (this.id = void 0),
                (this.isNull = !1),
                (this.percentage = this.options = this.name = void 0),
                (this.selected = !1),
                (this.total = this.shapeArgs = this.series = void 0),
                (this.visible = !0),
                (this.x = void 0);
            }
            animateBeforeDestroy() {
              const i = this,
                t = { x: i.startXPos, opacity: 0 },
                e = i.getGraphicalProps();
              e.singular.forEach(function (s) {
                i[s] = i[s].animate(
                  s === "dataLabel"
                    ? { x: i[s].startXPos, y: i[s].startYPos, opacity: 0 }
                    : t
                );
              }),
                e.plural.forEach(function (s) {
                  i[s].forEach(function (a) {
                    a.element &&
                      a.animate(
                        p(
                          { x: i.startXPos },
                          a.startYPos ? { x: a.startXPos, y: a.startYPos } : {}
                        )
                      );
                  });
                });
            }
            applyOptions(i, t) {
              const e = this.series,
                s = e.options.pointValKey || e.pointValKey;
              return (
                (i = l.prototype.optionsToObject.call(this, i)),
                p(this, i),
                (this.options = this.options ? p(this.options, i) : i),
                i.group && delete this.group,
                i.dataLabels && delete this.dataLabels,
                s && (this.y = l.prototype.getNestedProperty.call(this, s)),
                (this.formatPrefix = (this.isNull =
                  this.isValid && !this.isValid())
                  ? "null"
                  : "point"),
                this.selected && (this.state = "select"),
                "name" in this &&
                  typeof t > "u" &&
                  e.xAxis &&
                  e.xAxis.hasNames &&
                  (this.x = e.xAxis.nameToX(this)),
                typeof this.x > "u" && e
                  ? (this.x = typeof t > "u" ? e.autoIncrement() : t)
                  : g(i.x) &&
                    e.options.relativeXValue &&
                    (this.x = e.autoIncrement(i.x)),
                this
              );
            }
            destroy() {
              if (!this.destroyed) {
                const t = this;
                var i = t.series;
                const e = i.chart;
                i = i.options.dataSorting;
                const s = e.hoverPoints,
                  a = H(t.series.chart.renderer.globalAnimation),
                  b = () => {
                    (t.graphic || t.graphics || t.dataLabel || t.dataLabels) &&
                      (h(t), t.destroyElements());
                    for (const r in t) delete t[r];
                  };
                t.legendItem && e.legend.destroyItem(t),
                  s &&
                    (t.setState(), c(s, t), s.length || (e.hoverPoints = null)),
                  t === e.hoverPoint && t.onMouseOut(),
                  i && i.enabled
                    ? (this.animateBeforeDestroy(), m(b, a.duration))
                    : b(),
                  e.pointCount--;
              }
              this.destroyed = !0;
            }
            destroyElements(i) {
              const t = this;
              (i = t.getGraphicalProps(i)),
                i.singular.forEach(function (e) {
                  t[e] = t[e].destroy();
                }),
                i.plural.forEach(function (e) {
                  t[e].forEach(function (s) {
                    s && s.element && s.destroy();
                  }),
                    delete t[e];
                });
            }
            firePointEvent(i, t, e) {
              const s = this,
                a = this.series.options;
              (a.point.events[i] ||
                (s.options && s.options.events && s.options.events[i])) &&
                s.importEvents(),
                i === "click" &&
                  a.allowPointSelect &&
                  (e = function (b) {
                    s.select &&
                      s.select(null, b.ctrlKey || b.metaKey || b.shiftKey);
                  }),
                f(s, i, t, e);
            }
            getClassName() {
              return (
                "highcharts-point" +
                (this.selected ? " highcharts-point-select" : "") +
                (this.negative ? " highcharts-negative" : "") +
                (this.isNull ? " highcharts-null-point" : "") +
                (typeof this.colorIndex < "u"
                  ? " highcharts-color-" + this.colorIndex
                  : "") +
                (this.options.className ? " " + this.options.className : "") +
                (this.zone && this.zone.className
                  ? " " + this.zone.className.replace("highcharts-negative", "")
                  : "")
              );
            }
            getGraphicalProps(i) {
              const t = this,
                e = [],
                s = { singular: [], plural: [] };
              let a, b;
              for (
                i = i || { graphic: 1, dataLabel: 1 },
                  i.graphic && e.push("graphic"),
                  i.dataLabel &&
                    e.push(
                      "dataLabel",
                      "dataLabelPath",
                      "dataLabelUpper",
                      "connector"
                    ),
                  b = e.length;
                b--;

              )
                (a = e[b]), t[a] && s.singular.push(a);
              return (
                ["graphic", "dataLabel", "connector"].forEach(function (r) {
                  const w = r + "s";
                  i[r] && t[w] && s.plural.push(w);
                }),
                s
              );
            }
            getLabelConfig() {
              return {
                x: this.category,
                y: this.y,
                color: this.color,
                colorIndex: this.colorIndex,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal,
              };
            }
            getNestedProperty(i) {
              if (i)
                return i.indexOf("custom.") === 0
                  ? u(i, this.options)
                  : this[i];
            }
            getZone() {
              var i = this.series;
              const t = i.zones;
              i = i.zoneAxis || "y";
              let e,
                s = 0;
              for (e = t[s]; this[i] >= e.value; ) e = t[++s];
              return (
                this.nonZonedColor || (this.nonZonedColor = this.color),
                (this.color =
                  e && e.color && !this.options.color
                    ? e.color
                    : this.nonZonedColor),
                e
              );
            }
            hasNewShapeType() {
              return (
                (this.graphic &&
                  (this.graphic.symbolName ||
                    this.graphic.element.nodeName)) !== this.shapeType
              );
            }
            init(i, t, e) {
              return (
                (this.series = i),
                this.applyOptions(t, e),
                (this.id = D(this.id) ? this.id : v()),
                this.resolveColor(),
                i.chart.pointCount++,
                f(this, "afterInit"),
                this
              );
            }
            isValid() {
              return this.x !== null && g(this.y);
            }
            optionsToObject(i) {
              var t = this.series;
              const e = t.options.keys,
                s = e || t.pointArrayMap || ["y"],
                a = s.length;
              let b = {},
                r = 0,
                w = 0;
              if (g(i) || i === null) b[s[0]] = i;
              else if (n(i))
                for (
                  !e &&
                  i.length > a &&
                  ((t = typeof i[0]),
                  t === "string"
                    ? (b.name = i[0])
                    : t === "number" && (b.x = i[0]),
                  r++);
                  w < a;

                )
                  (e && typeof i[r] > "u") ||
                    (0 < s[w].indexOf(".")
                      ? l.prototype.setNestedProperty(b, i[r], s[w])
                      : (b[s[w]] = i[r])),
                    r++,
                    w++;
              else
                typeof i == "object" &&
                  ((b = i),
                  i.dataLabels && (t._hasPointLabels = !0),
                  i.marker && (t._hasPointMarkers = !0));
              return b;
            }
            pos(i, t = this.plotY) {
              if (!this.destroyed) {
                const { plotX: e, series: s } = this,
                  { chart: a, xAxis: b, yAxis: r } = s;
                let w = 0,
                  L = 0;
                if (g(e) && g(t))
                  return (
                    i &&
                      ((w = b ? b.pos : a.plotLeft),
                      (L = r ? r.pos : a.plotTop)),
                    a.inverted && b && r
                      ? [r.len - t + L, b.len - e + w]
                      : [e + w, t + L]
                  );
              }
            }
            resolveColor() {
              const i = this.series;
              var t = i.chart.styledMode;
              let e;
              var s = i.chart.options.chart.colorCount;
              delete this.nonZonedColor,
                i.options.colorByPoint
                  ? (t ||
                      ((s = i.options.colors || i.chart.options.colors),
                      (e = s[i.colorCounter]),
                      (s = s.length)),
                    (t = i.colorCounter),
                    i.colorCounter++,
                    i.colorCounter === s && (i.colorCounter = 0))
                  : (t || (e = i.color), (t = i.colorIndex)),
                (this.colorIndex = j(this.options.colorIndex, t)),
                (this.color = j(this.options.color, e));
            }
            setNestedProperty(i, t, e) {
              return (
                e.split(".").reduce(function (s, a, b, r) {
                  return (
                    (s[a] = r.length - 1 === b ? t : M(s[a], !0) ? s[a] : {}),
                    s[a]
                  );
                }, i),
                i
              );
            }
            shouldDraw() {
              return !this.isNull;
            }
            tooltipFormatter(i) {
              const t = this.series,
                e = t.tooltipOptions,
                s = j(e.valueDecimals, ""),
                a = e.valuePrefix || "",
                b = e.valueSuffix || "";
              return (
                t.chart.styledMode && (i = t.chart.tooltip.styledModeFormat(i)),
                (t.pointArrayMap || ["y"]).forEach(function (r) {
                  (r = "{point." + r),
                    (a || b) &&
                      (i = i.replace(RegExp(r + "}", "g"), a + r + "}" + b)),
                    (i = i.replace(RegExp(r + "}", "g"), r + ":,." + s + "f}"));
                }),
                S(i, { point: this, series: this.series }, t.chart)
              );
            }
            update(i, t, e, s) {
              function a() {
                b.applyOptions(i);
                var B = w && b.hasMockGraphic;
                (B = b.y === null ? !B : B),
                  w &&
                    B &&
                    ((b.graphic = w.destroy()), delete b.hasMockGraphic),
                  M(i, !0) &&
                    (w &&
                      w.element &&
                      i &&
                      i.marker &&
                      typeof i.marker.symbol < "u" &&
                      (b.graphic = w.destroy()),
                    i &&
                      i.dataLabels &&
                      b.dataLabel &&
                      (b.dataLabel = b.dataLabel.destroy()),
                    b.connector && (b.connector = b.connector.destroy())),
                  (V = b.index),
                  r.updateParallelArrays(b, V),
                  (I.data[V] =
                    M(I.data[V], !0) || M(i, !0) ? b.options : j(i, I.data[V])),
                  (r.isDirty = r.isDirtyData = !0),
                  !r.fixedBox && r.hasCartesianSeries && (L.isDirtyBox = !0),
                  I.legendType === "point" && (L.isDirtyLegend = !0),
                  t && L.redraw(e);
              }
              const b = this,
                r = b.series,
                w = b.graphic,
                L = r.chart,
                I = r.options;
              let V;
              (t = j(t, !0)),
                s === !1 ? a() : b.firePointEvent("update", { options: i }, a);
            }
            remove(i, t) {
              this.series.removePoint(this.series.data.indexOf(this), i, t);
            }
            select(i, t) {
              const e = this,
                s = e.series,
                a = s.chart;
              (this.selectedStaging = i = j(i, !e.selected)),
                e.firePointEvent(
                  i ? "select" : "unselect",
                  { accumulate: t },
                  function () {
                    (e.selected = e.options.selected = i),
                      (s.options.data[s.data.indexOf(e)] = e.options),
                      e.setState(i && "select"),
                      t ||
                        a.getSelectedPoints().forEach(function (b) {
                          const r = b.series;
                          b.selected &&
                            b !== e &&
                            ((b.selected = b.options.selected = !1),
                            (r.options.data[r.data.indexOf(b)] = b.options),
                            b.setState(
                              a.hoverPoints && r.options.inactiveOtherPoints
                                ? "inactive"
                                : ""
                            ),
                            b.firePointEvent("unselect"));
                        });
                  }
                ),
                delete this.selectedStaging;
            }
            onMouseOver(i) {
              const t = this.series.chart,
                e = t.pointer;
              (i = i
                ? e.normalize(i)
                : e.getChartCoordinatesFromPoint(this, t.inverted)),
                e.runPointActions(i, this);
            }
            onMouseOut() {
              const i = this.series.chart;
              this.firePointEvent("mouseOut"),
                this.series.options.inactiveOtherPoints ||
                  (i.hoverPoints || []).forEach(function (t) {
                    t.setState();
                  }),
                (i.hoverPoints = i.hoverPoint = null);
            }
            importEvents() {
              if (!this.hasImportedEvents) {
                const i = this,
                  t = C(i.series.options.point, i.options).events;
                (i.events = t),
                  P(t, function (e, s) {
                    d(e) && N(i, s, e);
                  }),
                  (this.hasImportedEvents = !0);
              }
            }
            setState(i, t) {
              const e = this.series;
              var s = this.state,
                a = e.options.states[i || "normal"] || {},
                b = Y.plotOptions[e.type].marker && e.options.marker;
              const r = b && b.enabled === !1,
                w = (b && b.states && b.states[i || "normal"]) || {},
                L = w.enabled === !1,
                I = this.marker || {},
                V = e.chart,
                B = b && e.markerAttribs;
              let x = e.halo;
              var R;
              let W;
              var X = e.stateMarkerGraphic;
              if (
                ((i = i || ""),
                !(
                  (i === this.state && !t) ||
                  (this.selected && i !== "select") ||
                  a.enabled === !1 ||
                  (i && (L || (r && w.enabled === !1))) ||
                  (i && I.states && I.states[i] && I.states[i].enabled === !1)
                ))
              ) {
                if (
                  ((this.state = i),
                  B && (R = e.markerAttribs(this, i)),
                  this.graphic && !this.hasMockGraphic)
                ) {
                  if (
                    (s && this.graphic.removeClass("highcharts-point-" + s),
                    i && this.graphic.addClass("highcharts-point-" + i),
                    !V.styledMode)
                  ) {
                    (s = e.pointAttribs(this, i)),
                      (W = j(V.options.chart.animation, a.animation));
                    const Z = s.opacity;
                    e.options.inactiveOtherPoints &&
                      g(Z) &&
                      ((this.dataLabels || []).forEach(function (E) {
                        E &&
                          !E.hasClass("highcharts-data-label-hidden") &&
                          E.animate({ opacity: Z }, W);
                      }),
                      this.connector &&
                        this.connector.animate({ opacity: Z }, W)),
                      this.graphic.animate(s, W);
                  }
                  R &&
                    this.graphic.animate(
                      R,
                      j(V.options.chart.animation, w.animation, b.animation)
                    ),
                    X && X.hide();
                } else
                  i &&
                    w &&
                    ((b = I.symbol || e.symbol),
                    X && X.currentSymbol !== b && (X = X.destroy()),
                    R &&
                      (X
                        ? X[t ? "animate" : "attr"]({ x: R.x, y: R.y })
                        : b &&
                          ((e.stateMarkerGraphic = X =
                            V.renderer
                              .symbol(b, R.x, R.y, R.width, R.height)
                              .add(e.markerGroup)),
                          (X.currentSymbol = b))),
                    !V.styledMode &&
                      X &&
                      this.state !== "inactive" &&
                      X.attr(e.pointAttribs(this, i))),
                    X &&
                      (X[i && this.isInside ? "show" : "hide"](),
                      (X.element.point = this),
                      X.addClass(this.getClassName(), !0));
                (a = a.halo),
                  (R = ((X = this.graphic || X) && X.visibility) || "inherit"),
                  a && a.size && X && R !== "hidden" && !this.isCluster
                    ? (x || (e.halo = x = V.renderer.path().add(X.parentGroup)),
                      x
                        .show()
                        [t ? "animate" : "attr"]({ d: this.haloPath(a.size) }),
                      x.attr({
                        class:
                          "highcharts-halo highcharts-color-" +
                          j(this.colorIndex, e.colorIndex) +
                          (this.className ? " " + this.className : ""),
                        visibility: R,
                        zIndex: -1,
                      }),
                      (x.point = this),
                      V.styledMode ||
                        x.attr(
                          p(
                            {
                              fill: this.color || e.color,
                              "fill-opacity": a.opacity,
                            },
                            A.filterUserAttributes(a.attributes || {})
                          )
                        ))
                    : x &&
                      x.point &&
                      x.point.haloPath &&
                      x.animate({ d: x.point.haloPath(0) }, null, x.hide),
                  f(this, "afterSetState", { state: i });
              }
            }
            haloPath(i) {
              const t = this.pos();
              return t
                ? this.series.chart.renderer.symbols.circle(
                    Math.floor(t[0]) - i,
                    t[1] - i,
                    2 * i,
                    2 * i
                  )
                : [];
            }
          }
          return l;
        }
      ),
      T(
        y,
        "Core/Pointer.js",
        [
          y["Core/Color/Color.js"],
          y["Core/Globals.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { parse: G } = A,
            { charts: U, noop: H } = O,
            {
              addEvent: Y,
              attr: S,
              css: N,
              defined: D,
              extend: c,
              find: p,
              fireEvent: f,
              isNumber: u,
              isObject: n,
              objectEach: d,
              offset: g,
              pick: M,
              splat: C,
            } = F;
          class P {
            constructor(m, h) {
              (this.lastValidTouch = {}),
                (this.pinchDown = []),
                (this.runChartClick = !1),
                (this.eventsToUnbind = []),
                (this.chart = m),
                (this.hasDragged = !1),
                (this.options = h),
                this.init(m, h);
            }
            applyInactiveState(m) {
              let h = [],
                v;
              (m || []).forEach(function (l) {
                (v = l.series),
                  h.push(v),
                  v.linkedParent && h.push(v.linkedParent),
                  v.linkedSeries && (h = h.concat(v.linkedSeries)),
                  v.navigatorSeries && h.push(v.navigatorSeries);
              }),
                this.chart.series.forEach(function (l) {
                  h.indexOf(l) === -1
                    ? l.setState("inactive", !0)
                    : l.options.inactiveOtherPoints &&
                      l.setAllPointsToState("inactive");
                });
            }
            destroy() {
              const m = this;
              this.eventsToUnbind.forEach((h) => h()),
                (this.eventsToUnbind = []),
                O.chartCount ||
                  (P.unbindDocumentMouseUp &&
                    (P.unbindDocumentMouseUp = P.unbindDocumentMouseUp()),
                  P.unbindDocumentTouchEnd &&
                    (P.unbindDocumentTouchEnd = P.unbindDocumentTouchEnd())),
                clearInterval(m.tooltipTimeout),
                d(m, function (h, v) {
                  m[v] = void 0;
                });
            }
            getSelectionMarkerAttrs(m, h) {
              const v = {
                args: { chartX: m, chartY: h },
                attrs: {},
                shapeType: "rect",
              };
              return (
                f(this, "getSelectionMarkerAttrs", v, (l) => {
                  const {
                    chart: o,
                    mouseDownX: i = 0,
                    mouseDownY: t = 0,
                    zoomHor: e,
                    zoomVert: s,
                  } = this;
                  l = l.attrs;
                  let a;
                  (l.x = o.plotLeft),
                    (l.y = o.plotTop),
                    (l.width = e ? 1 : o.plotWidth),
                    (l.height = s ? 1 : o.plotHeight),
                    e &&
                      ((a = m - i),
                      (l.width = Math.abs(a)),
                      (l.x = (0 < a ? 0 : a) + i)),
                    s &&
                      ((a = h - t),
                      (l.height = Math.abs(a)),
                      (l.y = (0 < a ? 0 : a) + t));
                }),
                v
              );
            }
            drag(m) {
              const h = this.chart,
                v = h.options.chart;
              var l = h.plotLeft;
              const o = h.plotTop,
                i = h.plotWidth,
                t = h.plotHeight,
                e = this.mouseDownX || 0,
                s = this.mouseDownY || 0,
                a = n(v.panning) ? v.panning && v.panning.enabled : v.panning,
                b = v.panKey && m[v.panKey + "Key"];
              let r = m.chartX,
                w = m.chartY,
                L = this.selectionMarker;
              if (
                (!L || !L.touch) &&
                (r < l ? (r = l) : r > l + i && (r = l + i),
                w < o ? (w = o) : w > o + t && (w = o + t),
                (this.hasDragged = Math.sqrt(
                  Math.pow(e - r, 2) + Math.pow(s - w, 2)
                )),
                10 < this.hasDragged)
              ) {
                l = h.isInsidePlot(e - l, s - o, { visiblePlotOnly: !0 });
                const { shapeType: I, attrs: V } = this.getSelectionMarkerAttrs(
                  r,
                  w
                );
                (!h.hasCartesianSeries && !h.mapView) ||
                  (!this.zoomX && !this.zoomY) ||
                  !l ||
                  b ||
                  L ||
                  ((this.selectionMarker = L = h.renderer[I]()),
                  L.attr({
                    class: "highcharts-selection-marker",
                    zIndex: 7,
                  }).add(),
                  h.styledMode ||
                    L.attr({
                      fill:
                        v.selectionMarkerFill ||
                        G("#334eff").setOpacity(0.25).get(),
                    })),
                  L && L.attr(V),
                  l && !L && a && h.pan(m, v.panning);
              }
            }
            dragStart(m) {
              const h = this.chart;
              (h.mouseIsDown = m.type),
                (h.cancelClick = !1),
                (h.mouseDownX = this.mouseDownX = m.chartX),
                (h.mouseDownY = this.mouseDownY = m.chartY);
            }
            getSelectionBox(m) {
              const h = { args: { marker: m }, result: {} };
              return (
                f(this, "getSelectionBox", h, (v) => {
                  v.result = {
                    x: m.attr ? +m.attr("x") : m.x,
                    y: m.attr ? +m.attr("y") : m.y,
                    width: m.attr ? m.attr("width") : m.width,
                    height: m.attr ? m.attr("height") : m.height,
                  };
                }),
                h.result
              );
            }
            drop(m) {
              const h = this,
                v = this.chart,
                l = this.hasPinched;
              if (this.selectionMarker) {
                const {
                    x: o,
                    y: i,
                    width: t,
                    height: e,
                  } = this.getSelectionBox(this.selectionMarker),
                  s = {
                    originalEvent: m,
                    xAxis: [],
                    yAxis: [],
                    x: o,
                    y: i,
                    width: t,
                    height: e,
                  };
                let a = !!v.mapView;
                (this.hasDragged || l) &&
                  (v.axes.forEach(function (b) {
                    if (
                      b.zoomEnabled &&
                      D(b.min) &&
                      (l || h[{ xAxis: "zoomX", yAxis: "zoomY" }[b.coll]]) &&
                      u(o) &&
                      u(i) &&
                      u(t) &&
                      u(e)
                    ) {
                      var r = b.horiz;
                      const w = m.type === "touchend" ? b.minPixelPadding : 0,
                        L = b.toValue((r ? o : i) + w);
                      (r = b.toValue((r ? o + t : i + e) - w)),
                        s[b.coll].push({
                          axis: b,
                          min: Math.min(L, r),
                          max: Math.max(L, r),
                        }),
                        (a = !0);
                    }
                  }),
                  a &&
                    f(v, "selection", s, function (b) {
                      v.zoom(c(b, l ? { animation: !1 } : null));
                    })),
                  u(v.index) &&
                    (this.selectionMarker = this.selectionMarker.destroy()),
                  l && this.scaleGroups();
              }
              v &&
                u(v.index) &&
                (N(v.container, { cursor: v._cursor }),
                (v.cancelClick = 10 < this.hasDragged),
                (v.mouseIsDown = this.hasDragged = this.hasPinched = !1),
                (this.pinchDown = []));
            }
            findNearestKDPoint(m, h, v) {
              let l;
              return (
                m.forEach(function (o) {
                  var i =
                    !(o.noSharedTooltip && h) &&
                    0 > o.options.findNearestPointBy.indexOf("y");
                  if (
                    ((o = o.searchPoint(v, i)),
                    (i = n(o, !0) && o.series) && !(i = !n(l, !0)))
                  ) {
                    {
                      i = l.distX - o.distX;
                      const t = l.dist - o.dist,
                        e =
                          (o.series.group && o.series.group.zIndex) -
                          (l.series.group && l.series.group.zIndex);
                      i =
                        i !== 0 && h
                          ? i
                          : t !== 0
                          ? t
                          : e !== 0
                          ? e
                          : l.series.index > o.series.index
                          ? -1
                          : 1;
                    }
                    i = 0 < i;
                  }
                  i && (l = o);
                }),
                l
              );
            }
            getChartCoordinatesFromPoint(m, h) {
              var v = m.series;
              const l = v.xAxis;
              v = v.yAxis;
              const o = m.shapeArgs;
              if (l && v) {
                let i = M(m.clientX, m.plotX),
                  t = m.plotY || 0;
                return (
                  m.isNode && o && u(o.x) && u(o.y) && ((i = o.x), (t = o.y)),
                  h
                    ? { chartX: v.len + v.pos - t, chartY: l.len + l.pos - i }
                    : { chartX: i + l.pos, chartY: t + v.pos }
                );
              }
              if (o && o.x && o.y) return { chartX: o.x, chartY: o.y };
            }
            getChartPosition() {
              if (this.chartPosition) return this.chartPosition;
              var { container: m } = this.chart;
              const h = g(m);
              this.chartPosition = {
                left: h.left,
                top: h.top,
                scaleX: 1,
                scaleY: 1,
              };
              const v = m.offsetWidth;
              return (
                (m = m.offsetHeight),
                2 < v &&
                  2 < m &&
                  ((this.chartPosition.scaleX = h.width / v),
                  (this.chartPosition.scaleY = h.height / m)),
                this.chartPosition
              );
            }
            getCoordinates(m) {
              const h = { xAxis: [], yAxis: [] };
              return (
                this.chart.axes.forEach(function (v) {
                  h[v.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: v,
                    value: v.toValue(m[v.horiz ? "chartX" : "chartY"]),
                  });
                }),
                h
              );
            }
            getHoverData(m, h, v, l, o, i) {
              const t = [];
              l = !(!l || !m);
              const e = function (r) {
                return (
                  r.visible &&
                  !(!o && r.directTouch) &&
                  M(r.options.enableMouseTracking, !0)
                );
              };
              let s,
                a = {
                  chartX: i ? i.chartX : void 0,
                  chartY: i ? i.chartY : void 0,
                  shared: o,
                };
              f(this, "beforeGetHoverData", a),
                (s =
                  h && !h.stickyTracking
                    ? [h]
                    : v.filter((r) => r.stickyTracking && (a.filter || e)(r)));
              const b = l || !i ? m : this.findNearestKDPoint(s, o, i);
              return (
                (h = b && b.series),
                b &&
                  (o && !h.noSharedTooltip
                    ? ((s = v.filter(function (r) {
                        return a.filter
                          ? a.filter(r)
                          : e(r) && !r.noSharedTooltip;
                      })),
                      s.forEach(function (r) {
                        let w = p(r.points, function (L) {
                          return L.x === b.x && !L.isNull;
                        });
                        n(w) &&
                          (r.boosted && r.boost && (w = r.boost.getPoint(w)),
                          t.push(w));
                      }))
                    : t.push(b)),
                (a = { hoverPoint: b }),
                f(this, "afterGetHoverData", a),
                { hoverPoint: a.hoverPoint, hoverSeries: h, hoverPoints: t }
              );
            }
            getPointFromEvent(m) {
              m = m.target;
              let h;
              for (; m && !h; ) (h = m.point), (m = m.parentNode);
              return h;
            }
            onTrackerMouseOut(m) {
              m = m.relatedTarget;
              const h = this.chart.hoverSeries;
              (this.isDirectTouch = !1),
                !h ||
                  !m ||
                  h.stickyTracking ||
                  this.inClass(m, "highcharts-tooltip") ||
                  (this.inClass(m, "highcharts-series-" + h.index) &&
                    this.inClass(m, "highcharts-tracker")) ||
                  h.onMouseOut();
            }
            inClass(m, h) {
              let v;
              for (; m; ) {
                if ((v = S(m, "class"))) {
                  if (v.indexOf(h) !== -1) return !0;
                  if (v.indexOf("highcharts-container") !== -1) return !1;
                }
                m = m.parentElement;
              }
            }
            init(m, h) {
              (this.options = h),
                (this.chart = m),
                (this.runChartClick = !(
                  !h.chart.events || !h.chart.events.click
                )),
                (this.pinchDown = []),
                (this.lastValidTouch = {}),
                this.setDOMEvents(),
                f(this, "afterInit");
            }
            normalize(m, h) {
              var v = m.touches,
                l = v
                  ? v.length
                    ? v.item(0)
                    : M(v.changedTouches, m.changedTouches)[0]
                  : m;
              return (
                h || (h = this.getChartPosition()),
                (v = l.pageX - h.left),
                (l = l.pageY - h.top),
                (v /= h.scaleX),
                (l /= h.scaleY),
                c(m, { chartX: Math.round(v), chartY: Math.round(l) })
              );
            }
            onContainerClick(m) {
              const h = this.chart,
                v = h.hoverPoint;
              m = this.normalize(m);
              const l = h.plotLeft,
                o = h.plotTop;
              h.cancelClick ||
                (v && this.inClass(m.target, "highcharts-tracker")
                  ? (f(v.series, "click", c(m, { point: v })),
                    h.hoverPoint && v.firePointEvent("click", m))
                  : (c(m, this.getCoordinates(m)),
                    h.isInsidePlot(m.chartX - l, m.chartY - o, {
                      visiblePlotOnly: !0,
                    }) && f(h, "click", m)));
            }
            onContainerMouseDown(m) {
              const h = ((m.buttons || m.button) & 1) === 1;
              (m = this.normalize(m)),
                O.isFirefox && m.button !== 0 && this.onContainerMouseMove(m),
                (typeof m.button > "u" || h) &&
                  (this.zoomOption(m),
                  h && m.preventDefault && m.preventDefault(),
                  this.dragStart(m));
            }
            onContainerMouseLeave(m) {
              const h = U[M(P.hoverChartIndex, -1)];
              (m = this.normalize(m)),
                h &&
                  m.relatedTarget &&
                  !this.inClass(m.relatedTarget, "highcharts-tooltip") &&
                  (h.pointer.reset(), (h.pointer.chartPosition = void 0));
            }
            onContainerMouseEnter(m) {
              delete this.chartPosition;
            }
            onContainerMouseMove(m) {
              const h = this.chart,
                v = h.tooltip;
              (m = this.normalize(m)),
                this.setHoverChartIndex(),
                (h.mouseIsDown === "mousedown" || this.touchSelect(m)) &&
                  this.drag(m),
                h.openMenu ||
                  (!this.inClass(m.target, "highcharts-tracker") &&
                    !h.isInsidePlot(
                      m.chartX - h.plotLeft,
                      m.chartY - h.plotTop,
                      { visiblePlotOnly: !0 }
                    )) ||
                  (v && v.shouldStickOnContact(m)) ||
                  (this.inClass(m.target, "highcharts-no-tooltip")
                    ? this.reset(!1, 0)
                    : this.runPointActions(m));
            }
            onDocumentTouchEnd(m) {
              const h = U[M(P.hoverChartIndex, -1)];
              h && h.pointer.drop(m);
            }
            onContainerTouchMove(m) {
              this.touchSelect(m)
                ? this.onContainerMouseMove(m)
                : this.touch(m);
            }
            onContainerTouchStart(m) {
              this.touchSelect(m)
                ? this.onContainerMouseDown(m)
                : (this.zoomOption(m), this.touch(m, !0));
            }
            onDocumentMouseMove(m) {
              const h = this.chart,
                v = h.tooltip,
                l = this.chartPosition;
              (m = this.normalize(m, l)),
                !l ||
                  h.isInsidePlot(m.chartX - h.plotLeft, m.chartY - h.plotTop, {
                    visiblePlotOnly: !0,
                  }) ||
                  (v && v.shouldStickOnContact(m)) ||
                  this.inClass(m.target, "highcharts-tracker") ||
                  this.reset();
            }
            onDocumentMouseUp(m) {
              const h = U[M(P.hoverChartIndex, -1)];
              h && h.pointer.drop(m);
            }
            pinch(m) {
              const h = this,
                v = h.chart,
                l = h.pinchDown,
                o = m.touches || [],
                i = o.length,
                t = h.lastValidTouch,
                e = h.hasZoom,
                s = {},
                a =
                  i === 1 &&
                  ((h.inClass(m.target, "highcharts-tracker") &&
                    v.runTrackerClick) ||
                    h.runChartClick),
                b = {};
              var r = h.chart.tooltip;
              r = i === 1 && M(r && r.options.followTouchMove, !0);
              let w = h.selectionMarker;
              1 < i ? (h.initiated = !0) : r && (h.initiated = !1),
                e &&
                  h.initiated &&
                  !a &&
                  m.cancelable !== !1 &&
                  m.preventDefault(),
                [].map.call(o, function (L) {
                  return h.normalize(L);
                }),
                m.type === "touchstart"
                  ? ([].forEach.call(o, function (L, I) {
                      l[I] = { chartX: L.chartX, chartY: L.chartY };
                    }),
                    (t.x = [l[0].chartX, l[1] && l[1].chartX]),
                    (t.y = [l[0].chartY, l[1] && l[1].chartY]),
                    v.axes.forEach(function (L) {
                      if (L.zoomEnabled) {
                        const I = v.bounds[L.horiz ? "h" : "v"],
                          V = L.minPixelPadding,
                          B = L.toPixels(
                            Math.min(M(L.options.min, L.dataMin), L.dataMin)
                          ),
                          x = L.toPixels(
                            Math.max(M(L.options.max, L.dataMax), L.dataMax)
                          ),
                          R = Math.max(B, x);
                        (I.min = Math.min(L.pos, Math.min(B, x) - V)),
                          (I.max = Math.max(L.pos + L.len, R + V));
                      }
                    }),
                    (h.res = !0))
                  : r
                  ? this.runPointActions(h.normalize(m))
                  : l.length &&
                    (f(v, "touchpan", { originalEvent: m }, () => {
                      w ||
                        (h.selectionMarker = w =
                          c({ destroy: H, touch: !0 }, v.plotBox)),
                        h.pinchTranslate(l, o, s, w, b, t),
                        (h.hasPinched = e),
                        h.scaleGroups(s, b);
                    }),
                    h.res && ((h.res = !1), this.reset(!1, 0)));
            }
            pinchTranslate(m, h, v, l, o, i) {
              this.zoomHor &&
                this.pinchTranslateDirection(!0, m, h, v, l, o, i),
                this.zoomVert &&
                  this.pinchTranslateDirection(!1, m, h, v, l, o, i);
            }
            pinchTranslateDirection(m, h, v, l, o, i, t, e) {
              const s = this.chart,
                a = m ? "x" : "y",
                b = m ? "X" : "Y",
                r = "chart" + b,
                w = m ? "width" : "height",
                L = s["plot" + (m ? "Left" : "Top")],
                I = s.inverted,
                V = s.bounds[m ? "h" : "v"],
                B = h.length === 1,
                x = h[0][r],
                R = !B && h[1][r];
              h = function () {
                typeof _ == "number" &&
                  20 < Math.abs(x - R) &&
                  (Z = e || Math.abs(E - _) / Math.abs(x - R)),
                  (X = (L - E) / Z + x),
                  (W = s["plot" + (m ? "Width" : "Height")] / Z);
              };
              let W,
                X,
                Z = e || 1,
                E = v[0][r],
                _ = !B && v[1][r],
                z;
              h(),
                (v = X),
                v < V.min
                  ? ((v = V.min), (z = !0))
                  : v + W > V.max && ((v = V.max - W), (z = !0)),
                z
                  ? ((E -= 0.8 * (E - t[a][0])),
                    typeof _ == "number" && (_ -= 0.8 * (_ - t[a][1])),
                    h())
                  : (t[a] = [E, _]),
                I || ((i[a] = X - L), (i[w] = W)),
                (i = I ? 1 / Z : Z),
                (o[w] = W),
                (o[a] = v),
                (l[I ? (m ? "scaleY" : "scaleX") : "scale" + b] = Z),
                (l["translate" + b] = i * L + (E - i * x));
            }
            reset(m, h) {
              const v = this.chart,
                l = v.hoverSeries,
                o = v.hoverPoint,
                i = v.hoverPoints,
                t = v.tooltip,
                e = t && t.shared ? i : o;
              m &&
                e &&
                C(e).forEach(function (s) {
                  s.series.isCartesian && typeof s.plotX > "u" && (m = !1);
                }),
                m
                  ? t &&
                    e &&
                    C(e).length &&
                    (t.refresh(e),
                    t.shared && i
                      ? i.forEach(function (s) {
                          s.setState(s.state, !0),
                            s.series.isCartesian &&
                              (s.series.xAxis.crosshair &&
                                s.series.xAxis.drawCrosshair(null, s),
                              s.series.yAxis.crosshair &&
                                s.series.yAxis.drawCrosshair(null, s));
                        })
                      : o &&
                        (o.setState(o.state, !0),
                        v.axes.forEach(function (s) {
                          s.crosshair &&
                            o.series[s.coll] === s &&
                            s.drawCrosshair(null, o);
                        })))
                  : (o && o.onMouseOut(),
                    i &&
                      i.forEach(function (s) {
                        s.setState();
                      }),
                    l && l.onMouseOut(),
                    t && t.hide(h),
                    this.unDocMouseMove &&
                      (this.unDocMouseMove = this.unDocMouseMove()),
                    v.axes.forEach(function (s) {
                      s.hideCrosshair();
                    }),
                    (this.hoverX = v.hoverPoints = v.hoverPoint = null));
            }
            runPointActions(m, h, v) {
              const l = this.chart,
                o = l.tooltip && l.tooltip.options.enabled ? l.tooltip : void 0,
                i = o ? o.shared : !1;
              let t = h || l.hoverPoint,
                e = (t && t.series) || l.hoverSeries;
              (h = this.getHoverData(
                t,
                e,
                l.series,
                (!m || m.type !== "touchmove") &&
                  (!!h || (e && e.directTouch && this.isDirectTouch)),
                i,
                m
              )),
                (t = h.hoverPoint),
                (e = h.hoverSeries);
              const s = h.hoverPoints;
              h =
                e && e.tooltipOptions.followPointer && !e.tooltipOptions.split;
              const a = i && e && !e.noSharedTooltip;
              if (t && (v || t !== l.hoverPoint || (o && o.isHidden))) {
                if (
                  ((l.hoverPoints || []).forEach(function (b) {
                    s.indexOf(b) === -1 && b.setState();
                  }),
                  l.hoverSeries !== e && e.onMouseOver(),
                  this.applyInactiveState(s),
                  (s || []).forEach(function (b) {
                    b.setState("hover");
                  }),
                  l.hoverPoint && l.hoverPoint.firePointEvent("mouseOut"),
                  !t.series)
                )
                  return;
                (l.hoverPoints = s),
                  (l.hoverPoint = t),
                  t.firePointEvent("mouseOver", void 0, () => {
                    o && t && o.refresh(a ? s : t, m);
                  });
              } else
                h &&
                  o &&
                  !o.isHidden &&
                  ((v = o.getAnchor([{}], m)),
                  l.isInsidePlot(v[0], v[1], { visiblePlotOnly: !0 }) &&
                    o.updatePosition({ plotX: v[0], plotY: v[1] }));
              this.unDocMouseMove ||
                ((this.unDocMouseMove = Y(
                  l.container.ownerDocument,
                  "mousemove",
                  function (b) {
                    const r = U[P.hoverChartIndex];
                    r && r.pointer.onDocumentMouseMove(b);
                  }
                )),
                this.eventsToUnbind.push(this.unDocMouseMove)),
                l.axes.forEach(function (b) {
                  const r = M((b.crosshair || {}).snap, !0);
                  let w;
                  r &&
                    (((w = l.hoverPoint) && w.series[b.coll] === b) ||
                      (w = p(s, (L) => L.series && L.series[b.coll] === b))),
                    w || !r ? b.drawCrosshair(m, w) : b.hideCrosshair();
                });
            }
            scaleGroups(m, h) {
              const v = this.chart;
              v.series.forEach(function (l) {
                const o = m || l.getPlotBox();
                l.group &&
                  ((l.xAxis && l.xAxis.zoomEnabled) || v.mapView) &&
                  (l.group.attr(o),
                  l.markerGroup &&
                    (l.markerGroup.attr(o),
                    l.markerGroup.clip(h ? v.clipRect : null)),
                  l.dataLabelsGroup && l.dataLabelsGroup.attr(o));
              }),
                v.clipRect.attr(h || v.clipBox);
            }
            setDOMEvents() {
              const m = this.chart.container,
                h = m.ownerDocument;
              (m.onmousedown = this.onContainerMouseDown.bind(this)),
                (m.onmousemove = this.onContainerMouseMove.bind(this)),
                (m.onclick = this.onContainerClick.bind(this)),
                this.eventsToUnbind.push(
                  Y(m, "mouseenter", this.onContainerMouseEnter.bind(this))
                ),
                this.eventsToUnbind.push(
                  Y(m, "mouseleave", this.onContainerMouseLeave.bind(this))
                ),
                P.unbindDocumentMouseUp ||
                  (P.unbindDocumentMouseUp = Y(
                    h,
                    "mouseup",
                    this.onDocumentMouseUp.bind(this)
                  ));
              let v = this.chart.renderTo.parentElement;
              for (; v && v.tagName !== "BODY"; )
                this.eventsToUnbind.push(
                  Y(v, "scroll", () => {
                    delete this.chartPosition;
                  })
                ),
                  (v = v.parentElement);
              O.hasTouch &&
                (this.eventsToUnbind.push(
                  Y(m, "touchstart", this.onContainerTouchStart.bind(this), {
                    passive: !1,
                  })
                ),
                this.eventsToUnbind.push(
                  Y(m, "touchmove", this.onContainerTouchMove.bind(this), {
                    passive: !1,
                  })
                ),
                P.unbindDocumentTouchEnd ||
                  (P.unbindDocumentTouchEnd = Y(
                    h,
                    "touchend",
                    this.onDocumentTouchEnd.bind(this),
                    { passive: !1 }
                  )));
            }
            setHoverChartIndex() {
              const m = this.chart,
                h = O.charts[M(P.hoverChartIndex, -1)];
              h &&
                h !== m &&
                h.pointer.onContainerMouseLeave({ relatedTarget: m.container }),
                (h && h.mouseIsDown) || (P.hoverChartIndex = m.index);
            }
            touch(m, h) {
              const v = this.chart;
              let l;
              this.setHoverChartIndex(),
                m.touches.length === 1
                  ? ((m = this.normalize(m)),
                    v.isInsidePlot(
                      m.chartX - v.plotLeft,
                      m.chartY - v.plotTop,
                      { visiblePlotOnly: !0 }
                    ) && !v.openMenu
                      ? (h && this.runPointActions(m),
                        m.type === "touchmove" &&
                          ((h = this.pinchDown),
                          (l = h[0]
                            ? 4 <=
                              Math.sqrt(
                                Math.pow(h[0].chartX - m.chartX, 2) +
                                  Math.pow(h[0].chartY - m.chartY, 2)
                              )
                            : !1)),
                        M(l, !0) && this.pinch(m))
                      : h && this.reset())
                  : m.touches.length === 2 && this.pinch(m);
            }
            touchSelect(m) {
              return !(
                !this.chart.zooming.singleTouch ||
                !m.touches ||
                m.touches.length !== 1
              );
            }
            zoomOption(m) {
              const h = this.chart,
                v = h.inverted;
              var l = h.zooming.type || "";
              /touch/.test(m.type) && (l = M(h.zooming.pinchType, l)),
                (this.zoomX = m = /x/.test(l)),
                (this.zoomY = l = /y/.test(l)),
                (this.zoomHor = (m && !v) || (l && v)),
                (this.zoomVert = (l && !v) || (m && v)),
                (this.hasZoom = m || l);
            }
          }
          return (
            (function (j) {
              const m = [],
                h = [];
              (j.compose = function (v) {
                F.pushUnique(h, v) &&
                  Y(v, "beforeRender", function () {
                    this.pointer = new j(this, this.options);
                  });
              }),
                (j.dissolve = function () {
                  for (let v = 0, l = m.length; v < l; ++v) m[v]();
                  m.length = 0;
                });
            })(P || (P = {})),
            P
          );
        }
      ),
      T(
        y,
        "Core/Legend/Legend.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Templating.js"],
          y["Core/Globals.js"],
          y["Core/Series/Point.js"],
          y["Core/Renderer/RendererUtilities.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H) {
          const { animObject: Y, setAnimation: S } = A,
            { format: N } = O,
            { marginNames: D } = F,
            { distribute: c } = U,
            {
              addEvent: p,
              createElement: f,
              css: u,
              defined: n,
              discardElement: d,
              find: g,
              fireEvent: M,
              isNumber: C,
              merge: P,
              pick: j,
              relativeLength: m,
              stableSort: h,
              syncTimeout: v,
            } = H;
          class l {
            constructor(i, t) {
              (this.allItems = []),
                (this.contentGroup = this.box = void 0),
                (this.display = !1),
                (this.group = void 0),
                (this.offsetWidth =
                  this.maxLegendWidth =
                  this.maxItemWidth =
                  this.legendWidth =
                  this.legendHeight =
                  this.lastLineHeight =
                  this.lastItemY =
                  this.itemY =
                  this.itemX =
                  this.itemMarginTop =
                  this.itemMarginBottom =
                  this.itemHeight =
                  this.initialItemY =
                    0),
                (this.options = void 0),
                (this.padding = 0),
                (this.pages = []),
                (this.proximate = !1),
                (this.scrollGroup = void 0),
                (this.widthOption =
                  this.totalItemWidth =
                  this.titleHeight =
                  this.symbolWidth =
                  this.symbolHeight =
                    0),
                (this.chart = i),
                this.init(i, t);
            }
            init(i, t) {
              (this.chart = i),
                this.setOptions(t),
                t.enabled &&
                  (this.render(),
                  p(this.chart, "endResize", function () {
                    this.legend.positionCheckboxes();
                  }),
                  p(this.chart, "render", () => {
                    this.proximate &&
                      (this.proximatePositions(), this.positionItems());
                  }));
            }
            setOptions(i) {
              const t = j(i.padding, 8);
              (this.options = i),
                this.chart.styledMode ||
                  ((this.itemStyle = i.itemStyle),
                  (this.itemHiddenStyle = P(
                    this.itemStyle,
                    i.itemHiddenStyle
                  ))),
                (this.itemMarginTop = i.itemMarginTop),
                (this.itemMarginBottom = i.itemMarginBottom),
                (this.padding = t),
                (this.initialItemY = t - 5),
                (this.symbolWidth = j(i.symbolWidth, 16)),
                (this.pages = []),
                (this.proximate =
                  i.layout === "proximate" && !this.chart.inverted),
                (this.baseline = void 0);
            }
            update(i, t) {
              const e = this.chart;
              this.setOptions(P(!0, this.options, i)),
                this.destroy(),
                (e.isDirtyLegend = e.isDirtyBox = !0),
                j(t, !0) && e.redraw(),
                M(this, "afterUpdate");
            }
            colorizeItem(i, t) {
              const {
                group: e,
                label: s,
                line: a,
                symbol: b,
              } = i.legendItem || {};
              if (
                (e &&
                  e[t ? "removeClass" : "addClass"](
                    "highcharts-legend-item-hidden"
                  ),
                !this.chart.styledMode)
              ) {
                const { itemHiddenStyle: r } = this,
                  w = r.color,
                  L = (t && i.color) || w,
                  I = i.options && i.options.marker;
                let V = { fill: L };
                s == null || s.css(P(t ? this.itemStyle : r)),
                  a == null || a.attr({ stroke: L }),
                  b &&
                    (I &&
                      b.isMarker &&
                      ((V = i.pointAttribs()), t || (V.stroke = V.fill = w)),
                    b.attr(V));
              }
              M(this, "afterColorizeItem", { item: i, visible: t });
            }
            positionItems() {
              this.allItems.forEach(this.positionItem, this),
                this.chart.isResizing || this.positionCheckboxes();
            }
            positionItem(i) {
              const { group: t, x: e = 0, y: s = 0 } = i.legendItem || {};
              var a = this.options,
                b = a.symbolPadding;
              const r = !a.rtl;
              (a = i.checkbox),
                t &&
                  t.element &&
                  ((b = {
                    translateX: r ? e : this.legendWidth - e - 2 * b - 4,
                    translateY: s,
                  }),
                  t[n(t.translateY) ? "animate" : "attr"](b, void 0, () => {
                    M(this, "afterPositionItem", { item: i });
                  })),
                a && ((a.x = e), (a.y = s));
            }
            destroyItem(i) {
              const t = i.checkbox,
                e = i.legendItem || {};
              for (const s of ["group", "label", "line", "symbol"])
                e[s] && (e[s] = e[s].destroy());
              t && d(t), (i.legendItem = void 0);
            }
            destroy() {
              for (const i of this.getAllItems()) this.destroyItem(i);
              for (const i of "clipRect up down pager nav box title group".split(
                " "
              ))
                this[i] && (this[i] = this[i].destroy());
              this.display = null;
            }
            positionCheckboxes() {
              const i = this.group && this.group.alignAttr,
                t = this.clipHeight || this.legendHeight,
                e = this.titleHeight;
              let s;
              i &&
                ((s = i.translateY),
                this.allItems.forEach(function (a) {
                  const b = a.checkbox;
                  let r;
                  b &&
                    ((r = s + e + b.y + (this.scrollOffset || 0) + 3),
                    u(b, {
                      left: i.translateX + a.checkboxOffset + b.x - 20 + "px",
                      top: r + "px",
                      display:
                        this.proximate || (r > s - 6 && r < s + t - 6)
                          ? ""
                          : "none",
                    }));
                }, this));
            }
            renderTitle() {
              var i = this.options;
              const t = this.padding,
                e = i.title;
              let s = 0;
              e.text &&
                (this.title ||
                  ((this.title = this.chart.renderer
                    .label(
                      e.text,
                      t - 3,
                      t - 4,
                      void 0,
                      void 0,
                      void 0,
                      i.useHTML,
                      void 0,
                      "legend-title"
                    )
                    .attr({ zIndex: 1 })),
                  this.chart.styledMode || this.title.css(e.style),
                  this.title.add(this.group)),
                e.width ||
                  this.title.css({ width: this.maxLegendWidth + "px" }),
                (i = this.title.getBBox()),
                (s = i.height),
                (this.offsetWidth = i.width),
                this.contentGroup.attr({ translateY: s })),
                (this.titleHeight = s);
            }
            setText(i) {
              const t = this.options;
              i.legendItem.label.attr({
                text: t.labelFormat
                  ? N(t.labelFormat, i, this.chart)
                  : t.labelFormatter.call(i),
              });
            }
            renderItem(i) {
              const t = (i.legendItem = i.legendItem || {});
              var e = this.chart,
                s = e.renderer;
              const a = this.options,
                b = this.symbolWidth,
                r = a.symbolPadding || 0,
                w = this.itemStyle,
                L = this.itemHiddenStyle,
                I = a.layout === "horizontal" ? j(a.itemDistance, 20) : 0,
                V = !a.rtl,
                B = !i.series,
                x = !B && i.series.drawLegendSymbol ? i.series : i;
              var R = x.options;
              const W = this.createCheckboxForItem && R && R.showCheckbox,
                X = a.useHTML,
                Z = i.options.className;
              let E = t.label;
              (R = b + r + I + (W ? 20 : 0)),
                E ||
                  ((t.group = s
                    .g("legend-item")
                    .addClass(
                      "highcharts-" +
                        x.type +
                        "-series highcharts-color-" +
                        i.colorIndex +
                        (Z ? " " + Z : "") +
                        (B ? " highcharts-series-" + i.index : "")
                    )
                    .attr({ zIndex: 1 })
                    .add(this.scrollGroup)),
                  (t.label = E =
                    s.text("", V ? b + r : -r, this.baseline || 0, X)),
                  e.styledMode || E.css(P(i.visible ? w : L)),
                  E.attr({ align: V ? "left" : "right", zIndex: 2 }).add(
                    t.group
                  ),
                  this.baseline ||
                    ((this.fontMetrics = s.fontMetrics(E)),
                    (this.baseline =
                      this.fontMetrics.f + 3 + this.itemMarginTop),
                    E.attr("y", this.baseline),
                    (this.symbolHeight = j(a.symbolHeight, this.fontMetrics.f)),
                    a.squareSymbol &&
                      ((this.symbolWidth = j(
                        a.symbolWidth,
                        Math.max(this.symbolHeight, 16)
                      )),
                      (R = this.symbolWidth + r + I + (W ? 20 : 0)),
                      V && E.attr("x", this.symbolWidth + r))),
                  x.drawLegendSymbol(this, i),
                  this.setItemEvents && this.setItemEvents(i, E, X)),
                W &&
                  !i.checkbox &&
                  this.createCheckboxForItem &&
                  this.createCheckboxForItem(i),
                this.colorizeItem(i, i.visible),
                (!e.styledMode && w.width) ||
                  E.css({
                    width:
                      (a.itemWidth || this.widthOption || e.spacingBox.width) -
                      R +
                      "px",
                  }),
                this.setText(i),
                (e = E.getBBox()),
                (s = (this.fontMetrics && this.fontMetrics.h) || 0),
                (i.itemWidth = i.checkboxOffset =
                  a.itemWidth || t.labelWidth || e.width + R),
                (this.maxItemWidth = Math.max(this.maxItemWidth, i.itemWidth)),
                (this.totalItemWidth += i.itemWidth),
                (this.itemHeight = i.itemHeight =
                  Math.round(
                    t.labelHeight || (e.height > 1.5 * s ? e.height : s)
                  ));
            }
            layoutItem(i) {
              var t = this.options;
              const e = this.padding,
                s = t.layout === "horizontal",
                a = i.itemHeight,
                b = this.itemMarginBottom,
                r = this.itemMarginTop,
                w = s ? j(t.itemDistance, 20) : 0,
                L = this.maxLegendWidth;
              t =
                t.alignColumns && this.totalItemWidth > L
                  ? this.maxItemWidth
                  : i.itemWidth;
              const I = i.legendItem || {};
              s &&
                this.itemX - e + t > L &&
                ((this.itemX = e),
                this.lastLineHeight &&
                  (this.itemY += r + this.lastLineHeight + b),
                (this.lastLineHeight = 0)),
                (this.lastItemY = r + this.itemY + b),
                (this.lastLineHeight = Math.max(a, this.lastLineHeight)),
                (I.x = this.itemX),
                (I.y = this.itemY),
                s
                  ? (this.itemX += t)
                  : ((this.itemY += r + a + b), (this.lastLineHeight = a)),
                (this.offsetWidth =
                  this.widthOption ||
                  Math.max(
                    (s ? this.itemX - e - (i.checkbox ? 0 : w) : t) + e,
                    this.offsetWidth
                  ));
            }
            getAllItems() {
              let i = [];
              return (
                this.chart.series.forEach(function (t) {
                  const e = t && t.options;
                  t &&
                    j(e.showInLegend, n(e.linkedTo) ? !1 : void 0, !0) &&
                    (i = i.concat(
                      (t.legendItem || {}).labels ||
                        (e.legendType === "point" ? t.data : t)
                    ));
                }),
                M(this, "afterGetAllItems", { allItems: i }),
                i
              );
            }
            getAlignment() {
              const i = this.options;
              return this.proximate
                ? i.align.charAt(0) + "tv"
                : i.floating
                ? ""
                : i.align.charAt(0) +
                  i.verticalAlign.charAt(0) +
                  i.layout.charAt(0);
            }
            adjustMargins(i, t) {
              const e = this.chart,
                s = this.options,
                a = this.getAlignment();
              a &&
                [
                  /(lth|ct|rth)/,
                  /(rtv|rm|rbv)/,
                  /(rbh|cb|lbh)/,
                  /(lbv|lm|ltv)/,
                ].forEach(function (b, r) {
                  b.test(a) &&
                    !n(i[r]) &&
                    (e[D[r]] = Math.max(
                      e[D[r]],
                      e.legend[(r + 1) % 2 ? "legendHeight" : "legendWidth"] +
                        [1, -1, -1, 1][r] * s[r % 2 ? "x" : "y"] +
                        j(s.margin, 12) +
                        t[r] +
                        (e.titleOffset[r] || 0)
                    ));
                });
            }
            proximatePositions() {
              const i = this.chart,
                t = [],
                e = this.options.align === "left";
              this.allItems.forEach(function (a) {
                var b,
                  r = e;
                let w;
                a.yAxis &&
                  (a.xAxis.options.reversed && (r = !r),
                  a.points &&
                    (b = g(
                      r ? a.points : a.points.slice(0).reverse(),
                      function (L) {
                        return C(L.plotY);
                      }
                    )),
                  (r =
                    this.itemMarginTop +
                    a.legendItem.label.getBBox().height +
                    this.itemMarginBottom),
                  (w = a.yAxis.top - i.plotTop),
                  a.visible
                    ? ((b = b ? b.plotY : a.yAxis.height), (b += w - 0.3 * r))
                    : (b = w + a.yAxis.height),
                  t.push({ target: b, size: r, item: a }));
              }, this);
              let s;
              for (const a of c(t, i.plotHeight))
                (s = a.item.legendItem || {}),
                  C(a.pos) && (s.y = i.plotTop - i.spacing[0] + a.pos);
            }
            render() {
              const i = this.chart,
                t = i.renderer,
                e = this.options,
                s = this.padding;
              var a = this.getAllItems();
              let b,
                r = this.group,
                w = this.box;
              (this.itemX = s),
                (this.itemY = this.initialItemY),
                (this.lastItemY = this.offsetWidth = 0),
                (this.widthOption = m(e.width, i.spacingBox.width - s));
              var L = i.spacingBox.width - 2 * s - e.x;
              -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) &&
                (L /= 2),
                (this.maxLegendWidth = this.widthOption || L),
                r ||
                  ((this.group = r =
                    t
                      .g("legend")
                      .addClass(e.className || "")
                      .attr({ zIndex: 7 })
                      .add()),
                  (this.contentGroup = t.g().attr({ zIndex: 1 }).add(r)),
                  (this.scrollGroup = t.g().add(this.contentGroup))),
                this.renderTitle(),
                h(
                  a,
                  (I, V) =>
                    ((I.options && I.options.legendIndex) || 0) -
                    ((V.options && V.options.legendIndex) || 0)
                ),
                e.reversed && a.reverse(),
                (this.allItems = a),
                (this.display = L = !!a.length),
                (this.itemHeight =
                  this.totalItemWidth =
                  this.maxItemWidth =
                  this.lastLineHeight =
                    0),
                a.forEach(this.renderItem, this),
                a.forEach(this.layoutItem, this),
                (a = (this.widthOption || this.offsetWidth) + s),
                (b = this.lastItemY + this.lastLineHeight + this.titleHeight),
                (b = this.handleOverflow(b)),
                (b += s),
                w ||
                  (this.box = w =
                    t
                      .rect()
                      .addClass("highcharts-legend-box")
                      .attr({ r: e.borderRadius })
                      .add(r)),
                i.styledMode ||
                  w
                    .attr({
                      stroke: e.borderColor,
                      "stroke-width": e.borderWidth || 0,
                      fill: e.backgroundColor || "none",
                    })
                    .shadow(e.shadow),
                0 < a &&
                  0 < b &&
                  w[w.placed ? "animate" : "attr"](
                    w.crisp.call(
                      {},
                      { x: 0, y: 0, width: a, height: b },
                      w.strokeWidth()
                    )
                  ),
                r[L ? "show" : "hide"](),
                i.styledMode && r.getStyle("display") === "none" && (a = b = 0),
                (this.legendWidth = a),
                (this.legendHeight = b),
                L && this.align(),
                this.proximate || this.positionItems(),
                M(this, "afterRender");
            }
            align(i = this.chart.spacingBox) {
              const t = this.chart,
                e = this.options;
              let s = i.y;
              /(lth|ct|rth)/.test(this.getAlignment()) && 0 < t.titleOffset[0]
                ? (s += t.titleOffset[0])
                : /(lbh|cb|rbh)/.test(this.getAlignment()) &&
                  0 < t.titleOffset[2] &&
                  (s -= t.titleOffset[2]),
                s !== i.y && (i = P(i, { y: s })),
                t.hasRendered || (this.group.placed = !1),
                this.group.align(
                  P(e, {
                    width: this.legendWidth,
                    height: this.legendHeight,
                    verticalAlign: this.proximate ? "top" : e.verticalAlign,
                  }),
                  !0,
                  i
                );
            }
            handleOverflow(i) {
              const t = this,
                e = this.chart,
                s = e.renderer,
                a = this.options;
              var b = a.y;
              const r = a.verticalAlign === "top",
                w = this.padding,
                L = a.maxHeight,
                I = a.navigation,
                V = j(I.animation, !0),
                B = I.arrowSize || 12,
                x = this.pages,
                R = this.allItems,
                W = function (tt) {
                  typeof tt == "number"
                    ? J.attr({ height: tt })
                    : J && ((t.clipRect = J.destroy()), t.contentGroup.clip()),
                    t.contentGroup.div &&
                      (t.contentGroup.div.style.clip = tt
                        ? "rect(" + w + "px,9999px," + (w + tt) + "px,0)"
                        : "auto");
                },
                X = function (tt) {
                  return (
                    (t[tt] = s
                      .circle(0, 0, 1.3 * B)
                      .translate(B / 2, B / 2)
                      .add(z)),
                    e.styledMode || t[tt].attr("fill", "rgba(0,0,0,0.0001)"),
                    t[tt]
                  );
                };
              let Z, E, _;
              b = e.spacingBox.height + (r ? -b : b) - w;
              let z = this.nav,
                J = this.clipRect;
              return (
                a.layout !== "horizontal" ||
                  a.verticalAlign === "middle" ||
                  a.floating ||
                  (b /= 2),
                L && (b = Math.min(b, L)),
                (x.length = 0),
                i && 0 < b && i > b && I.enabled !== !1
                  ? ((this.clipHeight = Z =
                      Math.max(b - 20 - this.titleHeight - w, 0)),
                    (this.currentPage = j(this.currentPage, 1)),
                    (this.fullHeight = i),
                    R.forEach((tt, $) => {
                      (_ = tt.legendItem || {}), (tt = _.y || 0);
                      const it = Math.round(_.label.getBBox().height);
                      let nt = x.length;
                      (!nt ||
                        (tt - x[nt - 1] > Z && (E || tt) !== x[nt - 1])) &&
                        (x.push(E || tt), nt++),
                        (_.pageIx = nt - 1),
                        E && ((R[$ - 1].legendItem || {}).pageIx = nt - 1),
                        $ === R.length - 1 &&
                          tt + it - x[nt - 1] > Z &&
                          tt > x[nt - 1] &&
                          (x.push(tt), (_.pageIx = nt)),
                        tt !== E && (E = tt);
                    }),
                    J ||
                      ((J = t.clipRect = s.clipRect(0, w - 2, 9999, 0)),
                      t.contentGroup.clip(J)),
                    W(Z),
                    z ||
                      ((this.nav = z =
                        s.g().attr({ zIndex: 1 }).add(this.group)),
                      (this.up = s.symbol("triangle", 0, 0, B, B).add(z)),
                      X("upTracker").on("click", function () {
                        t.scroll(-1, V);
                      }),
                      (this.pager = s
                        .text("", 15, 10)
                        .addClass("highcharts-legend-navigation")),
                      !e.styledMode && I.style && this.pager.css(I.style),
                      this.pager.add(z),
                      (this.down = s
                        .symbol("triangle-down", 0, 0, B, B)
                        .add(z)),
                      X("downTracker").on("click", function () {
                        t.scroll(1, V);
                      })),
                    t.scroll(0),
                    (i = b))
                  : z &&
                    (W(),
                    (this.nav = z.destroy()),
                    this.scrollGroup.attr({ translateY: 1 }),
                    (this.clipHeight = 0)),
                i
              );
            }
            scroll(i, t) {
              const e = this.chart,
                s = this.pages,
                a = s.length,
                b = this.clipHeight,
                r = this.options.navigation,
                w = this.pager,
                L = this.padding;
              let I = this.currentPage + i;
              I > a && (I = a),
                0 < I &&
                  (typeof t < "u" && S(t, e),
                  this.nav.attr({
                    translateX: L,
                    translateY: b + this.padding + 7 + this.titleHeight,
                    visibility: "inherit",
                  }),
                  [this.up, this.upTracker].forEach(function (V) {
                    V.attr({
                      class:
                        I === 1
                          ? "highcharts-legend-nav-inactive"
                          : "highcharts-legend-nav-active",
                    });
                  }),
                  w.attr({ text: I + "/" + a }),
                  [this.down, this.downTracker].forEach(function (V) {
                    V.attr({
                      x: 18 + this.pager.getBBox().width,
                      class:
                        I === a
                          ? "highcharts-legend-nav-inactive"
                          : "highcharts-legend-nav-active",
                    });
                  }, this),
                  e.styledMode ||
                    (this.up.attr({
                      fill: I === 1 ? r.inactiveColor : r.activeColor,
                    }),
                    this.upTracker.css({
                      cursor: I === 1 ? "default" : "pointer",
                    }),
                    this.down.attr({
                      fill: I === a ? r.inactiveColor : r.activeColor,
                    }),
                    this.downTracker.css({
                      cursor: I === a ? "default" : "pointer",
                    })),
                  (this.scrollOffset = -s[I - 1] + this.initialItemY),
                  this.scrollGroup.animate({ translateY: this.scrollOffset }),
                  (this.currentPage = I),
                  this.positionCheckboxes(),
                  (i = Y(j(t, e.renderer.globalAnimation, !0))),
                  v(() => {
                    M(this, "afterScroll", { currentPage: I });
                  }, i.duration));
            }
            setItemEvents(i, t, e) {
              const s = this,
                a = i.legendItem || {},
                b = s.chart.renderer.boxWrapper,
                r = i instanceof G,
                w = "highcharts-legend-" + (r ? "point" : "series") + "-active",
                L = s.chart.styledMode;
              e = e ? [t, a.symbol] : [a.group];
              const I = (V) => {
                s.allItems.forEach((B) => {
                  i !== B &&
                    [B].concat(B.linkedSeries || []).forEach((x) => {
                      x.setState(V, !r);
                    });
                });
              };
              for (const V of e)
                V &&
                  V.on("mouseover", function () {
                    i.visible && I("inactive"),
                      i.setState("hover"),
                      i.visible && b.addClass(w),
                      L || t.css(s.options.itemHoverStyle);
                  })
                    .on("mouseout", function () {
                      s.chart.styledMode ||
                        t.css(P(i.visible ? s.itemStyle : s.itemHiddenStyle)),
                        I(""),
                        b.removeClass(w),
                        i.setState();
                    })
                    .on("click", function (B) {
                      const x = function () {
                        i.setVisible && i.setVisible(),
                          I(i.visible ? "inactive" : "");
                      };
                      b.removeClass(w),
                        (B = { browserEvent: B }),
                        i.firePointEvent
                          ? i.firePointEvent("legendItemClick", B, x)
                          : M(i, "legendItemClick", B, x);
                    });
            }
            createCheckboxForItem(i) {
              (i.checkbox = f(
                "input",
                {
                  type: "checkbox",
                  className: "highcharts-legend-checkbox",
                  checked: i.selected,
                  defaultChecked: i.selected,
                },
                this.options.itemCheckboxStyle,
                this.chart.container
              )),
                p(i.checkbox, "click", function (t) {
                  M(
                    i.series || i,
                    "checkboxClick",
                    { checked: t.target.checked, item: i },
                    function () {
                      i.select();
                    }
                  );
                });
            }
          }
          return (
            (function (o) {
              const i = [];
              o.compose = function (t) {
                H.pushUnique(i, t) &&
                  p(t, "beforeMargins", function () {
                    this.legend = new o(this, this.options.legend);
                  });
              };
            })(l || (l = {})),
            l
          );
        }
      ),
      T(
        y,
        "Core/Legend/LegendSymbol.js",
        [y["Core/Utilities.js"]],
        function (A) {
          const { extend: O, merge: F, pick: G } = A;
          var U;
          return (
            (function (H) {
              (H.lineMarker = function (Y, S) {
                S = this.legendItem = this.legendItem || {};
                var N = this.options;
                const D = Y.symbolWidth,
                  c = Y.symbolHeight,
                  p = c / 2,
                  f = this.chart.renderer,
                  u = S.group;
                Y = Y.baseline - Math.round(0.3 * Y.fontMetrics.b);
                let n = {},
                  d = N.marker,
                  g = 0;
                this.chart.styledMode ||
                  ((n = { "stroke-width": Math.min(N.lineWidth || 0, 24) }),
                  N.dashStyle
                    ? (n.dashstyle = N.dashStyle)
                    : N.linecap !== "square" &&
                      (n["stroke-linecap"] = "round")),
                  (S.line = f
                    .path()
                    .addClass("highcharts-graph")
                    .attr(n)
                    .add(u)),
                  n["stroke-linecap"] &&
                    (g = Math.min(S.line.strokeWidth(), D) / 2),
                  D &&
                    S.line.attr({
                      d: [
                        ["M", g, Y],
                        ["L", D - g, Y],
                      ],
                    }),
                  d &&
                    d.enabled !== !1 &&
                    D &&
                    ((N = Math.min(G(d.radius, p), p)),
                    this.symbol.indexOf("url") === 0 &&
                      ((d = F(d, { width: c, height: c })), (N = 0)),
                    (S.symbol = S =
                      f
                        .symbol(
                          this.symbol,
                          D / 2 - N,
                          Y - N,
                          2 * N,
                          2 * N,
                          O({ context: "legend" }, d)
                        )
                        .addClass("highcharts-point")
                        .add(u)),
                    (S.isMarker = !0));
              }),
                (H.rectangle = function (Y, S) {
                  S = S.legendItem || {};
                  const N = Y.symbolHeight,
                    D = Y.options.squareSymbol;
                  S.symbol = this.chart.renderer
                    .rect(
                      D ? (Y.symbolWidth - N) / 2 : 0,
                      Y.baseline - N + 1,
                      D ? N : Y.symbolWidth,
                      N,
                      G(Y.options.symbolRadius, N / 2)
                    )
                    .addClass("highcharts-point")
                    .attr({ zIndex: 3 })
                    .add(S.group);
                });
            })(U || (U = {})),
            U
          );
        }
      ),
      T(y, "Core/Series/SeriesDefaults.js", [], function () {
        return {
          lineWidth: 1,
          allowPointSelect: !1,
          crisp: !0,
          showCheckbox: !1,
          animation: { duration: 1e3 },
          enableMouseTracking: !0,
          events: {},
          marker: {
            enabledThreshold: 2,
            lineColor: "#ffffff",
            lineWidth: 0,
            radius: 4,
            states: {
              normal: { animation: !0 },
              hover: {
                animation: { duration: 150 },
                enabled: !0,
                radiusPlus: 2,
                lineWidthPlus: 1,
              },
              select: {
                fillColor: "#cccccc",
                lineColor: "#000000",
                lineWidth: 2,
              },
            },
          },
          point: { events: {} },
          dataLabels: {
            animation: {},
            align: "center",
            borderWidth: 0,
            defer: !0,
            formatter: function () {
              const { numberFormatter: A } = this.series.chart;
              return typeof this.y != "number" ? "" : A(this.y, -1);
            },
            padding: 5,
            style: {
              fontSize: "0.7em",
              fontWeight: "bold",
              color: "contrast",
              textOutline: "1px contrast",
            },
            verticalAlign: "bottom",
            x: 0,
            y: 0,
          },
          cropThreshold: 300,
          opacity: 1,
          pointRange: 0,
          softThreshold: !0,
          states: {
            normal: { animation: !0 },
            hover: {
              animation: { duration: 150 },
              lineWidthPlus: 1,
              marker: {},
              halo: { size: 10, opacity: 0.25 },
            },
            select: { animation: { duration: 0 } },
            inactive: { animation: { duration: 150 }, opacity: 0.2 },
          },
          stickyTracking: !0,
          turboThreshold: 1e3,
          findNearestPointBy: "x",
        };
      }),
      T(
        y,
        "Core/Series/SeriesRegistry.js",
        [
          y["Core/Globals.js"],
          y["Core/Defaults.js"],
          y["Core/Series/Point.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          const { defaultOptions: U } = O,
            { extendClass: H, merge: Y } = G;
          var S;
          return (
            (function (N) {
              function D(c, p) {
                const f = U.plotOptions || {},
                  u = p.defaultOptions,
                  n = p.prototype;
                (n.type = c),
                  n.pointClass || (n.pointClass = F),
                  u && (f[c] = u),
                  (N.seriesTypes[c] = p);
              }
              (N.seriesTypes = A.seriesTypes),
                (N.registerSeriesType = D),
                (N.seriesType = function (c, p, f, u, n) {
                  const d = U.plotOptions || {};
                  return (
                    (p = p || ""),
                    (d[c] = Y(d[p], f)),
                    D(c, H(N.seriesTypes[p] || function () {}, u)),
                    (N.seriesTypes[c].prototype.type = c),
                    n && (N.seriesTypes[c].prototype.pointClass = H(F, n)),
                    N.seriesTypes[c]
                  );
                });
            })(S || (S = {})),
            S
          );
        }
      ),
      T(
        y,
        "Core/Series/Series.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Defaults.js"],
          y["Core/Foundation.js"],
          y["Core/Globals.js"],
          y["Core/Legend/LegendSymbol.js"],
          y["Core/Series/Point.js"],
          y["Core/Series/SeriesDefaults.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y, S, N, D) {
          const { animObject: c, setAnimation: p } = A,
            { defaultOptions: f } = O,
            { registerEventOptions: u } = F,
            { hasTouch: n, svg: d, win: g } = G,
            { seriesTypes: M } = S,
            {
              arrayMax: C,
              arrayMin: P,
              clamp: j,
              correctFloat: m,
              defined: h,
              diffObjects: v,
              erase: l,
              error: o,
              extend: i,
              find: t,
              fireEvent: e,
              getClosestDistance: s,
              getNestedProperty: a,
              insertItem: b,
              isArray: r,
              isNumber: w,
              isString: L,
              merge: I,
              objectEach: V,
              pick: B,
              removeEvent: x,
              splat: R,
              syncTimeout: W,
            } = D;
          class X {
            constructor() {
              this.zones =
                this.yAxis =
                this.xAxis =
                this.userOptions =
                this.tooltipOptions =
                this.processedYData =
                this.processedXData =
                this.points =
                this.options =
                this.linkedSeries =
                this.index =
                this.eventsToUnbind =
                this.eventOptions =
                this.data =
                this.chart =
                this._i =
                  void 0;
            }
            init(E, _) {
              e(this, "init", { options: _ });
              const z = this,
                J = E.series;
              (this.eventsToUnbind = []),
                (z.chart = E),
                (z.options = z.setOptions(_)),
                (_ = z.options),
                (z.linkedSeries = []),
                z.bindAxes(),
                i(z, {
                  name: _.name,
                  state: "",
                  visible: _.visible !== !1,
                  selected: _.selected === !0,
                }),
                u(this, _);
              const tt = _.events;
              ((tt && tt.click) ||
                (_.point && _.point.events && _.point.events.click) ||
                _.allowPointSelect) &&
                (E.runTrackerClick = !0),
                z.getColor(),
                z.getSymbol(),
                z.parallelArrays.forEach(function (it) {
                  z[it + "Data"] || (z[it + "Data"] = []);
                }),
                z.isCartesian && (E.hasCartesianSeries = !0);
              let $;
              J.length && ($ = J[J.length - 1]),
                (z._i = B($ && $._i, -1) + 1),
                (z.opacity = z.options.opacity),
                E.orderItems("series", b(this, J)),
                _.dataSorting && _.dataSorting.enabled
                  ? z.setDataSortingOptions()
                  : z.points || z.data || z.setData(_.data, !1),
                e(this, "afterInit");
            }
            is(E) {
              return M[E] && this instanceof M[E];
            }
            bindAxes() {
              const E = this,
                _ = E.options,
                z = E.chart;
              let J;
              e(this, "bindAxes", null, function () {
                (E.axisTypes || []).forEach(function (tt) {
                  z[tt].forEach(function ($) {
                    (J = $.options),
                      (B(_[tt], 0) === $.index ||
                        (typeof _[tt] < "u" && _[tt] === J.id)) &&
                        (b(E, $.series), (E[tt] = $), ($.isDirty = !0));
                  }),
                    E[tt] || E.optionalAxis === tt || o(18, !0, z);
                });
              }),
                e(this, "afterBindAxes");
            }
            updateParallelArrays(E, _, z) {
              const J = E.series,
                tt = w(_)
                  ? function ($) {
                      const it = $ === "y" && J.toYData ? J.toYData(E) : E[$];
                      J[$ + "Data"][_] = it;
                    }
                  : function ($) {
                      Array.prototype[_].apply(J[$ + "Data"], z);
                    };
              J.parallelArrays.forEach(tt);
            }
            hasData() {
              return (
                (this.visible &&
                  typeof this.dataMax < "u" &&
                  typeof this.dataMin < "u") ||
                (this.visible && this.yData && 0 < this.yData.length)
              );
            }
            autoIncrement(E) {
              var _ = this.options;
              const z = _.pointIntervalUnit,
                J = _.relativeXValue,
                tt = this.chart.time;
              let $ = this.xIncrement,
                it;
              return (
                ($ = B($, _.pointStart, 0)),
                (this.pointInterval = it =
                  B(this.pointInterval, _.pointInterval, 1)),
                J && w(E) && (it *= E),
                z &&
                  ((_ = new tt.Date($)),
                  z === "day"
                    ? tt.set("Date", _, tt.get("Date", _) + it)
                    : z === "month"
                    ? tt.set("Month", _, tt.get("Month", _) + it)
                    : z === "year" &&
                      tt.set("FullYear", _, tt.get("FullYear", _) + it),
                  (it = _.getTime() - $)),
                J && w(E) ? $ + it : ((this.xIncrement = $ + it), $)
              );
            }
            setDataSortingOptions() {
              const E = this.options;
              i(this, {
                requireSorting: !1,
                sorted: !1,
                enabledDataSorting: !0,
                allowDG: !1,
              }),
                h(E.pointRange) || (E.pointRange = 1);
            }
            setOptions(E) {
              var _, z;
              const J = this.chart;
              var tt = J.options.plotOptions,
                $ = J.userOptions || {};
              const it = I(E);
              E = J.styledMode;
              const nt = { plotOptions: tt, userOptions: it };
              e(this, "setOptions", nt);
              const rt = nt.plotOptions[this.type];
              $ = $.plotOptions || {};
              const at = $.series || {},
                ct = f.plotOptions[this.type] || {},
                Q = $[this.type] || {};
              return (
                (this.userOptions = nt.userOptions),
                (tt = I(rt, tt.series, Q, it)),
                (this.tooltipOptions = I(
                  f.tooltip,
                  (_ = f.plotOptions.series) === null || _ === void 0
                    ? void 0
                    : _.tooltip,
                  ct == null ? void 0 : ct.tooltip,
                  J.userOptions.tooltip,
                  (z = $.series) === null || z === void 0 ? void 0 : z.tooltip,
                  Q.tooltip,
                  it.tooltip
                )),
                (this.stickyTracking = B(
                  it.stickyTracking,
                  Q.stickyTracking,
                  at.stickyTracking,
                  this.tooltipOptions.shared && !this.noSharedTooltip
                    ? !0
                    : tt.stickyTracking
                )),
                rt.marker === null && delete tt.marker,
                (this.zoneAxis = tt.zoneAxis),
                (z = this.zones = (tt.zones || []).slice()),
                (!tt.negativeColor && !tt.negativeFillColor) ||
                  tt.zones ||
                  ((_ = {
                    value: tt[this.zoneAxis + "Threshold"] || tt.threshold || 0,
                    className: "highcharts-negative",
                  }),
                  E ||
                    ((_.color = tt.negativeColor),
                    (_.fillColor = tt.negativeFillColor)),
                  z.push(_)),
                z.length &&
                  h(z[z.length - 1].value) &&
                  z.push(
                    E ? {} : { color: this.color, fillColor: this.fillColor }
                  ),
                e(this, "afterSetOptions", { options: tt }),
                tt
              );
            }
            getName() {
              return B(this.options.name, "Series " + (this.index + 1));
            }
            getCyclic(E, _, z) {
              const J = this.chart,
                tt = `${E}Index`,
                $ = `${E}Counter`,
                it =
                  (z == null ? void 0 : z.length) || J.options.chart.colorCount;
              if (!_) {
                var nt = B(
                  E === "color" ? this.options.colorIndex : void 0,
                  this[tt]
                );
                h(nt) ||
                  (J.series.length || (J[$] = 0),
                  (nt = J[$] % it),
                  (J[$] += 1)),
                  z && (_ = z[nt]);
              }
              typeof nt < "u" && (this[tt] = nt), (this[E] = _);
            }
            getColor() {
              this.chart.styledMode
                ? this.getCyclic("color")
                : this.options.colorByPoint
                ? (this.color = "#cccccc")
                : this.getCyclic(
                    "color",
                    this.options.color || f.plotOptions[this.type].color,
                    this.chart.options.colors
                  );
            }
            getPointsCollection() {
              return (this.hasGroupedData ? this.points : this.data) || [];
            }
            getSymbol() {
              this.getCyclic(
                "symbol",
                this.options.marker.symbol,
                this.chart.options.symbols
              );
            }
            findPointIndex(E, _) {
              const z = E.id,
                J = E.x,
                tt = this.points;
              var $ = this.options.dataSorting,
                it;
              let nt, rt;
              if (z) ($ = this.chart.get(z)), $ instanceof H && (it = $);
              else if (
                (this.linkedParent ||
                  this.enabledDataSorting ||
                  this.options.relativeXValue) &&
                ((it = (at) => !at.touched && at.index === E.index),
                $ && $.matchByName
                  ? (it = (at) => !at.touched && at.name === E.name)
                  : this.options.relativeXValue &&
                    (it = (at) => !at.touched && at.options.x === E.x),
                (it = t(tt, it)),
                !it)
              )
                return;
              return (
                it && ((rt = it && it.index), typeof rt < "u" && (nt = !0)),
                typeof rt > "u" && w(J) && (rt = this.xData.indexOf(J, _)),
                rt !== -1 &&
                  typeof rt < "u" &&
                  this.cropped &&
                  (rt = rt >= this.cropStart ? rt - this.cropStart : rt),
                !nt && w(rt) && tt[rt] && tt[rt].touched && (rt = void 0),
                rt
              );
            }
            updateData(E, _) {
              const z = this.options,
                J = z.dataSorting,
                tt = this.points,
                $ = [],
                it = this.requireSorting,
                nt = E.length === tt.length;
              let rt,
                at,
                ct,
                Q = !0;
              if (
                ((this.xIncrement = null),
                E.forEach(function (K, st) {
                  var et =
                    (h(K) &&
                      this.pointClass.prototype.optionsToObject.call(
                        { series: this },
                        K
                      )) ||
                    {};
                  const ot = et.x;
                  et.id || w(ot)
                    ? ((et = this.findPointIndex(et, ct)),
                      et === -1 || typeof et > "u"
                        ? $.push(K)
                        : tt[et] && K !== z.data[et]
                        ? (tt[et].update(K, !1, null, !1),
                          (tt[et].touched = !0),
                          it && (ct = et + 1))
                        : tt[et] && (tt[et].touched = !0),
                      (!nt ||
                        st !== et ||
                        (J && J.enabled) ||
                        this.hasDerivedData) &&
                        (rt = !0))
                    : $.push(K);
                }, this),
                rt)
              )
                for (E = tt.length; E--; )
                  (at = tt[E]) && !at.touched && at.remove && at.remove(!1, _);
              else
                !nt || (J && J.enabled)
                  ? (Q = !1)
                  : (E.forEach(function (K, st) {
                      K === tt[st].y ||
                        tt[st].destroyed ||
                        tt[st].update(K, !1, null, !1);
                    }),
                    ($.length = 0));
              return (
                tt.forEach(function (K) {
                  K && (K.touched = !1);
                }),
                Q
                  ? ($.forEach(function (K) {
                      this.addPoint(K, !1, null, null, !1);
                    }, this),
                    this.xIncrement === null &&
                      this.xData &&
                      this.xData.length &&
                      ((this.xIncrement = C(this.xData)), this.autoIncrement()),
                    !0)
                  : !1
              );
            }
            setData(E, _ = !0, z, J) {
              var tt;
              const $ = this,
                it = $.points,
                nt = (it && it.length) || 0,
                rt = $.options,
                at = $.chart,
                ct = rt.dataSorting,
                Q = $.xAxis,
                K = rt.turboThreshold,
                st = this.xData,
                et = this.yData;
              var ot = $.pointArrayMap;
              ot = ot && ot.length;
              const lt = rt.keys;
              let ht,
                mt = 0,
                yt = 1,
                gt = null;
              if (!at.options.chart.allowMutatingData) {
                rt.data && delete $.options.data,
                  $.userOptions.data && delete $.userOptions.data;
                var ft = I(!0, E);
              }
              if (
                ((E = ft || E || []),
                (ft = E.length),
                ct && ct.enabled && (E = this.sortData(E)),
                at.options.chart.allowMutatingData &&
                  J !== !1 &&
                  ft &&
                  nt &&
                  !$.cropped &&
                  !$.hasGroupedData &&
                  $.visible &&
                  !$.boosted &&
                  (ht = this.updateData(E, z)),
                !ht)
              ) {
                if (
                  (($.xIncrement = null),
                  ($.colorCounter = 0),
                  this.parallelArrays.forEach(function (St) {
                    $[St + "Data"].length = 0;
                  }),
                  K && ft > K)
                )
                  if (((gt = $.getFirstValidPoint(E)), w(gt)))
                    for (z = 0; z < ft; z++)
                      (st[z] = this.autoIncrement()), (et[z] = E[z]);
                  else if (r(gt))
                    if (ot)
                      if (gt.length === ot)
                        for (z = 0; z < ft; z++)
                          (st[z] = this.autoIncrement()), (et[z] = E[z]);
                      else
                        for (z = 0; z < ft; z++)
                          (J = E[z]),
                            (st[z] = J[0]),
                            (et[z] = J.slice(1, ot + 1));
                    else if (
                      (lt &&
                        ((mt = lt.indexOf("x")),
                        (yt = lt.indexOf("y")),
                        (mt = 0 <= mt ? mt : 0),
                        (yt = 0 <= yt ? yt : 1)),
                      gt.length === 1 && (yt = 0),
                      mt === yt)
                    )
                      for (z = 0; z < ft; z++)
                        (st[z] = this.autoIncrement()), (et[z] = E[z][yt]);
                    else
                      for (z = 0; z < ft; z++)
                        (J = E[z]), (st[z] = J[mt]), (et[z] = J[yt]);
                  else o(12, !1, at);
                else
                  for (z = 0; z < ft; z++)
                    (J = { series: $ }),
                      $.pointClass.prototype.applyOptions.apply(J, [E[z]]),
                      $.updateParallelArrays(J, z);
                for (
                  et && L(et[0]) && o(14, !0, at),
                    $.data = [],
                    $.options.data = $.userOptions.data = E,
                    z = nt;
                  z--;

                )
                  (tt = it[z]) === null || tt === void 0 || tt.destroy();
                Q && (Q.minRange = Q.userMinRange),
                  ($.isDirty = at.isDirtyBox = !0),
                  ($.isDirtyData = !!it),
                  (z = !1);
              }
              rt.legendType === "point" &&
                (this.processData(), this.generatePoints()),
                _ && at.redraw(z);
            }
            sortData(E) {
              const _ = this,
                z = _.options.dataSorting.sortKey || "y",
                J = function (tt, $) {
                  return (
                    (h($) &&
                      tt.pointClass.prototype.optionsToObject.call(
                        { series: tt },
                        $
                      )) ||
                    {}
                  );
                };
              return (
                E.forEach(function (tt, $) {
                  (E[$] = J(_, tt)), (E[$].index = $);
                }, this),
                E.concat()
                  .sort(
                    (tt, $) => (
                      (tt = a(z, tt)),
                      ($ = a(z, $)),
                      $ < tt ? -1 : $ > tt ? 1 : 0
                    )
                  )
                  .forEach(function (tt, $) {
                    tt.x = $;
                  }, this),
                _.linkedSeries &&
                  _.linkedSeries.forEach(function (tt) {
                    const $ = tt.options,
                      it = $.data;
                    ($.dataSorting && $.dataSorting.enabled) ||
                      !it ||
                      (it.forEach(function (nt, rt) {
                        (it[rt] = J(tt, nt)),
                          E[rt] && ((it[rt].x = E[rt].x), (it[rt].index = rt));
                      }),
                      tt.setData(it, !1));
                  }),
                E
              );
            }
            getProcessedData(E) {
              const _ = this;
              var z = _.xAxis,
                J = _.options;
              const tt = J.cropThreshold,
                $ = E || _.getExtremesFromAll || J.getExtremesFromAll,
                it = z == null ? void 0 : z.logarithmic,
                nt = _.isCartesian;
              let rt = 0,
                at;
              (E = _.xData), (J = _.yData);
              let ct = !1;
              const Q = E.length;
              if (z) {
                var K = z.getExtremes();
                (at = K.min),
                  (K = K.max),
                  (ct = !(!z.categories || z.names.length));
              }
              if (nt && _.sorted && !$ && (!tt || Q > tt || _.forceCrop)) {
                if (E[Q - 1] < at || E[0] > K) (E = []), (J = []);
                else if (_.yData && (E[0] < at || E[Q - 1] > K)) {
                  var st = this.cropData(_.xData, _.yData, at, K);
                  (E = st.xData), (J = st.yData), (rt = st.start), (st = !0);
                }
              }
              return (
                (z = s(
                  [it ? E.map(it.log2lin) : E],
                  () => _.requireSorting && !ct && o(15, !1, _.chart)
                )),
                {
                  xData: E,
                  yData: J,
                  cropped: st,
                  cropStart: rt,
                  closestPointRange: z,
                }
              );
            }
            processData(E) {
              const _ = this.xAxis;
              if (
                this.isCartesian &&
                !this.isDirty &&
                !_.isDirty &&
                !this.yAxis.isDirty &&
                !E
              )
                return !1;
              (E = this.getProcessedData()),
                (this.cropped = E.cropped),
                (this.cropStart = E.cropStart),
                (this.processedXData = E.xData),
                (this.processedYData = E.yData),
                (this.closestPointRange = this.basePointRange =
                  E.closestPointRange),
                e(this, "afterProcessData");
            }
            cropData(E, _, z, J, tt) {
              const $ = E.length;
              let it,
                nt = 0,
                rt = $;
              for (tt = B(tt, this.cropShoulder), it = 0; it < $; it++)
                if (E[it] >= z) {
                  nt = Math.max(0, it - tt);
                  break;
                }
              for (z = it; z < $; z++)
                if (E[z] > J) {
                  rt = z + tt;
                  break;
                }
              return {
                xData: E.slice(nt, rt),
                yData: _.slice(nt, rt),
                start: nt,
                end: rt,
              };
            }
            generatePoints() {
              var E = this.options;
              const _ = this.processedData || E.data,
                z = this.processedXData,
                J = this.processedYData,
                tt = this.pointClass,
                $ = z.length,
                it = this.cropStart || 0,
                nt = this.hasGroupedData,
                rt = E.keys,
                at = [];
              E = E.dataGrouping && E.dataGrouping.groupAll ? it : 0;
              let ct,
                Q,
                K,
                st = this.data;
              if (!st && !nt) {
                var et = [];
                (et.length = _.length), (st = this.data = et);
              }
              for (rt && nt && (this.options.keys = !1), K = 0; K < $; K++)
                (et = it + K),
                  nt
                    ? ((Q = new tt().init(this, [z[K]].concat(R(J[K])))),
                      (Q.dataGroup = this.groupMap[E + K]),
                      Q.dataGroup.options &&
                        ((Q.options = Q.dataGroup.options),
                        i(Q, Q.dataGroup.options),
                        delete Q.dataLabels))
                    : (Q = st[et]) ||
                      typeof _[et] > "u" ||
                      (st[et] = Q = new tt().init(this, _[et], z[K])),
                  Q && ((Q.index = nt ? E + K : et), (at[K] = Q));
              if (
                ((this.options.keys = rt), st && ($ !== (ct = st.length) || nt))
              )
                for (K = 0; K < ct; K++)
                  K !== it || nt || (K += $),
                    st[K] && (st[K].destroyElements(), (st[K].plotX = void 0));
              (this.data = st),
                (this.points = at),
                e(this, "afterGeneratePoints");
            }
            getXExtremes(E) {
              return { min: P(E), max: C(E) };
            }
            getExtremes(E, _) {
              const z = this.xAxis;
              var J = this.yAxis;
              const tt = this.processedXData || this.xData,
                $ = [],
                it = this.requireSorting ? this.cropShoulder : 0;
              J = J ? J.positiveValuesOnly : !1;
              let nt,
                rt = 0,
                at = 0,
                ct = 0;
              E = E || this.stackedYData || this.processedYData || [];
              const Q = E.length;
              if (z) {
                var K = z.getExtremes();
                (rt = K.min), (at = K.max);
              }
              for (nt = 0; nt < Q; nt++) {
                var st = tt[nt];
                K = E[nt];
                var et = (w(K) || r(K)) && (K.length || 0 < K || !J);
                if (
                  ((st =
                    _ ||
                    this.getExtremesFromAll ||
                    this.options.getExtremesFromAll ||
                    this.cropped ||
                    !z ||
                    ((tt[nt + it] || st) >= rt && (tt[nt - it] || st) <= at)),
                  et && st)
                )
                  if ((et = K.length))
                    for (; et--; ) w(K[et]) && ($[ct++] = K[et]);
                  else $[ct++] = K;
              }
              return (
                (E = { activeYData: $, dataMin: P($), dataMax: C($) }),
                e(this, "afterGetExtremes", { dataExtremes: E }),
                E
              );
            }
            applyExtremes() {
              const E = this.getExtremes();
              return (this.dataMin = E.dataMin), (this.dataMax = E.dataMax), E;
            }
            getFirstValidPoint(E) {
              const _ = E.length;
              let z = 0,
                J = null;
              for (; J === null && z < _; ) (J = E[z]), z++;
              return J;
            }
            translate() {
              var E;
              this.processedXData || this.processData(), this.generatePoints();
              var _ = this.options;
              const z = _.stacking,
                J = this.xAxis,
                tt = J.categories,
                $ = this.enabledDataSorting,
                it = this.yAxis,
                nt = this.points,
                rt = nt.length,
                at = this.pointPlacementToXValue(),
                ct = !!at,
                Q = _.threshold;
              _ = _.startFromThreshold ? Q : 0;
              let K,
                st,
                et,
                ot,
                lt = Number.MAX_VALUE;
              for (K = 0; K < rt; K++) {
                const ht = nt[K],
                  mt = ht.x;
                let yt,
                  gt,
                  ft = ht.y,
                  St = ht.low;
                const bt =
                  z &&
                  ((E = it.stacking) === null || E === void 0
                    ? void 0
                    : E.stacks[
                        (this.negStacks && ft < (_ ? 0 : Q) ? "-" : "") +
                          this.stackKey
                      ]);
                (st = J.translate(mt, !1, !1, !1, !0, at)),
                  (ht.plotX = w(st) ? m(j(st, -1e5, 1e5)) : void 0),
                  z &&
                    this.visible &&
                    bt &&
                    bt[mt] &&
                    ((ot = this.getStackIndicator(ot, mt, this.index)),
                    !ht.isNull &&
                      ot.key &&
                      ((yt = bt[mt]), (gt = yt.points[ot.key])),
                    yt &&
                      r(gt) &&
                      ((St = gt[0]),
                      (ft = gt[1]),
                      St === _ &&
                        ot.key === bt[mt].base &&
                        (St = B(w(Q) ? Q : it.min)),
                      it.positiveValuesOnly &&
                        h(St) &&
                        0 >= St &&
                        (St = void 0),
                      (ht.total = ht.stackTotal = B(yt.total)),
                      (ht.percentage =
                        h(ht.y) && yt.total ? (ht.y / yt.total) * 100 : void 0),
                      (ht.stackY = ft),
                      this.irregularWidths ||
                        yt.setOffset(
                          this.pointXOffset || 0,
                          this.barW || 0,
                          void 0,
                          void 0,
                          void 0,
                          this.xAxis
                        ))),
                  (ht.yBottom = h(St)
                    ? j(it.translate(St, !1, !0, !1, !0), -1e5, 1e5)
                    : void 0),
                  this.dataModify && (ft = this.dataModify.modifyValue(ft, K));
                let kt;
                w(ft) &&
                  ht.plotX !== void 0 &&
                  ((kt = it.translate(ft, !1, !0, !1, !0)),
                  (kt = w(kt) ? j(kt, -1e5, 1e5) : void 0)),
                  (ht.plotY = kt),
                  (ht.isInside = this.isPointInside(ht)),
                  (ht.clientX = ct
                    ? m(J.translate(mt, !1, !1, !1, !0, at))
                    : st),
                  (ht.negative = (ht.y || 0) < (Q || 0)),
                  (ht.category = B(tt && tt[ht.x], ht.x)),
                  ht.isNull ||
                    ht.visible === !1 ||
                    (typeof et < "u" && (lt = Math.min(lt, Math.abs(st - et))),
                    (et = st)),
                  (ht.zone = this.zones.length ? ht.getZone() : void 0),
                  !ht.graphic && this.group && $ && (ht.isNew = !0);
              }
              (this.closestPointRangePx = lt), e(this, "afterTranslate");
            }
            getValidPoints(E, _, z) {
              const J = this.chart;
              return (E || this.points || []).filter(function (tt) {
                const { plotX: $, plotY: it } = tt;
                return (!z && (tt.isNull || !w(it))) ||
                  (_ && !J.isInsidePlot($, it, { inverted: J.inverted }))
                  ? !1
                  : tt.visible !== !1;
              });
            }
            getClipBox() {
              const { chart: E, xAxis: _, yAxis: z } = this,
                J = I(E.clipBox);
              return (
                _ && _.len !== E.plotSizeX && (J.width = _.len),
                z && z.len !== E.plotSizeY && (J.height = z.len),
                J
              );
            }
            getSharedClipKey() {
              return (this.sharedClipKey =
                (this.options.xAxis || 0) + "," + (this.options.yAxis || 0));
            }
            setClip() {
              const { chart: E, group: _, markerGroup: z } = this,
                J = E.sharedClips,
                tt = E.renderer,
                $ = this.getClipBox(),
                it = this.getSharedClipKey();
              let nt = J[it];
              nt ? nt.animate($) : (J[it] = nt = tt.clipRect($)),
                _ && _.clip(this.options.clip === !1 ? void 0 : nt),
                z && z.clip();
            }
            animate(E) {
              const { chart: _, group: z, markerGroup: J } = this,
                tt = _.inverted;
              var $ = c(this.options.animation),
                it = [
                  this.getSharedClipKey(),
                  $.duration,
                  $.easing,
                  $.defer,
                ].join();
              let nt = _.sharedClips[it],
                rt = _.sharedClips[it + "m"];
              if (E && z)
                ($ = this.getClipBox()),
                  nt
                    ? nt.attr("height", $.height)
                    : (($.width = 0),
                      tt && ($.x = _.plotHeight),
                      (nt = _.renderer.clipRect($)),
                      (_.sharedClips[it] = nt),
                      (rt = _.renderer.clipRect({
                        x: -99,
                        y: -99,
                        width: tt ? _.plotWidth + 199 : 99,
                        height: tt ? 99 : _.plotHeight + 199,
                      })),
                      (_.sharedClips[it + "m"] = rt)),
                  z.clip(nt),
                  J && J.clip(rt);
              else if (nt && !nt.hasClass("highcharts-animating")) {
                it = this.getClipBox();
                const at = $.step;
                J &&
                  J.element.childNodes.length &&
                  ($.step = function (ct, Q) {
                    at && at.apply(Q, arguments),
                      Q.prop === "width" &&
                        rt &&
                        rt.element &&
                        rt.attr(tt ? "height" : "width", ct + 99);
                  }),
                  nt.addClass("highcharts-animating").animate(it, $);
              }
            }
            afterAnimate() {
              this.setClip(),
                V(this.chart.sharedClips, (E, _, z) => {
                  E &&
                    !this.chart.container.querySelector(
                      `[clip-path="url(#${E.id})"]`
                    ) &&
                    (E.destroy(), delete z[_]);
                }),
                (this.finishedAnimating = !0),
                e(this, "afterAnimate");
            }
            drawPoints(E = this.points) {
              const _ = this.chart,
                z = _.styledMode,
                { colorAxis: J, options: tt } = this,
                $ = tt.marker,
                it = this[this.specialGroup || "markerGroup"],
                nt = this.xAxis,
                rt = B(
                  $.enabled,
                  !nt || nt.isRadial ? !0 : null,
                  this.closestPointRangePx >= $.enabledThreshold * $.radius
                );
              let at, ct, Q, K, st, et;
              if ($.enabled !== !1 || this._hasPointMarkers)
                for (at = 0; at < E.length; at++) {
                  (ct = E[at]), (K = (Q = ct.graphic) ? "animate" : "attr");
                  var ot = ct.marker || {};
                  if (
                    ((st = !!ct.marker),
                    ((rt && typeof ot.enabled > "u") || ot.enabled) &&
                      !ct.isNull &&
                      ct.visible !== !1)
                  ) {
                    const lt = B(ot.symbol, this.symbol, "rect");
                    (et = this.markerAttribs(ct, ct.selected && "select")),
                      this.enabledDataSorting &&
                        (ct.startXPos = nt.reversed
                          ? -(et.width || 0)
                          : nt.width);
                    const ht = ct.isInside !== !1;
                    !Q &&
                      ht &&
                      (0 < (et.width || 0) || ct.hasImage) &&
                      ((ct.graphic = Q =
                        _.renderer
                          .symbol(
                            lt,
                            et.x,
                            et.y,
                            et.width,
                            et.height,
                            st ? ot : $
                          )
                          .add(it)),
                      this.enabledDataSorting &&
                        _.hasRendered &&
                        (Q.attr({ x: ct.startXPos }), (K = "animate"))),
                      Q &&
                        K === "animate" &&
                        Q[ht ? "show" : "hide"](ht).animate(et),
                      Q &&
                        ((ot = this.pointAttribs(
                          ct,
                          z || !ct.selected ? void 0 : "select"
                        )),
                        z ? J && Q.css({ fill: ot.fill }) : Q[K](ot)),
                      Q && Q.addClass(ct.getClassName(), !0);
                  } else Q && (ct.graphic = Q.destroy());
                }
            }
            markerAttribs(E, _) {
              const z = this.options;
              var J = z.marker;
              const tt = E.marker || {},
                $ = tt.symbol || J.symbol,
                it = {};
              let nt = B(tt.radius, J && J.radius);
              return (
                _ &&
                  ((J = J.states[_]),
                  (_ = tt.states && tt.states[_]),
                  (nt = B(
                    _ && _.radius,
                    J && J.radius,
                    nt && nt + ((J && J.radiusPlus) || 0)
                  ))),
                (E.hasImage = $ && $.indexOf("url") === 0),
                E.hasImage && (nt = 0),
                (E = E.pos()),
                w(nt) &&
                  E &&
                  ((it.x = E[0] - nt),
                  (it.y = E[1] - nt),
                  z.crisp && (it.x = Math.floor(it.x))),
                nt && (it.width = it.height = 2 * nt),
                it
              );
            }
            pointAttribs(E, _) {
              var z = this.options.marker,
                J = E && E.options;
              const tt = (J && J.marker) || {};
              var $ = J && J.color,
                it = E && E.color;
              const nt = E && E.zone && E.zone.color;
              let rt = this.color;
              return (
                (E = B(tt.lineWidth, z.lineWidth)),
                (J = 1),
                (rt = $ || nt || it || rt),
                ($ = tt.fillColor || z.fillColor || rt),
                (it = tt.lineColor || z.lineColor || rt),
                (_ = _ || "normal"),
                (z = z.states[_] || {}),
                (_ = (tt.states && tt.states[_]) || {}),
                (E = B(
                  _.lineWidth,
                  z.lineWidth,
                  E + B(_.lineWidthPlus, z.lineWidthPlus, 0)
                )),
                ($ = _.fillColor || z.fillColor || $),
                (it = _.lineColor || z.lineColor || it),
                (J = B(_.opacity, z.opacity, J)),
                { stroke: it, "stroke-width": E, fill: $, opacity: J }
              );
            }
            destroy(E) {
              const _ = this,
                z = _.chart,
                J = /AppleWebKit\/533/.test(g.navigator.userAgent),
                tt = _.data || [];
              let $, it, nt, rt;
              for (
                e(_, "destroy", { keepEventsForUpdate: E }),
                  this.removeEvents(E),
                  (_.axisTypes || []).forEach(function (at) {
                    (rt = _[at]) &&
                      rt.series &&
                      (l(rt.series, _), (rt.isDirty = rt.forceRedraw = !0));
                  }),
                  _.legendItem && _.chart.legend.destroyItem(_),
                  it = tt.length;
                it--;

              )
                (nt = tt[it]) && nt.destroy && nt.destroy();
              _.clips && _.clips.forEach((at) => at.destroy()),
                D.clearTimeout(_.animationTimeout),
                V(_, function (at, ct) {
                  at instanceof N &&
                    !at.survive &&
                    (($ = J && ct === "group" ? "hide" : "destroy"), at[$]());
                }),
                z.hoverSeries === _ && (z.hoverSeries = void 0),
                l(z.series, _),
                z.orderItems("series"),
                V(_, function (at, ct) {
                  (E && ct === "hcEvents") || delete _[ct];
                });
            }
            applyZones() {
              const E = this,
                _ = this.chart,
                z = _.renderer,
                J = this.zones,
                tt = this.clips || [],
                $ = this.graph,
                it = this.area,
                nt = Math.max(_.plotWidth, _.plotHeight),
                rt = this[(this.zoneAxis || "y") + "Axis"],
                at = _.inverted;
              let ct,
                Q,
                K,
                st,
                et,
                ot,
                lt,
                ht,
                mt,
                yt,
                gt,
                ft = !1;
              J.length && ($ || it) && rt && typeof rt.min < "u"
                ? ((et = rt.reversed),
                  (ot = rt.horiz),
                  $ && !this.showLine && $.hide(),
                  it && it.hide(),
                  (st = rt.getExtremes()),
                  J.forEach(function (St, bt) {
                    (ct = et
                      ? ot
                        ? _.plotWidth
                        : 0
                      : ot
                      ? 0
                      : rt.toPixels(st.min) || 0),
                      (ct = j(B(Q, ct), 0, nt)),
                      (Q = j(
                        Math.round(rt.toPixels(B(St.value, st.max), !0) || 0),
                        0,
                        nt
                      )),
                      ft && (ct = Q = rt.toPixels(st.max)),
                      (lt = Math.abs(ct - Q)),
                      (ht = Math.min(ct, Q)),
                      (mt = Math.max(ct, Q)),
                      rt.isXAxis
                        ? ((K = {
                            x: at ? mt : ht,
                            y: 0,
                            width: lt,
                            height: nt,
                          }),
                          ot || (K.x = _.plotHeight - K.x))
                        : ((K = {
                            x: 0,
                            y: at ? mt : ht,
                            width: nt,
                            height: lt,
                          }),
                          ot && (K.y = _.plotWidth - K.y)),
                      tt[bt] ? tt[bt].animate(K) : (tt[bt] = z.clipRect(K)),
                      (yt = E["zone-area-" + bt]),
                      (gt = E["zone-graph-" + bt]),
                      $ && gt && gt.clip(tt[bt]),
                      it && yt && yt.clip(tt[bt]),
                      (ft = St.value > st.max),
                      E.resetZones && Q === 0 && (Q = void 0);
                  }),
                  (this.clips = tt))
                : E.visible && ($ && $.show(), it && it.show());
            }
            plotGroup(E, _, z, J, tt) {
              let $ = this[E];
              const it = !$;
              return (
                (z = { visibility: z, zIndex: J || 0.1 }),
                typeof this.opacity > "u" ||
                  this.chart.styledMode ||
                  this.state === "inactive" ||
                  (z.opacity = this.opacity),
                it && (this[E] = $ = this.chart.renderer.g().add(tt)),
                $.addClass(
                  "highcharts-" +
                    _ +
                    " highcharts-series-" +
                    this.index +
                    " highcharts-" +
                    this.type +
                    "-series " +
                    (h(this.colorIndex)
                      ? "highcharts-color-" + this.colorIndex + " "
                      : "") +
                    (this.options.className || "") +
                    ($.hasClass("highcharts-tracker")
                      ? " highcharts-tracker"
                      : ""),
                  !0
                ),
                $.attr(z)[it ? "attr" : "animate"](this.getPlotBox(_)),
                $
              );
            }
            getPlotBox(E) {
              let _ = this.xAxis,
                z = this.yAxis;
              const J = this.chart;
              return (
                (E =
                  J.inverted &&
                  !J.polar &&
                  _ &&
                  this.invertible !== !1 &&
                  E === "series"),
                J.inverted && ((_ = z), (z = this.xAxis)),
                {
                  translateX: _ ? _.left : J.plotLeft,
                  translateY: z ? z.top : J.plotTop,
                  rotation: E ? 90 : 0,
                  rotationOriginX: E ? (_.len - z.len) / 2 : 0,
                  rotationOriginY: E ? (_.len + z.len) / 2 : 0,
                  scaleX: E ? -1 : 1,
                  scaleY: 1,
                }
              );
            }
            removeEvents(E) {
              E || x(this),
                this.eventsToUnbind.length &&
                  (this.eventsToUnbind.forEach(function (_) {
                    _();
                  }),
                  (this.eventsToUnbind.length = 0));
            }
            render() {
              const E = this;
              var _ = E.chart;
              const z = E.options,
                J = c(z.animation),
                tt = E.visible ? "inherit" : "hidden",
                $ = z.zIndex,
                it = E.hasRendered;
              _ = _.seriesGroup;
              let nt = E.finishedAnimating ? 0 : J.duration;
              e(this, "render"),
                E.plotGroup("group", "series", tt, $, _),
                (E.markerGroup = E.plotGroup(
                  "markerGroup",
                  "markers",
                  tt,
                  $,
                  _
                )),
                z.clip !== !1 && E.setClip(),
                E.animate && nt && E.animate(!0),
                E.drawGraph && (E.drawGraph(), E.applyZones()),
                E.visible && E.drawPoints(),
                E.drawDataLabels && E.drawDataLabels(),
                E.redrawPoints && E.redrawPoints(),
                E.drawTracker && z.enableMouseTracking && E.drawTracker(),
                E.animate && nt && E.animate(),
                it ||
                  (nt && J.defer && (nt += J.defer),
                  (E.animationTimeout = W(function () {
                    E.afterAnimate();
                  }, nt || 0))),
                (E.isDirty = !1),
                (E.hasRendered = !0),
                e(E, "afterRender");
            }
            redraw() {
              const E = this.isDirty || this.isDirtyData;
              this.translate(), this.render(), E && delete this.kdTree;
            }
            searchPoint(E, _) {
              const z = this.xAxis,
                J = this.yAxis,
                tt = this.chart.inverted;
              return this.searchKDTree(
                {
                  clientX: tt ? z.len - E.chartY + z.pos : E.chartX - z.pos,
                  plotY: tt ? J.len - E.chartX + J.pos : E.chartY - J.pos,
                },
                _,
                E
              );
            }
            buildKDTree(E) {
              function _(tt, $, it) {
                var nt = tt && tt.length;
                let rt;
                if (nt)
                  return (
                    (rt = z.kdAxisArray[$ % it]),
                    tt.sort(function (at, ct) {
                      return at[rt] - ct[rt];
                    }),
                    (nt = Math.floor(nt / 2)),
                    {
                      point: tt[nt],
                      left: _(tt.slice(0, nt), $ + 1, it),
                      right: _(tt.slice(nt + 1), $ + 1, it),
                    }
                  );
              }
              this.buildingKdTree = !0;
              const z = this,
                J = -1 < z.options.findNearestPointBy.indexOf("y") ? 2 : 1;
              delete z.kdTree,
                W(
                  function () {
                    (z.kdTree = _(
                      z.getValidPoints(null, !z.directTouch),
                      J,
                      J
                    )),
                      (z.buildingKdTree = !1);
                  },
                  z.options.kdNow || (E && E.type === "touchstart") ? 0 : 1
                );
            }
            searchKDTree(E, _, z) {
              function J(rt, at, ct, Q) {
                const K = at.point;
                var st = tt.kdAxisArray[ct % Q];
                let et = K;
                var ot = h(rt[$]) && h(K[$]) ? Math.pow(rt[$] - K[$], 2) : null,
                  lt =
                    h(rt[it]) && h(K[it]) ? Math.pow(rt[it] - K[it], 2) : null;
                return (
                  (lt = (ot || 0) + (lt || 0)),
                  (K.dist = h(lt) ? Math.sqrt(lt) : Number.MAX_VALUE),
                  (K.distX = h(ot) ? Math.sqrt(ot) : Number.MAX_VALUE),
                  (st = rt[st] - K[st]),
                  (lt = 0 > st ? "left" : "right"),
                  (ot = 0 > st ? "right" : "left"),
                  at[lt] &&
                    ((lt = J(rt, at[lt], ct + 1, Q)),
                    (et = lt[nt] < et[nt] ? lt : K)),
                  at[ot] &&
                    Math.sqrt(st * st) < et[nt] &&
                    ((rt = J(rt, at[ot], ct + 1, Q)),
                    (et = rt[nt] < et[nt] ? rt : et)),
                  et
                );
              }
              const tt = this,
                $ = this.kdAxisArray[0],
                it = this.kdAxisArray[1],
                nt = _ ? "distX" : "dist";
              if (
                ((_ = -1 < tt.options.findNearestPointBy.indexOf("y") ? 2 : 1),
                this.kdTree || this.buildingKdTree || this.buildKDTree(z),
                this.kdTree)
              )
                return J(E, this.kdTree, _, _);
            }
            pointPlacementToXValue() {
              const {
                options: { pointPlacement: E, pointRange: _ },
                xAxis: z,
              } = this;
              let J = E;
              return (
                J === "between" && (J = z.reversed ? -0.5 : 0.5),
                w(J) ? J * (_ || z.pointRange) : 0
              );
            }
            isPointInside(E) {
              const { chart: _, xAxis: z, yAxis: J } = this;
              return (
                typeof E.plotY < "u" &&
                typeof E.plotX < "u" &&
                0 <= E.plotY &&
                E.plotY <= (J ? J.len : _.plotHeight) &&
                0 <= E.plotX &&
                E.plotX <= (z ? z.len : _.plotWidth)
              );
            }
            drawTracker() {
              const E = this,
                _ = E.options,
                z = _.trackByArea,
                J = [].concat(z ? E.areaPath : E.graphPath),
                tt = E.chart,
                $ = tt.pointer,
                it = tt.renderer,
                nt = tt.options.tooltip.snap,
                rt = E.tracker,
                at = function (Q) {
                  _.enableMouseTracking &&
                    tt.hoverSeries !== E &&
                    E.onMouseOver();
                },
                ct = "rgba(192,192,192," + (d ? 1e-4 : 0.002) + ")";
              rt
                ? rt.attr({ d: J })
                : E.graph &&
                  ((E.tracker = it
                    .path(J)
                    .attr({
                      visibility: E.visible ? "inherit" : "hidden",
                      zIndex: 2,
                    })
                    .addClass(
                      z ? "highcharts-tracker-area" : "highcharts-tracker-line"
                    )
                    .add(E.group)),
                  tt.styledMode ||
                    E.tracker.attr({
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      stroke: ct,
                      fill: z ? ct : "none",
                      "stroke-width": E.graph.strokeWidth() + (z ? 0 : 2 * nt),
                    }),
                  [E.tracker, E.markerGroup, E.dataLabelsGroup].forEach(
                    function (Q) {
                      Q &&
                        (Q.addClass("highcharts-tracker")
                          .on("mouseover", at)
                          .on("mouseout", function (K) {
                            $.onTrackerMouseOut(K);
                          }),
                        _.cursor &&
                          !tt.styledMode &&
                          Q.css({ cursor: _.cursor }),
                        n) &&
                        Q.on("touchstart", at);
                    }
                  )),
                e(this, "afterDrawTracker");
            }
            addPoint(E, _, z, J, tt) {
              const $ = this.options,
                it = this.data,
                nt = this.chart;
              var rt = this.xAxis;
              rt = rt && rt.hasNames && rt.names;
              const at = $.data,
                ct = this.xData;
              let Q, K;
              _ = B(_, !0);
              const st = { series: this };
              this.pointClass.prototype.applyOptions.apply(st, [E]);
              const et = st.x;
              if (((K = ct.length), this.requireSorting && et < ct[K - 1]))
                for (Q = !0; K && ct[K - 1] > et; ) K--;
              this.updateParallelArrays(st, "splice", [K, 0, 0]),
                this.updateParallelArrays(st, K),
                rt && st.name && (rt[et] = st.name),
                at.splice(K, 0, E),
                (Q || this.processedData) &&
                  (this.data.splice(K, 0, null), this.processData()),
                $.legendType === "point" && this.generatePoints(),
                z &&
                  (it[0] && it[0].remove
                    ? it[0].remove(!1)
                    : (it.shift(),
                      this.updateParallelArrays(st, "shift"),
                      at.shift())),
                tt !== !1 && e(this, "addPoint", { point: st }),
                (this.isDirtyData = this.isDirty = !0),
                _ && nt.redraw(J);
            }
            removePoint(E, _, z) {
              const J = this,
                tt = J.data,
                $ = tt[E],
                it = J.points,
                nt = J.chart,
                rt = function () {
                  it && it.length === tt.length && it.splice(E, 1),
                    tt.splice(E, 1),
                    J.options.data.splice(E, 1),
                    J.updateParallelArrays($ || { series: J }, "splice", [
                      E,
                      1,
                    ]),
                    $ && $.destroy(),
                    (J.isDirty = !0),
                    (J.isDirtyData = !0),
                    _ && nt.redraw();
                };
              p(z, nt),
                (_ = B(_, !0)),
                $ ? $.firePointEvent("remove", null, rt) : rt();
            }
            remove(E, _, z, J) {
              function tt() {
                $.destroy(J),
                  (it.isDirtyLegend = it.isDirtyBox = !0),
                  it.linkSeries(J),
                  B(E, !0) && it.redraw(_);
              }
              const $ = this,
                it = $.chart;
              z !== !1 ? e($, "remove", null, tt) : tt();
            }
            update(E, _) {
              (E = v(E, this.userOptions)), e(this, "update", { options: E });
              const z = this,
                J = z.chart;
              var tt = z.userOptions;
              const $ = z.initialType || z.type;
              var it = J.options.plotOptions;
              const nt = M[$].prototype;
              var rt = z.finishedAnimating && { animation: !1 };
              const at = {};
              let ct,
                Q = [
                  "colorIndex",
                  "eventOptions",
                  "navigatorSeries",
                  "symbolIndex",
                  "baseSeries",
                ],
                K = E.type || tt.type || J.options.chart.type;
              const st = !(
                this.hasDerivedData ||
                (K && K !== this.type) ||
                typeof E.pointStart < "u" ||
                typeof E.pointInterval < "u" ||
                typeof E.relativeXValue < "u" ||
                E.joinBy ||
                E.mapData ||
                z.hasOptionChanged("dataGrouping") ||
                z.hasOptionChanged("pointStart") ||
                z.hasOptionChanged("pointInterval") ||
                z.hasOptionChanged("pointIntervalUnit") ||
                z.hasOptionChanged("keys")
              );
              if (
                ((K = K || $),
                st &&
                  (Q.push(
                    "data",
                    "isDirtyData",
                    "points",
                    "processedData",
                    "processedXData",
                    "processedYData",
                    "xIncrement",
                    "cropped",
                    "_hasPointMarkers",
                    "_hasPointLabels",
                    "clips",
                    "nodes",
                    "layout",
                    "level",
                    "mapMap",
                    "mapData",
                    "minY",
                    "maxY",
                    "minX",
                    "maxX"
                  ),
                  E.visible !== !1 && Q.push("area", "graph"),
                  z.parallelArrays.forEach(function (et) {
                    Q.push(et + "Data");
                  }),
                  E.data &&
                    (E.dataSorting && i(z.options.dataSorting, E.dataSorting),
                    this.setData(E.data, !1))),
                (E = I(
                  tt,
                  rt,
                  {
                    index: typeof tt.index > "u" ? z.index : tt.index,
                    pointStart: B(
                      it && it.series && it.series.pointStart,
                      tt.pointStart,
                      z.xData[0]
                    ),
                  },
                  !st && { data: z.options.data },
                  E
                )),
                st && E.data && (E.data = z.options.data),
                (Q = [
                  "group",
                  "markerGroup",
                  "dataLabelsGroup",
                  "transformGroup",
                ].concat(Q)),
                Q.forEach(function (et) {
                  (Q[et] = z[et]), delete z[et];
                }),
                (it = !1),
                M[K])
              ) {
                if (((it = K !== z.type), z.remove(!1, !1, !1, !0), it))
                  if (Object.setPrototypeOf)
                    Object.setPrototypeOf(z, M[K].prototype);
                  else {
                    rt =
                      Object.hasOwnProperty.call(z, "hcEvents") && z.hcEvents;
                    for (ct in nt) z[ct] = void 0;
                    i(z, M[K].prototype),
                      rt ? (z.hcEvents = rt) : delete z.hcEvents;
                  }
              } else o(17, !0, J, { missingModuleFor: K });
              if (
                (Q.forEach(function (et) {
                  z[et] = Q[et];
                }),
                z.init(J, E),
                st && this.points)
              ) {
                if (((E = z.options), E.visible === !1))
                  (at.graphic = 1), (at.dataLabel = 1);
                else if (!z._hasPointLabels) {
                  const { marker: et, dataLabels: ot } = E;
                  (tt = tt.marker || {}),
                    !et ||
                      (et.enabled !== !1 &&
                        tt.symbol === et.symbol &&
                        tt.height === et.height &&
                        tt.width === et.width) ||
                      (at.graphic = 1),
                    ot && ot.enabled === !1 && (at.dataLabel = 1);
                }
                for (const et of this.points)
                  et &&
                    et.series &&
                    (et.resolveColor(),
                    Object.keys(at).length && et.destroyElements(at),
                    E.showInLegend === !1 &&
                      et.legendItem &&
                      J.legend.destroyItem(et));
              }
              (z.initialType = $),
                J.linkSeries(),
                it && z.linkedSeries.length && (z.isDirtyData = !0),
                e(this, "afterUpdate"),
                B(_, !0) && J.redraw(st ? void 0 : !1);
            }
            setName(E) {
              (this.name = this.options.name = this.userOptions.name = E),
                (this.chart.isDirtyLegend = !0);
            }
            hasOptionChanged(E) {
              const _ = this.options[E],
                z = this.chart.options.plotOptions,
                J = this.userOptions[E];
              return J
                ? _ !== J
                : _ !==
                    B(
                      z && z[this.type] && z[this.type][E],
                      z && z.series && z.series[E],
                      _
                    );
            }
            onMouseOver() {
              const E = this.chart,
                _ = E.hoverSeries;
              E.pointer.setHoverChartIndex(),
                _ && _ !== this && _.onMouseOut(),
                this.options.events.mouseOver && e(this, "mouseOver"),
                this.setState("hover"),
                (E.hoverSeries = this);
            }
            onMouseOut() {
              const E = this.options,
                _ = this.chart,
                z = _.tooltip,
                J = _.hoverPoint;
              (_.hoverSeries = null),
                J && J.onMouseOut(),
                this && E.events.mouseOut && e(this, "mouseOut"),
                !z ||
                  this.stickyTracking ||
                  (z.shared && !this.noSharedTooltip) ||
                  z.hide(),
                _.series.forEach(function (tt) {
                  tt.setState("", !0);
                });
            }
            setState(E, _) {
              const z = this;
              var J = z.options;
              const tt = z.graph,
                $ = J.inactiveOtherPoints,
                it = J.states,
                nt = B(
                  it[E || "normal"] && it[E || "normal"].animation,
                  z.chart.options.chart.animation
                );
              let rt = J.lineWidth,
                at = 0,
                ct = J.opacity;
              if (
                ((E = E || ""),
                z.state !== E &&
                  ([z.group, z.markerGroup, z.dataLabelsGroup].forEach(
                    function (Q) {
                      Q &&
                        (z.state &&
                          Q.removeClass("highcharts-series-" + z.state),
                        E && Q.addClass("highcharts-series-" + E));
                    }
                  ),
                  (z.state = E),
                  !z.chart.styledMode))
              ) {
                if (it[E] && it[E].enabled === !1) return;
                if (
                  (E &&
                    ((rt = it[E].lineWidth || rt + (it[E].lineWidthPlus || 0)),
                    (ct = B(it[E].opacity, ct))),
                  tt && !tt.dashstyle && w(rt))
                )
                  for (
                    J = { "stroke-width": rt }, tt.animate(J, nt);
                    z["zone-graph-" + at];

                  )
                    z["zone-graph-" + at].animate(J, nt), (at += 1);
                $ ||
                  [
                    z.group,
                    z.markerGroup,
                    z.dataLabelsGroup,
                    z.labelBySeries,
                  ].forEach(function (Q) {
                    Q && Q.animate({ opacity: ct }, nt);
                  });
              }
              _ && $ && z.points && z.setAllPointsToState(E || void 0);
            }
            setAllPointsToState(E) {
              this.points.forEach(function (_) {
                _.setState && _.setState(E);
              });
            }
            setVisible(E, _) {
              const z = this,
                J = z.chart,
                tt = J.options.chart.ignoreHiddenSeries,
                $ = z.visible,
                it = (z.visible =
                  E =
                  z.options.visible =
                  z.userOptions.visible =
                    typeof E > "u" ? !$ : E)
                  ? "show"
                  : "hide";
              [
                "group",
                "dataLabelsGroup",
                "markerGroup",
                "tracker",
                "tt",
              ].forEach(function (nt) {
                z[nt] && z[nt][it]();
              }),
                (J.hoverSeries === z ||
                  (J.hoverPoint && J.hoverPoint.series) === z) &&
                  z.onMouseOut(),
                z.legendItem && J.legend.colorizeItem(z, E),
                (z.isDirty = !0),
                z.options.stacking &&
                  J.series.forEach(function (nt) {
                    nt.options.stacking && nt.visible && (nt.isDirty = !0);
                  }),
                z.linkedSeries.forEach(function (nt) {
                  nt.setVisible(E, !1);
                }),
                tt && (J.isDirtyBox = !0),
                e(z, it),
                _ !== !1 && J.redraw();
            }
            show() {
              this.setVisible(!0);
            }
            hide() {
              this.setVisible(!1);
            }
            select(E) {
              (this.selected =
                E =
                this.options.selected =
                  typeof E > "u" ? !this.selected : E),
                this.checkbox && (this.checkbox.checked = E),
                e(this, E ? "select" : "unselect");
            }
            shouldShowTooltip(E, _, z = {}) {
              return (
                (z.series = this),
                (z.visiblePlotOnly = !0),
                this.chart.isInsidePlot(E, _, z)
              );
            }
            drawLegendSymbol(E, _) {
              var z;
              (z = U[this.options.legendSymbol || "rectangle"]) === null ||
                z === void 0 ||
                z.call(this, E, _);
            }
          }
          return (
            (X.defaultOptions = Y),
            (X.types = S.seriesTypes),
            (X.registerType = S.registerSeriesType),
            i(X.prototype, {
              axisTypes: ["xAxis", "yAxis"],
              coll: "series",
              colorCounter: 0,
              cropShoulder: 1,
              directTouch: !1,
              isCartesian: !0,
              kdAxisArray: ["clientX", "plotY"],
              parallelArrays: ["x", "y"],
              pointClass: H,
              requireSorting: !0,
              sorted: !0,
            }),
            (S.series = X),
            X
          );
        }
      ),
      T(
        y,
        "Core/Chart/Chart.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Axis/Axis.js"],
          y["Core/Defaults.js"],
          y["Core/Templating.js"],
          y["Core/Foundation.js"],
          y["Core/Globals.js"],
          y["Core/Renderer/RendererRegistry.js"],
          y["Core/Series/Series.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Renderer/SVG/SVGRenderer.js"],
          y["Core/Time.js"],
          y["Core/Utilities.js"],
          y["Core/Renderer/HTML/AST.js"],
        ],
        function (A, O, F, G, U, H, Y, S, N, D, c, p, f) {
          const { animate: u, animObject: n, setAnimation: d } = A,
            { defaultOptions: g, defaultTime: M } = F,
            { numberFormat: C } = G,
            { registerEventOptions: P } = U,
            { charts: j, doc: m, marginNames: h, svg: v, win: l } = H,
            { seriesTypes: o } = N,
            {
              addEvent: i,
              attr: t,
              createElement: e,
              css: s,
              defined: a,
              diffObjects: b,
              discardElement: r,
              erase: w,
              error: L,
              extend: I,
              find: V,
              fireEvent: B,
              getStyle: x,
              isArray: R,
              isNumber: W,
              isObject: X,
              isString: Z,
              merge: E,
              objectEach: _,
              pick: z,
              pInt: J,
              relativeLength: tt,
              removeEvent: $,
              splat: it,
              syncTimeout: nt,
              uniqueKey: rt,
            } = p;
          class at {
            static chart(Q, K, st) {
              return new at(Q, K, st);
            }
            constructor(Q, K, st) {
              (this.series =
                this.renderTo =
                this.renderer =
                this.pointer =
                this.pointCount =
                this.plotWidth =
                this.plotTop =
                this.plotLeft =
                this.plotHeight =
                this.plotBox =
                this.options =
                this.numberFormatter =
                this.margin =
                this.labelCollectors =
                this.isResizing =
                this.index =
                this.eventOptions =
                this.container =
                this.colorCounter =
                this.clipBox =
                this.chartWidth =
                this.chartHeight =
                this.bounds =
                this.axisOffset =
                this.axes =
                  void 0),
                (this.sharedClips = {}),
                (this.zooming =
                  this.yAxis =
                  this.xAxis =
                  this.userOptions =
                  this.titleOffset =
                  this.time =
                  this.symbolCounter =
                  this.spacingBox =
                  this.spacing =
                    void 0),
                this.getArgs(Q, K, st);
            }
            getArgs(Q, K, st) {
              Z(Q) || Q.nodeName
                ? ((this.renderTo = Q), this.init(K, st))
                : this.init(Q, K);
            }
            setZoomOptions() {
              const Q = this.options.chart,
                K = Q.zooming;
              this.zooming = Object.assign(Object.assign({}, K), {
                type: z(Q.zoomType, K.type),
                key: z(Q.zoomKey, K.key),
                pinchType: z(Q.pinchType, K.pinchType),
                singleTouch: z(Q.zoomBySingleTouch, K.singleTouch, !1),
                resetButton: E(K.resetButton, Q.resetZoomButton),
              });
            }
            init(Q, K) {
              B(this, "init", { args: arguments }, function () {
                const st = E(g, Q),
                  et = st.chart;
                (this.userOptions = I({}, Q)),
                  (this.margin = []),
                  (this.spacing = []),
                  (this.bounds = { h: {}, v: {} }),
                  (this.labelCollectors = []),
                  (this.callback = K),
                  (this.isResizing = 0),
                  (this.options = st),
                  (this.axes = []),
                  (this.series = []),
                  (this.time =
                    Q.time && Object.keys(Q.time).length
                      ? new c(Q.time)
                      : H.time),
                  (this.numberFormatter = et.numberFormatter || C),
                  (this.styledMode = et.styledMode),
                  (this.hasCartesianSeries = et.showAxes),
                  (this.index = j.length),
                  j.push(this),
                  H.chartCount++,
                  P(this, et),
                  (this.xAxis = []),
                  (this.yAxis = []),
                  (this.pointCount =
                    this.colorCounter =
                    this.symbolCounter =
                      0),
                  this.setZoomOptions(),
                  B(this, "afterInit"),
                  this.firstRender();
              });
            }
            initSeries(Q) {
              var K = this.options.chart;
              K = Q.type || K.type;
              const st = o[K];
              return (
                st || L(17, !0, this, { missingModuleFor: K }),
                (K = new st()),
                typeof K.init == "function" && K.init(this, Q),
                K
              );
            }
            setSeriesData() {
              this.getSeriesOrderByLinks().forEach(function (Q) {
                Q.points ||
                  Q.data ||
                  !Q.enabledDataSorting ||
                  Q.setData(Q.options.data, !1);
              });
            }
            getSeriesOrderByLinks() {
              return this.series.concat().sort(function (Q, K) {
                return Q.linkedSeries.length || K.linkedSeries.length
                  ? K.linkedSeries.length - Q.linkedSeries.length
                  : 0;
              });
            }
            orderItems(Q, K = 0) {
              const st = this[Q],
                et = (this.options[Q] = it(this.options[Q]).slice());
              if (
                ((Q = this.userOptions[Q] =
                  this.userOptions[Q] ? it(this.userOptions[Q]).slice() : []),
                this.hasRendered && (et.splice(K), Q.splice(K)),
                st)
              )
                for (let ot = K, lt = st.length; ot < lt; ++ot)
                  (K = st[ot]) &&
                    ((K.index = ot),
                    K instanceof S && (K.name = K.getName()),
                    K.options.isInternal ||
                      ((et[ot] = K.options), (Q[ot] = K.userOptions)));
            }
            isInsidePlot(Q, K, st = {}) {
              const {
                inverted: et,
                plotBox: ot,
                plotLeft: lt,
                plotTop: ht,
                scrollablePlotBox: mt,
              } = this;
              var yt = 0;
              let gt = 0;
              st.visiblePlotOnly &&
                this.scrollingContainer &&
                ({ scrollLeft: yt, scrollTop: gt } = this.scrollingContainer);
              const ft = st.series,
                St = (st.visiblePlotOnly && mt) || ot;
              var bt = st.inverted ? K : Q;
              if (
                ((K = st.inverted ? Q : K),
                (Q = { x: bt, y: K, isInsidePlot: !0, options: st }),
                !st.ignoreX)
              ) {
                const kt = (ft &&
                  (et && !this.polar ? ft.yAxis : ft.xAxis)) || {
                  pos: lt,
                  len: 1 / 0,
                };
                (bt = st.paneCoordinates ? kt.pos + bt : lt + bt),
                  (bt >= Math.max(yt + lt, kt.pos) &&
                    bt <= Math.min(yt + lt + St.width, kt.pos + kt.len)) ||
                    (Q.isInsidePlot = !1);
              }
              return (
                !st.ignoreY &&
                  Q.isInsidePlot &&
                  ((yt = (!et && st.axis && !st.axis.isXAxis && st.axis) ||
                    (ft && (et ? ft.xAxis : ft.yAxis)) || {
                      pos: ht,
                      len: 1 / 0,
                    }),
                  (st = st.paneCoordinates ? yt.pos + K : ht + K),
                  (st >= Math.max(gt + ht, yt.pos) &&
                    st <= Math.min(gt + ht + St.height, yt.pos + yt.len)) ||
                    (Q.isInsidePlot = !1)),
                B(this, "afterIsInsidePlot", Q),
                Q.isInsidePlot
              );
            }
            redraw(Q) {
              B(this, "beforeRedraw");
              const K = this.hasCartesianSeries
                  ? this.axes
                  : this.colorAxis || [],
                st = this.series,
                et = this.pointer,
                ot = this.legend,
                lt = this.userOptions.legend,
                ht = this.renderer,
                mt = ht.isHidden(),
                yt = [];
              let gt,
                ft,
                St = this.isDirtyBox,
                bt = this.isDirtyLegend,
                kt;
              for (
                ht.rootFontSize = ht.boxWrapper.getStyle("font-size"),
                  this.setResponsive && this.setResponsive(!1),
                  d(this.hasRendered ? Q : !1, this),
                  mt && this.temporaryDisplay(),
                  this.layOutTitles(!1),
                  Q = st.length;
                Q--;

              )
                if (
                  ((kt = st[Q]),
                  (kt.options.stacking || kt.options.centerInCategory) &&
                    ((ft = !0), kt.isDirty))
                ) {
                  gt = !0;
                  break;
                }
              if (gt)
                for (Q = st.length; Q--; )
                  (kt = st[Q]), kt.options.stacking && (kt.isDirty = !0);
              st.forEach(function (Ct) {
                Ct.isDirty &&
                  (Ct.options.legendType === "point"
                    ? (typeof Ct.updateTotals == "function" &&
                        Ct.updateTotals(),
                      (bt = !0))
                    : lt && (lt.labelFormatter || lt.labelFormat) && (bt = !0)),
                  Ct.isDirtyData && B(Ct, "updatedData");
              }),
                bt &&
                  ot &&
                  ot.options.enabled &&
                  (ot.render(), (this.isDirtyLegend = !1)),
                ft && this.getStacks(),
                K.forEach(function (Ct) {
                  Ct.updateNames(), Ct.setScale();
                }),
                this.getMargins(),
                K.forEach(function (Ct) {
                  Ct.isDirty && (St = !0);
                }),
                K.forEach(function (Ct) {
                  const ut = Ct.min + "," + Ct.max;
                  Ct.extKey !== ut &&
                    ((Ct.extKey = ut),
                    yt.push(function () {
                      B(
                        Ct,
                        "afterSetExtremes",
                        I(Ct.eventArgs, Ct.getExtremes())
                      ),
                        delete Ct.eventArgs;
                    })),
                    (St || ft) && Ct.redraw();
                }),
                St && this.drawChartBox(),
                B(this, "predraw"),
                st.forEach(function (Ct) {
                  (St || Ct.isDirty) && Ct.visible && Ct.redraw(),
                    (Ct.isDirtyData = !1);
                }),
                et && et.reset(!0),
                ht.draw(),
                B(this, "redraw"),
                B(this, "render"),
                mt && this.temporaryDisplay(!0),
                yt.forEach(function (Ct) {
                  Ct.call();
                });
            }
            get(Q) {
              function K(ot) {
                return ot.id === Q || (ot.options && ot.options.id === Q);
              }
              const st = this.series;
              let et = V(this.axes, K) || V(this.series, K);
              for (let ot = 0; !et && ot < st.length; ot++)
                et = V(st[ot].points || [], K);
              return et;
            }
            getAxes() {
              const Q = this.options;
              B(this, "getAxes");
              for (const K of ["xAxis", "yAxis"]) {
                const st = (Q[K] = it(Q[K] || {}));
                for (const et of st) new O(this, et, K);
              }
              B(this, "afterGetAxes");
            }
            getSelectedPoints() {
              return this.series.reduce(
                (Q, K) => (
                  K.getPointsCollection().forEach((st) => {
                    z(st.selectedStaging, st.selected) && Q.push(st);
                  }),
                  Q
                ),
                []
              );
            }
            getSelectedSeries() {
              return this.series.filter(function (Q) {
                return Q.selected;
              });
            }
            setTitle(Q, K, st) {
              this.applyDescription("title", Q),
                this.applyDescription("subtitle", K),
                this.applyDescription("caption", void 0),
                this.layOutTitles(st);
            }
            applyDescription(Q, K) {
              const st = this,
                et = (this.options[Q] = E(this.options[Q], K));
              let ot = this[Q];
              ot && K && (this[Q] = ot = ot.destroy()),
                et &&
                  !ot &&
                  ((ot = this.renderer
                    .text(et.text, 0, 0, et.useHTML)
                    .attr({
                      align: et.align,
                      class: "highcharts-" + Q,
                      zIndex: et.zIndex || 4,
                    })
                    .add()),
                  (ot.update = function (lt, ht) {
                    st.applyDescription(Q, lt), st.layOutTitles(ht);
                  }),
                  this.styledMode ||
                    ot.css(
                      I(
                        Q === "title"
                          ? { fontSize: this.options.isStock ? "1em" : "1.2em" }
                          : {},
                        et.style
                      )
                    ),
                  (this[Q] = ot));
            }
            layOutTitles(Q = !0) {
              const K = [0, 0, 0],
                st = this.renderer,
                et = this.spacingBox;
              ["title", "subtitle", "caption"].forEach(function (lt) {
                const ht = this[lt],
                  mt = this.options[lt],
                  yt = mt.verticalAlign || "top";
                if (
                  ((lt =
                    lt === "title"
                      ? yt === "top"
                        ? -3
                        : 0
                      : yt === "top"
                      ? K[0] + 2
                      : 0),
                  ht)
                ) {
                  ht.css({
                    width:
                      (mt.width || et.width + (mt.widthAdjust || 0)) + "px",
                  });
                  const gt = st.fontMetrics(ht).b,
                    ft = Math.round(ht.getBBox(mt.useHTML).height);
                  ht.align(
                    I({ y: yt === "bottom" ? gt : lt + gt, height: ft }, mt),
                    !1,
                    "spacingBox"
                  ),
                    mt.floating ||
                      (yt === "top"
                        ? (K[0] = Math.ceil(K[0] + ft))
                        : yt === "bottom" && (K[2] = Math.ceil(K[2] + ft)));
                }
              }, this),
                K[0] &&
                  (this.options.title.verticalAlign || "top") === "top" &&
                  (K[0] += this.options.title.margin),
                K[2] &&
                  this.options.caption.verticalAlign === "bottom" &&
                  (K[2] += this.options.caption.margin);
              const ot =
                !this.titleOffset || this.titleOffset.join(",") !== K.join(",");
              (this.titleOffset = K),
                B(this, "afterLayOutTitles"),
                !this.isDirtyBox &&
                  ot &&
                  ((this.isDirtyBox = this.isDirtyLegend = ot),
                  this.hasRendered && Q && this.isDirtyBox && this.redraw());
            }
            getContainerBox() {
              return {
                width: x(this.renderTo, "width", !0) || 0,
                height: x(this.renderTo, "height", !0) || 0,
              };
            }
            getChartSize() {
              var Q = this.options.chart;
              const K = Q.width;
              Q = Q.height;
              const st = this.getContainerBox();
              (this.chartWidth = Math.max(0, K || st.width || 600)),
                (this.chartHeight = Math.max(
                  0,
                  tt(Q, this.chartWidth) || (1 < st.height ? st.height : 400)
                )),
                (this.containerBox = st);
            }
            temporaryDisplay(Q) {
              let K = this.renderTo;
              if (Q)
                for (; K && K.style; )
                  K.hcOrigStyle && (s(K, K.hcOrigStyle), delete K.hcOrigStyle),
                    K.hcOrigDetached &&
                      (m.body.removeChild(K), (K.hcOrigDetached = !1)),
                    (K = K.parentNode);
              else
                for (
                  ;
                  K &&
                  K.style &&
                  (m.body.contains(K) ||
                    K.parentNode ||
                    ((K.hcOrigDetached = !0), m.body.appendChild(K)),
                  (x(K, "display", !1) === "none" || K.hcOricDetached) &&
                    ((K.hcOrigStyle = {
                      display: K.style.display,
                      height: K.style.height,
                      overflow: K.style.overflow,
                    }),
                    (Q = { display: "block", overflow: "hidden" }),
                    K !== this.renderTo && (Q.height = 0),
                    s(K, Q),
                    K.offsetWidth ||
                      K.style.setProperty("display", "block", "important")),
                  (K = K.parentNode),
                  K !== m.body);

                );
            }
            setClassName(Q) {
              this.container.className = "highcharts-container " + (Q || "");
            }
            getContainer() {
              const Q = this.options,
                K = Q.chart;
              var st = rt();
              let et,
                ot = this.renderTo;
              ot || (this.renderTo = ot = K.renderTo),
                Z(ot) && (this.renderTo = ot = m.getElementById(ot)),
                ot || L(13, !0, this);
              var lt = J(t(ot, "data-highcharts-chart"));
              W(lt) && j[lt] && j[lt].hasRendered && j[lt].destroy(),
                t(ot, "data-highcharts-chart", this.index),
                (ot.innerHTML = f.emptyHTML),
                K.skipClone || ot.offsetWidth || this.temporaryDisplay(),
                this.getChartSize(),
                (lt = this.chartWidth);
              const ht = this.chartHeight;
              if (
                (s(ot, { overflow: "hidden" }),
                this.styledMode ||
                  (et = I(
                    {
                      position: "relative",
                      overflow: "hidden",
                      width: lt + "px",
                      height: ht + "px",
                      textAlign: "left",
                      lineHeight: "normal",
                      zIndex: 0,
                      "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                      userSelect: "none",
                      "touch-action": "manipulation",
                      outline: "none",
                    },
                    K.style || {}
                  )),
                (this.container = st = e("div", { id: st }, et, ot)),
                (this._cursor = st.style.cursor),
                (this.renderer = new (
                  K.renderer || !v ? Y.getRendererType(K.renderer) : D
                )(
                  st,
                  lt,
                  ht,
                  void 0,
                  K.forExport,
                  Q.exporting && Q.exporting.allowHTML,
                  this.styledMode
                )),
                (this.containerBox = this.getContainerBox()),
                d(void 0, this),
                this.setClassName(K.className),
                this.styledMode)
              )
                for (const mt in Q.defs) this.renderer.definition(Q.defs[mt]);
              else this.renderer.setStyle(K.style);
              (this.renderer.chartIndex = this.index),
                B(this, "afterGetContainer");
            }
            getMargins(Q) {
              const { spacing: K, margin: st, titleOffset: et } = this;
              this.resetMargins(),
                et[0] &&
                  !a(st[0]) &&
                  (this.plotTop = Math.max(this.plotTop, et[0] + K[0])),
                et[2] &&
                  !a(st[2]) &&
                  (this.marginBottom = Math.max(
                    this.marginBottom,
                    et[2] + K[2]
                  )),
                this.legend &&
                  this.legend.display &&
                  this.legend.adjustMargins(st, K),
                B(this, "getMargins"),
                Q || this.getAxisMargins();
            }
            getAxisMargins() {
              const Q = this,
                K = (Q.axisOffset = [0, 0, 0, 0]),
                st = Q.colorAxis,
                et = Q.margin,
                ot = function (lt) {
                  lt.forEach(function (ht) {
                    ht.visible && ht.getOffset();
                  });
                };
              Q.hasCartesianSeries ? ot(Q.axes) : st && st.length && ot(st),
                h.forEach(function (lt, ht) {
                  a(et[ht]) || (Q[lt] += K[ht]);
                }),
                Q.setChartSize();
            }
            getOptions() {
              return b(this.userOptions, g);
            }
            reflow(Q) {
              const K = this;
              var st = K.options.chart;
              st = a(st.width) && a(st.height);
              const et = K.containerBox,
                ot = K.getContainerBox();
              delete K.pointer.chartPosition,
                !st &&
                  !K.isPrinting &&
                  et &&
                  ot.width &&
                  ((ot.width !== et.width || ot.height !== et.height) &&
                    (p.clearTimeout(K.reflowTimeout),
                    (K.reflowTimeout = nt(
                      function () {
                        K.container && K.setSize(void 0, void 0, !1);
                      },
                      Q ? 100 : 0
                    ))),
                  (K.containerBox = ot));
            }
            setReflow() {
              const Q = this;
              var K = (st) => {
                var et;
                !((et = Q.options) === null || et === void 0) &&
                  et.chart.reflow &&
                  Q.hasLoaded &&
                  Q.reflow(st);
              };
              typeof ResizeObserver == "function"
                ? new ResizeObserver(K).observe(Q.renderTo)
                : ((K = i(l, "resize", K)), i(this, "destroy", K));
            }
            setSize(Q, K, st) {
              const et = this,
                ot = et.renderer;
              (et.isResizing += 1),
                d(st, et),
                (st = ot.globalAnimation),
                (et.oldChartHeight = et.chartHeight),
                (et.oldChartWidth = et.chartWidth),
                typeof Q < "u" && (et.options.chart.width = Q),
                typeof K < "u" && (et.options.chart.height = K),
                et.getChartSize(),
                et.styledMode ||
                  (st ? u : s)(
                    et.container,
                    {
                      width: et.chartWidth + "px",
                      height: et.chartHeight + "px",
                    },
                    st
                  ),
                et.setChartSize(!0),
                ot.setSize(et.chartWidth, et.chartHeight, st),
                et.axes.forEach(function (lt) {
                  (lt.isDirty = !0), lt.setScale();
                }),
                (et.isDirtyLegend = !0),
                (et.isDirtyBox = !0),
                et.layOutTitles(),
                et.getMargins(),
                et.redraw(st),
                (et.oldChartHeight = null),
                B(et, "resize"),
                nt(function () {
                  et &&
                    B(et, "endResize", null, function () {
                      --et.isResizing;
                    });
                }, n(st).duration);
            }
            setChartSize(Q) {
              var K = this.inverted;
              const st = this.renderer;
              var et = this.chartWidth,
                ot = this.chartHeight;
              const lt = this.options.chart,
                ht = this.spacing,
                mt = this.clipOffset;
              let yt, gt, ft, St;
              (this.plotLeft = yt = Math.round(this.plotLeft)),
                (this.plotTop = gt = Math.round(this.plotTop)),
                (this.plotWidth = ft =
                  Math.max(0, Math.round(et - yt - this.marginRight))),
                (this.plotHeight = St =
                  Math.max(0, Math.round(ot - gt - this.marginBottom))),
                (this.plotSizeX = K ? St : ft),
                (this.plotSizeY = K ? ft : St),
                (this.plotBorderWidth = lt.plotBorderWidth || 0),
                (this.spacingBox = st.spacingBox =
                  {
                    x: ht[3],
                    y: ht[0],
                    width: et - ht[3] - ht[1],
                    height: ot - ht[0] - ht[2],
                  }),
                (this.plotBox = st.plotBox =
                  { x: yt, y: gt, width: ft, height: St }),
                (K = 2 * Math.floor(this.plotBorderWidth / 2)),
                (et = Math.ceil(Math.max(K, mt[3]) / 2)),
                (ot = Math.ceil(Math.max(K, mt[0]) / 2)),
                (this.clipBox = {
                  x: et,
                  y: ot,
                  width: Math.floor(
                    this.plotSizeX - Math.max(K, mt[1]) / 2 - et
                  ),
                  height: Math.max(
                    0,
                    Math.floor(this.plotSizeY - Math.max(K, mt[2]) / 2 - ot)
                  ),
                }),
                Q ||
                  (this.axes.forEach(function (bt) {
                    bt.setAxisSize(), bt.setAxisTranslation();
                  }),
                  st.alignElements()),
                B(this, "afterSetChartSize", { skipAxes: Q });
            }
            resetMargins() {
              B(this, "resetMargins");
              const Q = this,
                K = Q.options.chart;
              ["margin", "spacing"].forEach(function (st) {
                const et = K[st],
                  ot = X(et) ? et : [et, et, et, et];
                ["Top", "Right", "Bottom", "Left"].forEach(function (lt, ht) {
                  Q[st][ht] = z(K[st + lt], ot[ht]);
                });
              }),
                h.forEach(function (st, et) {
                  Q[st] = z(Q.margin[et], Q.spacing[et]);
                }),
                (Q.axisOffset = [0, 0, 0, 0]),
                (Q.clipOffset = [0, 0, 0, 0]);
            }
            drawChartBox() {
              const Q = this.options.chart,
                K = this.renderer,
                st = this.chartWidth,
                et = this.chartHeight,
                ot = this.styledMode,
                lt = this.plotBGImage;
              var ht = Q.backgroundColor;
              const mt = Q.plotBackgroundColor,
                yt = Q.plotBackgroundImage,
                gt = this.plotLeft,
                ft = this.plotTop,
                St = this.plotWidth,
                bt = this.plotHeight,
                kt = this.plotBox,
                Ct = this.clipRect,
                ut = this.clipBox;
              let Tt = this.chartBackground,
                Rt = this.plotBackground,
                Yt = this.plotBorder,
                It,
                Wt,
                Ht = "animate";
              Tt ||
                ((this.chartBackground = Tt =
                  K.rect().addClass("highcharts-background").add()),
                (Ht = "attr")),
                ot
                  ? (It = Wt = Tt.strokeWidth())
                  : ((It = Q.borderWidth || 0),
                    (Wt = It + (Q.shadow ? 8 : 0)),
                    (ht = { fill: ht || "none" }),
                    (It || Tt["stroke-width"]) &&
                      ((ht.stroke = Q.borderColor), (ht["stroke-width"] = It)),
                    Tt.attr(ht).shadow(Q.shadow)),
                Tt[Ht]({
                  x: Wt / 2,
                  y: Wt / 2,
                  width: st - Wt - (It % 2),
                  height: et - Wt - (It % 2),
                  r: Q.borderRadius,
                }),
                (Ht = "animate"),
                Rt ||
                  ((Ht = "attr"),
                  (this.plotBackground = Rt =
                    K.rect().addClass("highcharts-plot-background").add())),
                Rt[Ht](kt),
                ot ||
                  (Rt.attr({ fill: mt || "none" }).shadow(Q.plotShadow),
                  yt &&
                    (lt
                      ? (yt !== lt.attr("href") && lt.attr("href", yt),
                        lt.animate(kt))
                      : (this.plotBGImage = K.image(
                          yt,
                          gt,
                          ft,
                          St,
                          bt
                        ).add()))),
                Ct
                  ? Ct.animate({ width: ut.width, height: ut.height })
                  : (this.clipRect = K.clipRect(ut)),
                (Ht = "animate"),
                Yt ||
                  ((Ht = "attr"),
                  (this.plotBorder = Yt =
                    K.rect()
                      .addClass("highcharts-plot-border")
                      .attr({ zIndex: 1 })
                      .add())),
                ot ||
                  Yt.attr({
                    stroke: Q.plotBorderColor,
                    "stroke-width": Q.plotBorderWidth || 0,
                    fill: "none",
                  }),
                Yt[Ht](
                  Yt.crisp(
                    { x: gt, y: ft, width: St, height: bt },
                    -Yt.strokeWidth()
                  )
                ),
                (this.isDirtyBox = !1),
                B(this, "afterDrawChartBox");
            }
            propFromSeries() {
              const Q = this,
                K = Q.options.chart,
                st = Q.options.series;
              let et, ot, lt;
              ["inverted", "angular", "polar"].forEach(function (ht) {
                for (
                  ot = o[K.type],
                    lt = K[ht] || (ot && ot.prototype[ht]),
                    et = st && st.length;
                  !lt && et--;

                )
                  (ot = o[st[et].type]) && ot.prototype[ht] && (lt = !0);
                Q[ht] = lt;
              });
            }
            linkSeries(Q) {
              const K = this,
                st = K.series;
              st.forEach(function (et) {
                et.linkedSeries.length = 0;
              }),
                st.forEach(function (et) {
                  let ot = et.options.linkedTo;
                  Z(ot) &&
                    (ot =
                      ot === ":previous"
                        ? K.series[et.index - 1]
                        : K.get(ot)) &&
                    ot.linkedParent !== et &&
                    (ot.linkedSeries.push(et),
                    (et.linkedParent = ot),
                    ot.enabledDataSorting && et.setDataSortingOptions(),
                    (et.visible = z(
                      et.options.visible,
                      ot.options.visible,
                      et.visible
                    )));
                }),
                B(this, "afterLinkSeries", { isUpdating: Q });
            }
            renderSeries() {
              this.series.forEach(function (Q) {
                Q.translate(), Q.render();
              });
            }
            render() {
              const Q = this.axes,
                K = this.colorAxis,
                st = this.renderer,
                et = function (gt) {
                  gt.forEach(function (ft) {
                    ft.visible && ft.render();
                  });
                };
              let ot = 0;
              this.setTitle(),
                B(this, "beforeMargins"),
                this.getStacks && this.getStacks(),
                this.getMargins(!0),
                this.setChartSize();
              const lt = this.plotWidth;
              Q.some(function (gt) {
                if (
                  gt.horiz &&
                  gt.visible &&
                  gt.options.labels.enabled &&
                  gt.series.length
                )
                  return (ot = 21), !0;
              });
              const ht = (this.plotHeight = Math.max(this.plotHeight - ot, 0));
              Q.forEach(function (gt) {
                gt.setScale();
              }),
                this.getAxisMargins();
              const mt = 1.1 < lt / this.plotWidth,
                yt = 1.05 < ht / this.plotHeight;
              (mt || yt) &&
                (Q.forEach(function (gt) {
                  ((gt.horiz && mt) || (!gt.horiz && yt)) &&
                    gt.setTickInterval(!0);
                }),
                this.getMargins()),
                this.drawChartBox(),
                this.hasCartesianSeries ? et(Q) : K && K.length && et(K),
                this.seriesGroup ||
                  (this.seriesGroup = st
                    .g("series-group")
                    .attr({ zIndex: 3 })
                    .shadow(this.options.chart.seriesGroupShadow)
                    .add()),
                this.renderSeries(),
                this.addCredits(),
                this.setResponsive && this.setResponsive(),
                (this.hasRendered = !0);
            }
            addCredits(Q) {
              const K = this,
                st = E(!0, this.options.credits, Q);
              st.enabled &&
                !this.credits &&
                ((this.credits = this.renderer
                  .text(st.text + (this.mapCredits || ""), 0, 0)
                  .addClass("highcharts-credits")
                  .on("click", function () {
                    st.href && (l.location.href = st.href);
                  })
                  .attr({ align: st.position.align, zIndex: 8 })),
                K.styledMode || this.credits.css(st.style),
                this.credits.add().align(st.position),
                (this.credits.update = function (et) {
                  (K.credits = K.credits.destroy()), K.addCredits(et);
                }));
            }
            destroy() {
              const Q = this,
                K = Q.axes,
                st = Q.series,
                et = Q.container,
                ot = et && et.parentNode;
              let lt;
              for (
                B(Q, "destroy"),
                  Q.renderer.forExport ? w(j, Q) : (j[Q.index] = void 0),
                  H.chartCount--,
                  Q.renderTo.removeAttribute("data-highcharts-chart"),
                  $(Q),
                  lt = K.length;
                lt--;

              )
                K[lt] = K[lt].destroy();
              for (
                this.scroller &&
                  this.scroller.destroy &&
                  this.scroller.destroy(),
                  lt = st.length;
                lt--;

              )
                st[lt] = st[lt].destroy();
              "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer"
                .split(" ")
                .forEach(function (ht) {
                  const mt = Q[ht];
                  mt && mt.destroy && (Q[ht] = mt.destroy());
                }),
                et && ((et.innerHTML = f.emptyHTML), $(et), ot && r(et)),
                _(Q, function (ht, mt) {
                  delete Q[mt];
                });
            }
            firstRender() {
              const Q = this,
                K = Q.options;
              Q.getContainer(),
                Q.resetMargins(),
                Q.setChartSize(),
                Q.propFromSeries(),
                Q.getAxes();
              const st = R(K.series) ? K.series : [];
              (K.series = []),
                st.forEach(function (et) {
                  Q.initSeries(et);
                }),
                Q.linkSeries(),
                Q.setSeriesData(),
                B(Q, "beforeRender"),
                Q.render(),
                Q.pointer.getChartPosition(),
                !Q.renderer.imgCount && !Q.hasLoaded && Q.onload(),
                Q.temporaryDisplay(!0);
            }
            onload() {
              this.callbacks.concat([this.callback]).forEach(function (Q) {
                Q && typeof this.index < "u" && Q.apply(this, [this]);
              }, this),
                B(this, "load"),
                B(this, "render"),
                a(this.index) && this.setReflow(),
                this.warnIfA11yModuleNotLoaded(),
                (this.hasLoaded = !0);
            }
            warnIfA11yModuleNotLoaded() {
              const { options: Q, title: K } = this;
              Q &&
                !this.accessibility &&
                (this.renderer.boxWrapper.attr({
                  role: "img",
                  "aria-label": ((K && K.element.textContent) || "").replace(
                    /</g,
                    "&lt;"
                  ),
                }),
                (Q.accessibility && Q.accessibility.enabled === !1) ||
                  L(
                    'Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.',
                    !1,
                    this
                  ));
            }
            addSeries(Q, K, st) {
              const et = this;
              let ot;
              return (
                Q &&
                  ((K = z(K, !0)),
                  B(et, "addSeries", { options: Q }, function () {
                    (ot = et.initSeries(Q)),
                      (et.isDirtyLegend = !0),
                      et.linkSeries(),
                      ot.enabledDataSorting && ot.setData(Q.data, !1),
                      B(et, "afterAddSeries", { series: ot }),
                      K && et.redraw(st);
                  })),
                ot
              );
            }
            addAxis(Q, K, st, et) {
              return this.createAxis(K ? "xAxis" : "yAxis", {
                axis: Q,
                redraw: st,
                animation: et,
              });
            }
            addColorAxis(Q, K, st) {
              return this.createAxis("colorAxis", {
                axis: Q,
                redraw: K,
                animation: st,
              });
            }
            createAxis(Q, K) {
              return (
                (Q = new O(this, K.axis, Q)),
                z(K.redraw, !0) && this.redraw(K.animation),
                Q
              );
            }
            showLoading(Q) {
              const K = this,
                st = K.options,
                et = st.loading,
                ot = function () {
                  lt &&
                    s(lt, {
                      left: K.plotLeft + "px",
                      top: K.plotTop + "px",
                      width: K.plotWidth + "px",
                      height: K.plotHeight + "px",
                    });
                };
              let lt = K.loadingDiv,
                ht = K.loadingSpan;
              lt ||
                (K.loadingDiv = lt =
                  e(
                    "div",
                    {
                      className: "highcharts-loading highcharts-loading-hidden",
                    },
                    null,
                    K.container
                  )),
                ht ||
                  ((K.loadingSpan = ht =
                    e(
                      "span",
                      { className: "highcharts-loading-inner" },
                      null,
                      lt
                    )),
                  i(K, "redraw", ot)),
                (lt.className = "highcharts-loading"),
                f.setElementHTML(ht, z(Q, st.lang.loading, "")),
                K.styledMode ||
                  (s(lt, I(et.style, { zIndex: 10 })),
                  s(ht, et.labelStyle),
                  K.loadingShown ||
                    (s(lt, { opacity: 0, display: "" }),
                    u(
                      lt,
                      { opacity: et.style.opacity || 0.5 },
                      { duration: et.showDuration || 0 }
                    ))),
                (K.loadingShown = !0),
                ot();
            }
            hideLoading() {
              const Q = this.options,
                K = this.loadingDiv;
              K &&
                ((K.className = "highcharts-loading highcharts-loading-hidden"),
                this.styledMode ||
                  u(
                    K,
                    { opacity: 0 },
                    {
                      duration: Q.loading.hideDuration || 100,
                      complete: function () {
                        s(K, { display: "none" });
                      },
                    }
                  )),
                (this.loadingShown = !1);
            }
            update(Q, K, st, et) {
              const ot = this,
                lt = {
                  credits: "addCredits",
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption",
                },
                ht = Q.isResponsiveOptions,
                mt = [];
              let yt, gt;
              B(ot, "update", { options: Q }),
                ht || ot.setResponsive(!1, !0),
                (Q = b(Q, ot.options)),
                (ot.userOptions = E(ot.userOptions, Q));
              var ft = Q.chart;
              if (ft) {
                if (
                  (E(!0, ot.options.chart, ft),
                  this.setZoomOptions(),
                  "className" in ft && ot.setClassName(ft.className),
                  "inverted" in ft || "polar" in ft || "type" in ft)
                ) {
                  ot.propFromSeries();
                  var St = !0;
                }
                "alignTicks" in ft && (St = !0),
                  "events" in ft && P(this, ft),
                  _(ft, function (bt, kt) {
                    ot.propsRequireUpdateSeries.indexOf("chart." + kt) !== -1 &&
                      (yt = !0),
                      ot.propsRequireDirtyBox.indexOf(kt) !== -1 &&
                        (ot.isDirtyBox = !0),
                      ot.propsRequireReflow.indexOf(kt) !== -1 &&
                        (ht ? (ot.isDirtyBox = !0) : (gt = !0));
                  }),
                  !ot.styledMode &&
                    ft.style &&
                    ot.renderer.setStyle(ot.options.chart.style || {});
              }
              !ot.styledMode && Q.colors && (this.options.colors = Q.colors),
                Q.time &&
                  (this.time === M && (this.time = new c(Q.time)),
                  E(!0, ot.options.time, Q.time)),
                _(Q, function (bt, kt) {
                  ot[kt] && typeof ot[kt].update == "function"
                    ? ot[kt].update(bt, !1)
                    : typeof ot[lt[kt]] == "function"
                    ? ot[lt[kt]](bt)
                    : kt !== "colors" &&
                      ot.collectionsWithUpdate.indexOf(kt) === -1 &&
                      E(!0, ot.options[kt], Q[kt]),
                    kt !== "chart" &&
                      ot.propsRequireUpdateSeries.indexOf(kt) !== -1 &&
                      (yt = !0);
                }),
                this.collectionsWithUpdate.forEach(function (bt) {
                  Q[bt] &&
                    (it(Q[bt]).forEach(function (kt, Ct) {
                      const ut = a(kt.id);
                      let Tt;
                      ut && (Tt = ot.get(kt.id)),
                        !Tt &&
                          ot[bt] &&
                          (Tt = ot[bt][z(kt.index, Ct)]) &&
                          ((ut && a(Tt.options.id)) || Tt.options.isInternal) &&
                          (Tt = void 0),
                        Tt &&
                          Tt.coll === bt &&
                          (Tt.update(kt, !1), st && (Tt.touched = !0)),
                        !Tt &&
                          st &&
                          ot.collectionsWithInit[bt] &&
                          (ot.collectionsWithInit[bt][0].apply(
                            ot,
                            [kt]
                              .concat(ot.collectionsWithInit[bt][1] || [])
                              .concat([!1])
                          ).touched = !0);
                    }),
                    st &&
                      ot[bt].forEach(function (kt) {
                        kt.touched || kt.options.isInternal
                          ? delete kt.touched
                          : mt.push(kt);
                      }));
                }),
                mt.forEach(function (bt) {
                  bt.chart && bt.remove && bt.remove(!1);
                }),
                St &&
                  ot.axes.forEach(function (bt) {
                    bt.update({}, !1);
                  }),
                yt &&
                  ot.getSeriesOrderByLinks().forEach(function (bt) {
                    bt.chart && bt.update({}, !1);
                  }, this),
                (St = ft && ft.width),
                (ft =
                  ft &&
                  (Z(ft.height)
                    ? tt(ft.height, St || ot.chartWidth)
                    : ft.height)),
                gt ||
                (W(St) && St !== ot.chartWidth) ||
                (W(ft) && ft !== ot.chartHeight)
                  ? ot.setSize(St, ft, et)
                  : z(K, !0) && ot.redraw(et),
                B(ot, "afterUpdate", { options: Q, redraw: K, animation: et });
            }
            setSubtitle(Q, K) {
              this.applyDescription("subtitle", Q), this.layOutTitles(K);
            }
            setCaption(Q, K) {
              this.applyDescription("caption", Q), this.layOutTitles(K);
            }
            showResetZoom() {
              function Q() {
                K.zoomOut();
              }
              const K = this,
                st = g.lang,
                et = K.zooming.resetButton,
                ot = et.theme,
                lt =
                  et.relativeTo === "chart" || et.relativeTo === "spacingBox"
                    ? null
                    : "scrollablePlotBox";
              B(this, "beforeShowResetZoom", null, function () {
                K.resetZoomButton = K.renderer
                  .button(st.resetZoom, null, null, Q, ot)
                  .attr({ align: et.position.align, title: st.resetZoomTitle })
                  .addClass("highcharts-reset-zoom")
                  .add()
                  .align(et.position, !1, lt);
              }),
                B(this, "afterShowResetZoom");
            }
            zoomOut() {
              B(this, "selection", { resetSelection: !0 }, this.zoom);
            }
            zoom(Q) {
              const K = this,
                st = K.pointer;
              let et = !1,
                ot;
              !Q || Q.resetSelection
                ? (K.axes.forEach(function (ht) {
                    ot = ht.zoom();
                  }),
                  (st.initiated = !1))
                : Q.xAxis.concat(Q.yAxis).forEach(function (ht) {
                    const mt = ht.axis;
                    ((st[mt.isXAxis ? "zoomX" : "zoomY"] &&
                      a(st.mouseDownX) &&
                      a(st.mouseDownY) &&
                      K.isInsidePlot(
                        st.mouseDownX - K.plotLeft,
                        st.mouseDownY - K.plotTop,
                        { axis: mt }
                      )) ||
                      !a(K.inverted ? st.mouseDownX : st.mouseDownY)) &&
                      ((ot = mt.zoom(ht.min, ht.max)),
                      mt.displayBtn && (et = !0));
                  });
              const lt = K.resetZoomButton;
              et && !lt
                ? K.showResetZoom()
                : !et && X(lt) && (K.resetZoomButton = lt.destroy()),
                ot &&
                  K.redraw(
                    z(
                      K.options.chart.animation,
                      Q && Q.animation,
                      100 > K.pointCount
                    )
                  );
            }
            pan(Q, K) {
              const st = this,
                et = st.hoverPoints;
              K = typeof K == "object" ? K : { enabled: K, type: "x" };
              const ot = st.options.chart;
              ot && ot.panning && (ot.panning = K);
              const lt = K.type;
              let ht;
              B(this, "pan", { originalEvent: Q }, function () {
                et &&
                  et.forEach(function (gt) {
                    gt.setState();
                  });
                let mt = st.xAxis;
                lt === "xy"
                  ? (mt = mt.concat(st.yAxis))
                  : lt === "y" && (mt = st.yAxis);
                const yt = {};
                mt.forEach(function (gt) {
                  if (gt.options.panningEnabled && !gt.options.isInternal) {
                    var ft = gt.horiz,
                      St = Q[ft ? "chartX" : "chartY"];
                    ft = ft ? "mouseDownX" : "mouseDownY";
                    var bt = st[ft],
                      kt = gt.minPointOffset || 0,
                      Ct =
                        (gt.reversed && !st.inverted) ||
                        (!gt.reversed && st.inverted)
                          ? -1
                          : 1,
                      ut = gt.getExtremes(),
                      Tt = gt.toValue(bt - St, !0) + kt * Ct,
                      Rt =
                        gt.toValue(bt + gt.len - St, !0) -
                        (kt * Ct || (gt.isXAxis && gt.pointRangePadding) || 0),
                      Yt = Rt < Tt;
                    (Ct = gt.hasVerticalPanning()),
                      (bt = Yt ? Rt : Tt),
                      (Tt = Yt ? Tt : Rt);
                    var It = gt.panningState;
                    !Ct ||
                      gt.isXAxis ||
                      (It && !It.isDirty) ||
                      gt.series.forEach(function (Wt) {
                        var Ht = Wt.getProcessedData(!0);
                        (Ht = Wt.getExtremes(Ht.yData, !0)),
                          It ||
                            (It = {
                              startMin: Number.MAX_VALUE,
                              startMax: -Number.MAX_VALUE,
                            }),
                          W(Ht.dataMin) &&
                            W(Ht.dataMax) &&
                            ((It.startMin = Math.min(
                              z(Wt.options.threshold, 1 / 0),
                              Ht.dataMin,
                              It.startMin
                            )),
                            (It.startMax = Math.max(
                              z(Wt.options.threshold, -1 / 0),
                              Ht.dataMax,
                              It.startMax
                            )));
                      }),
                      (Ct = Math.min(
                        z(It && It.startMin, ut.dataMin),
                        kt
                          ? ut.min
                          : gt.toValue(gt.toPixels(ut.min) - gt.minPixelPadding)
                      )),
                      (Rt = Math.max(
                        z(It && It.startMax, ut.dataMax),
                        kt
                          ? ut.max
                          : gt.toValue(gt.toPixels(ut.max) + gt.minPixelPadding)
                      )),
                      (gt.panningState = It),
                      gt.isOrdinal ||
                        ((kt = Ct - bt),
                        0 < kt && ((Tt += kt), (bt = Ct)),
                        (kt = Tt - Rt),
                        0 < kt && ((Tt = Rt), (bt -= kt)),
                        gt.series.length &&
                          bt !== ut.min &&
                          Tt !== ut.max &&
                          bt >= Ct &&
                          Tt <= Rt &&
                          (gt.setExtremes(bt, Tt, !1, !1, { trigger: "pan" }),
                          !st.resetZoomButton &&
                            bt !== Ct &&
                            Tt !== Rt &&
                            lt.match("y") &&
                            (st.showResetZoom(), (gt.displayBtn = !1)),
                          (ht = !0)),
                        (yt[ft] = St));
                  }
                }),
                  _(yt, (gt, ft) => {
                    st[ft] = gt;
                  }),
                  ht && st.redraw(!1),
                  s(st.container, { cursor: "move" });
              });
            }
          }
          return (
            I(at.prototype, {
              callbacks: [],
              collectionsWithInit: {
                xAxis: [at.prototype.addAxis, [!0]],
                yAxis: [at.prototype.addAxis, [!1]],
                series: [at.prototype.addSeries],
              },
              collectionsWithUpdate: ["xAxis", "yAxis", "series"],
              propsRequireDirtyBox:
                "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(
                  " "
                ),
              propsRequireReflow:
                "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(
                  " "
                ),
              propsRequireUpdateSeries:
                "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(
                  " "
                ),
            }),
            at
          );
        }
      ),
      T(
        y,
        "Extensions/ScrollablePlotArea.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Axis/Axis.js"],
          y["Core/Chart/Chart.js"],
          y["Core/Series/Series.js"],
          y["Core/Renderer/RendererRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H) {
          const { stop: Y } = A,
            {
              addEvent: S,
              createElement: N,
              defined: D,
              merge: c,
              pick: p,
            } = H;
          S(F, "afterSetChartSize", function (f) {
            var u = this.options.chart.scrollablePlotArea,
              n = u && u.minWidth;
            u = u && u.minHeight;
            let d;
            this.renderer.forExport ||
              (n
                ? (this.scrollablePixelsX = n =
                    Math.max(0, n - this.chartWidth)) &&
                  ((this.scrollablePlotBox = this.renderer.scrollablePlotBox =
                    c(this.plotBox)),
                  (this.plotBox.width = this.plotWidth += n),
                  this.inverted
                    ? (this.clipBox.height += n)
                    : (this.clipBox.width += n),
                  (d = { 1: { name: "right", value: n } }))
                : u &&
                  ((this.scrollablePixelsY = n =
                    Math.max(0, u - this.chartHeight)),
                  D(n) &&
                    ((this.scrollablePlotBox = this.renderer.scrollablePlotBox =
                      c(this.plotBox)),
                    (this.plotBox.height = this.plotHeight += n),
                    this.inverted
                      ? (this.clipBox.width += n)
                      : (this.clipBox.height += n),
                    (d = { 2: { name: "bottom", value: n } }))),
              d &&
                !f.skipAxes &&
                this.axes.forEach(function (g) {
                  d[g.side]
                    ? (g.getPlotLinePath = function () {
                        let M = d[g.side].name,
                          C = this[M],
                          P;
                        return (
                          (this[M] = C - d[g.side].value),
                          (P = O.prototype.getPlotLinePath.apply(
                            this,
                            arguments
                          )),
                          (this[M] = C),
                          P
                        );
                      })
                    : (g.setAxisSize(), g.setAxisTranslation());
                }));
          }),
            S(F, "render", function () {
              this.scrollablePixelsX || this.scrollablePixelsY
                ? (this.setUpScrolling && this.setUpScrolling(),
                  this.applyFixed())
                : this.fixedDiv && this.applyFixed();
            }),
            (F.prototype.setUpScrolling = function () {
              const f = {
                WebkitOverflowScrolling: "touch",
                overflowX: "hidden",
                overflowY: "hidden",
              };
              this.scrollablePixelsX && (f.overflowX = "auto"),
                this.scrollablePixelsY && (f.overflowY = "auto"),
                (this.scrollingParent = N(
                  "div",
                  { className: "highcharts-scrolling-parent" },
                  { position: "relative" },
                  this.renderTo
                )),
                (this.scrollingContainer = N(
                  "div",
                  { className: "highcharts-scrolling" },
                  f,
                  this.scrollingParent
                ));
              let u;
              S(this.scrollingContainer, "scroll", () => {
                this.pointer &&
                  (delete this.pointer.chartPosition,
                  this.hoverPoint && (u = this.hoverPoint),
                  this.pointer.runPointActions(void 0, u, !0));
              }),
                (this.innerContainer = N(
                  "div",
                  { className: "highcharts-inner-container" },
                  null,
                  this.scrollingContainer
                )),
                this.innerContainer.appendChild(this.container),
                (this.setUpScrolling = null);
            }),
            (F.prototype.moveFixedElements = function () {
              let f = this.container,
                u = this.fixedRenderer,
                n =
                  ".highcharts-breadcrumbs-group .highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(
                    " "
                  ),
                d;
              this.scrollablePixelsX && !this.inverted
                ? (d = ".highcharts-yaxis")
                : (this.scrollablePixelsX && this.inverted) ||
                  (this.scrollablePixelsY && !this.inverted)
                ? (d = ".highcharts-xaxis")
                : this.scrollablePixelsY &&
                  this.inverted &&
                  (d = ".highcharts-yaxis"),
                d &&
                  n.push(
                    `${d}:not(.highcharts-radial-axis)`,
                    `${d}-labels:not(.highcharts-radial-axis-labels)`
                  ),
                n.forEach(function (g) {
                  [].forEach.call(f.querySelectorAll(g), function (M) {
                    (M.namespaceURI === u.SVG_NS
                      ? u.box
                      : u.box.parentNode
                    ).appendChild(M),
                      (M.style.pointerEvents = "auto");
                  });
                });
            }),
            (F.prototype.applyFixed = function () {
              var f = !this.fixedDiv,
                u = this.options.chart,
                n = u.scrollablePlotArea,
                d = U.getRendererType();
              f
                ? ((this.fixedDiv = N(
                    "div",
                    { className: "highcharts-fixed" },
                    {
                      position: "absolute",
                      overflow: "hidden",
                      pointerEvents: "none",
                      zIndex: ((u.style && u.style.zIndex) || 0) + 2,
                      top: 0,
                    },
                    null,
                    !0
                  )),
                  this.scrollingContainer &&
                    this.scrollingContainer.parentNode.insertBefore(
                      this.fixedDiv,
                      this.scrollingContainer
                    ),
                  (this.renderTo.style.overflow = "visible"),
                  (this.fixedRenderer = u =
                    new d(
                      this.fixedDiv,
                      this.chartWidth,
                      this.chartHeight,
                      this.options.chart.style
                    )),
                  (this.scrollableMask = u
                    .path()
                    .attr({
                      fill: this.options.chart.backgroundColor || "#fff",
                      "fill-opacity": p(n.opacity, 0.85),
                      zIndex: -1,
                    })
                    .addClass("highcharts-scrollable-mask")
                    .add()),
                  S(this, "afterShowResetZoom", this.moveFixedElements),
                  S(this, "afterApplyDrilldown", this.moveFixedElements),
                  S(this, "afterLayOutTitles", this.moveFixedElements))
                : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight),
                (this.scrollableDirty || f) &&
                  ((this.scrollableDirty = !1), this.moveFixedElements()),
                (u = this.chartWidth + (this.scrollablePixelsX || 0)),
                (d = this.chartHeight + (this.scrollablePixelsY || 0)),
                Y(this.container),
                (this.container.style.width = u + "px"),
                (this.container.style.height = d + "px"),
                this.renderer.boxWrapper.attr({
                  width: u,
                  height: d,
                  viewBox: [0, 0, u, d].join(" "),
                }),
                this.chartBackground.attr({ width: u, height: d }),
                (this.scrollingContainer.style.height =
                  this.chartHeight + "px"),
                f &&
                  (n.scrollPositionX &&
                    (this.scrollingContainer.scrollLeft =
                      this.scrollablePixelsX * n.scrollPositionX),
                  n.scrollPositionY &&
                    (this.scrollingContainer.scrollTop =
                      this.scrollablePixelsY * n.scrollPositionY)),
                (d = this.axisOffset),
                (f = this.plotTop - d[0] - 1),
                (n = this.plotLeft - d[3] - 1),
                (u = this.plotTop + this.plotHeight + d[2] + 1),
                (d = this.plotLeft + this.plotWidth + d[1] + 1);
              let g =
                  this.plotLeft +
                  this.plotWidth -
                  (this.scrollablePixelsX || 0),
                M =
                  this.plotTop +
                  this.plotHeight -
                  (this.scrollablePixelsY || 0);
              (f = this.scrollablePixelsX
                ? [
                    ["M", 0, f],
                    ["L", this.plotLeft - 1, f],
                    ["L", this.plotLeft - 1, u],
                    ["L", 0, u],
                    ["Z"],
                    ["M", g, f],
                    ["L", this.chartWidth, f],
                    ["L", this.chartWidth, u],
                    ["L", g, u],
                    ["Z"],
                  ]
                : this.scrollablePixelsY
                ? [
                    ["M", n, 0],
                    ["L", n, this.plotTop - 1],
                    ["L", d, this.plotTop - 1],
                    ["L", d, 0],
                    ["Z"],
                    ["M", n, M],
                    ["L", n, this.chartHeight],
                    ["L", d, this.chartHeight],
                    ["L", d, M],
                    ["Z"],
                  ]
                : [["M", 0, 0]]),
                this.redrawTrigger !== "adjustHeight" &&
                  this.scrollableMask.attr({ d: f });
            }),
            S(O, "afterInit", function () {
              this.chart.scrollableDirty = !0;
            }),
            S(G, "show", function () {
              this.chart.scrollableDirty = !0;
            });
        }
      ),
      T(
        y,
        "Core/Axis/Stacking/StackItem.js",
        [
          y["Core/Templating.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { format: G } = A,
            { series: U } = O,
            {
              destroyObjectProperties: H,
              fireEvent: Y,
              isNumber: S,
              pick: N,
            } = F;
          class D {
            constructor(p, f, u, n, d) {
              const g = p.chart.inverted,
                M = p.reversed;
              (this.axis = p),
                (p = this.isNegative = !!u != !!M),
                (this.options = f = f || {}),
                (this.x = n),
                (this.cumulative = this.total = null),
                (this.points = {}),
                (this.hasValidPoints = !1),
                (this.stack = d),
                (this.rightCliff = this.leftCliff = 0),
                (this.alignOptions = {
                  align: f.align || (g ? (p ? "left" : "right") : "center"),
                  verticalAlign:
                    f.verticalAlign || (g ? "middle" : p ? "bottom" : "top"),
                  y: f.y,
                  x: f.x,
                }),
                (this.textAlign =
                  f.textAlign || (g ? (p ? "right" : "left") : "center"));
            }
            destroy() {
              H(this, this.axis);
            }
            render(p) {
              const f = this.axis.chart,
                u = this.options;
              var n = u.format;
              (n = n ? G(n, this, f) : u.formatter.call(this)),
                this.label
                  ? this.label.attr({ text: n, visibility: "hidden" })
                  : ((this.label = f.renderer.label(
                      n,
                      null,
                      void 0,
                      u.shape,
                      void 0,
                      void 0,
                      u.useHTML,
                      !1,
                      "stack-labels"
                    )),
                    (n = {
                      r: u.borderRadius || 0,
                      text: n,
                      padding: N(u.padding, 5),
                      visibility: "hidden",
                    }),
                    f.styledMode ||
                      ((n.fill = u.backgroundColor),
                      (n.stroke = u.borderColor),
                      (n["stroke-width"] = u.borderWidth),
                      this.label.css(u.style || {})),
                    this.label.attr(n),
                    this.label.added || this.label.add(p)),
                (this.label.labelrank = f.plotSizeY),
                Y(this, "afterRender");
            }
            setOffset(p, f, u, n, d, g) {
              const {
                  alignOptions: M,
                  axis: C,
                  label: P,
                  options: j,
                  textAlign: m,
                } = this,
                h = C.chart;
              u = this.getStackBox({
                xOffset: p,
                width: f,
                boxBottom: u,
                boxTop: n,
                defaultX: d,
                xAxis: g,
              });
              var { verticalAlign: v } = M;
              if (P && u) {
                (n = P.getBBox()),
                  (d = P.padding),
                  (g = N(j.overflow, "justify") === "justify"),
                  (M.x = j.x || 0),
                  (M.y = j.y || 0);
                const { x: l, y: o } = this.adjustStackPosition({
                  labelBox: n,
                  verticalAlign: v,
                  textAlign: m,
                });
                (u.x -= l),
                  (u.y -= o),
                  P.align(M, !1, u),
                  (v = h.isInsidePlot(
                    P.alignAttr.x + M.x + l,
                    P.alignAttr.y + M.y + o
                  )) || (g = !1),
                  g &&
                    U.prototype.justifyDataLabel.call(
                      C,
                      P,
                      M,
                      P.alignAttr,
                      n,
                      u
                    ),
                  P.attr({
                    x: P.alignAttr.x,
                    y: P.alignAttr.y,
                    rotation: j.rotation,
                    rotationOriginX: n.width / 2,
                    rotationOriginY: n.height / 2,
                  }),
                  N(!g && j.crop, !0) &&
                    (v =
                      S(P.x) &&
                      S(P.y) &&
                      h.isInsidePlot(P.x - d + P.width, P.y) &&
                      h.isInsidePlot(P.x + d, P.y)),
                  P[v ? "show" : "hide"]();
              }
              Y(this, "afterSetOffset", { xOffset: p, width: f });
            }
            adjustStackPosition({
              labelBox: p,
              verticalAlign: f,
              textAlign: u,
            }) {
              const n = {
                bottom: 0,
                middle: 1,
                top: 2,
                right: 1,
                center: 0,
                left: -1,
              };
              return {
                x: p.width / 2 + (p.width / 2) * n[u],
                y: (p.height / 2) * n[f],
              };
            }
            getStackBox(p) {
              var f = this.axis;
              const u = f.chart,
                {
                  boxTop: n,
                  defaultX: d,
                  xOffset: g,
                  width: M,
                  boxBottom: C,
                } = p;
              var P = f.stacking.usePercentage ? 100 : N(n, this.total, 0);
              (P = f.toPixels(P)), (p = p.xAxis || u.xAxis[0]);
              const j = N(d, p.translate(this.x)) + g;
              (f = f.toPixels(
                C ||
                  (S(f.min) && f.logarithmic && f.logarithmic.lin2log(f.min)) ||
                  0
              )),
                (f = Math.abs(P - f));
              const m = this.isNegative;
              return u.inverted
                ? {
                    x: (m ? P : P - f) - u.plotLeft,
                    y: p.height - j - M,
                    width: f,
                    height: M,
                  }
                : {
                    x: j + p.transB - u.plotLeft,
                    y: (m ? P - f : P) - u.plotTop,
                    width: M,
                    height: f,
                  };
            }
          }
          return D;
        }
      ),
      T(
        y,
        "Core/Axis/Stacking/StackingAxis.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Axis/Axis.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Axis/Stacking/StackItem.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U) {
          function H() {
            const i = this,
              t = i.inverted;
            i.yAxis.forEach((e) => {
              e.stacking &&
                e.stacking.stacks &&
                e.hasVisibleSeries &&
                (e.stacking.oldStacks = e.stacking.stacks);
            }),
              i.series.forEach((e) => {
                const s = (e.xAxis && e.xAxis.options) || {};
                !e.options.stacking ||
                  (e.visible !== !0 &&
                    i.options.chart.ignoreHiddenSeries !== !1) ||
                  (e.stackKey = [
                    e.type,
                    v(e.options.stack, ""),
                    t ? s.top : s.left,
                    t ? s.height : s.width,
                  ].join());
              });
          }
          function Y() {
            const i = this.stacking;
            if (i) {
              var t = i.stacks;
              h(t, function (e, s) {
                C(e), (t[s] = null);
              }),
                i && i.stackTotalGroup && i.stackTotalGroup.destroy();
            }
          }
          function S() {
            this.coll !== "yAxis" ||
              this.stacking ||
              (this.stacking = new l(this));
          }
          function N(i, t, e, s) {
            return (
              !M(i) || i.x !== t || (s && i.stackKey !== s)
                ? (i = { x: t, index: 0, key: s, stackKey: s })
                : i.index++,
              (i.key = [e, t, i.index].join()),
              i
            );
          }
          function D() {
            const i = this,
              t = i.stackKey,
              e = i.yAxis.stacking.stacks,
              s = i.processedXData,
              a = i[i.options.stacking + "Stacker"];
            let b;
            a &&
              [t, "-" + t].forEach((r) => {
                let w = s.length,
                  L;
                for (; w--; ) {
                  var I = s[w];
                  (b = i.getStackIndicator(b, I, i.index, r)),
                    (L = (I = e[r] && e[r][I]) && I.points[b.key]) &&
                      a.call(i, L, I, w);
                }
              });
          }
          function c(i, t, e) {
            (t = t.total ? 100 / t.total : 0),
              (i[0] = g(i[0] * t)),
              (i[1] = g(i[1] * t)),
              (this.stackedYData[e] = i[1]);
          }
          function p() {
            const i = this.yAxis.stacking;
            this.options.centerInCategory &&
            (this.is("column") || this.is("columnrange")) &&
            !this.options.stacking &&
            1 < this.chart.series.length
              ? n.setStackedPoints.call(this, "group")
              : i &&
                h(i.stacks, (t, e) => {
                  e.slice(-5) === "group" &&
                    (h(t, (s) => s.destroy()), delete i.stacks[e]);
                });
          }
          function f(i) {
            var t = this.chart;
            const e = i || this.options.stacking;
            if (
              e &&
              (this.visible === !0 || t.options.chart.ignoreHiddenSeries === !1)
            ) {
              var s = this.processedXData,
                a = this.processedYData,
                b = [],
                r = a.length,
                w = this.options,
                L = w.threshold,
                I = v(w.startFromThreshold && L, 0);
              (w = w.stack), (i = i ? `${this.type},${e}` : this.stackKey);
              var V = "-" + i,
                B = this.negStacks;
              t = e === "group" ? t.yAxis[0] : this.yAxis;
              var x = t.stacking.stacks,
                R = t.stacking.oldStacks,
                W,
                X;
              for (t.stacking.stacksTouched += 1, X = 0; X < r; X++) {
                var Z = s[X],
                  E = a[X],
                  _ = this.getStackIndicator(_, Z, this.index),
                  z = _.key,
                  J = (W = B && E < (I ? 0 : L)) ? V : i;
                x[J] || (x[J] = {}),
                  x[J][Z] ||
                    (R[J] && R[J][Z]
                      ? ((x[J][Z] = R[J][Z]), (x[J][Z].total = null))
                      : (x[J][Z] = new G(t, t.options.stackLabels, !!W, Z, w))),
                  (J = x[J][Z]),
                  E !== null
                    ? ((J.points[z] = J.points[this.index] =
                        [v(J.cumulative, I)]),
                      M(J.cumulative) || (J.base = z),
                      (J.touched = t.stacking.stacksTouched),
                      0 < _.index &&
                        this.singleStacks === !1 &&
                        (J.points[z][0] =
                          J.points[this.index + "," + Z + ",0"][0]))
                    : (J.points[z] = J.points[this.index] = null),
                  e === "percent"
                    ? ((W = W ? i : V),
                      B && x[W] && x[W][Z]
                        ? ((W = x[W][Z]),
                          (J.total = W.total =
                            Math.max(W.total, J.total) + Math.abs(E) || 0))
                        : (J.total = g(J.total + (Math.abs(E) || 0))))
                    : e === "group"
                    ? (j(E) && (E = E[0]),
                      E !== null && (J.total = (J.total || 0) + 1))
                    : (J.total = g(J.total + (E || 0))),
                  (J.cumulative =
                    e === "group"
                      ? (J.total || 1) - 1
                      : g(v(J.cumulative, I) + (E || 0))),
                  E !== null &&
                    (J.points[z].push(J.cumulative),
                    (b[X] = J.cumulative),
                    (J.hasValidPoints = !0));
              }
              e === "percent" && (t.stacking.usePercentage = !0),
                e !== "group" && (this.stackedYData = b),
                (t.stacking.oldStacks = {});
            }
          }
          const { getDeferredAnimation: u } = A,
            {
              series: { prototype: n },
            } = F,
            {
              addEvent: d,
              correctFloat: g,
              defined: M,
              destroyObjectProperties: C,
              fireEvent: P,
              isArray: j,
              isNumber: m,
              objectEach: h,
              pick: v,
            } = U;
          class l {
            constructor(t) {
              (this.oldStacks = {}),
                (this.stacks = {}),
                (this.stacksTouched = 0),
                (this.axis = t);
            }
            buildStacks() {
              const t = this.axis,
                e = t.series,
                s = t.options.reversedStacks,
                a = e.length;
              let b, r;
              for (this.usePercentage = !1, r = a; r--; )
                (b = e[s ? r : a - r - 1]),
                  b.setStackedPoints(),
                  b.setGroupedPoints();
              for (r = 0; r < a; r++) e[r].modifyStacks();
              P(t, "afterBuildStacks");
            }
            cleanStacks() {
              let t;
              this.oldStacks && (t = this.stacks = this.oldStacks),
                h(t, function (e) {
                  h(e, function (s) {
                    s.cumulative = s.total;
                  });
                });
            }
            resetStacks() {
              h(this.stacks, (t) => {
                h(t, (e, s) => {
                  m(e.touched) && e.touched < this.stacksTouched
                    ? (e.destroy(), delete t[s])
                    : ((e.total = null), (e.cumulative = null));
                });
              });
            }
            renderStackTotals() {
              var t = this.axis;
              const e = t.chart,
                s = e.renderer,
                a = this.stacks;
              t = u(
                e,
                (t.options.stackLabels && t.options.stackLabels.animation) || !1
              );
              const b = (this.stackTotalGroup =
                this.stackTotalGroup ||
                s.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add());
              b.translate(e.plotLeft, e.plotTop),
                h(a, function (r) {
                  h(r, function (w) {
                    w.render(b);
                  });
                }),
                b.animate({ opacity: 1 }, t);
            }
          }
          var o;
          return (
            (function (i) {
              const t = [];
              i.compose = function (e, s, a) {
                U.pushUnique(t, e) && (d(e, "init", S), d(e, "destroy", Y)),
                  U.pushUnique(t, s) && (s.prototype.getStacks = H),
                  U.pushUnique(t, a) &&
                    ((e = a.prototype),
                    (e.getStackIndicator = N),
                    (e.modifyStacks = D),
                    (e.percentStacker = c),
                    (e.setGroupedPoints = p),
                    (e.setStackedPoints = f));
              };
            })(o || (o = {})),
            o
          );
        }
      ),
      T(
        y,
        "Series/Line/LineSeries.js",
        [
          y["Core/Series/Series.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { defined: G, merge: U } = F;
          class H extends A {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            drawGraph() {
              const S = this,
                N = this.options,
                D = (this.gappedPath || this.getGraphPath).call(this),
                c = this.chart.styledMode;
              let p = [["graph", "highcharts-graph"]];
              c ||
                p[0].push(N.lineColor || this.color || "#cccccc", N.dashStyle),
                (p = S.getZonesGraphs(p)),
                p.forEach(function (f, u) {
                  var n = f[0];
                  let d = S[n];
                  const g = d ? "animate" : "attr";
                  d
                    ? ((d.endX = S.preventGraphAnimation ? null : D.xMap),
                      d.animate({ d: D }))
                    : D.length &&
                      (S[n] = d =
                        S.chart.renderer
                          .path(D)
                          .addClass(f[1])
                          .attr({ zIndex: 1 })
                          .add(S.group)),
                    d &&
                      !c &&
                      ((n = {
                        stroke: f[2],
                        "stroke-width": N.lineWidth || 0,
                        fill: (S.fillGraph && S.color) || "none",
                      }),
                      f[3]
                        ? (n.dashstyle = f[3])
                        : N.linecap !== "square" &&
                          (n["stroke-linecap"] = n["stroke-linejoin"] =
                            "round"),
                      d[g](n).shadow(2 > u && N.shadow)),
                    d && ((d.startX = D.xMap), (d.isArea = D.isArea));
                });
            }
            getGraphPath(S, N, D) {
              const c = this,
                p = c.options,
                f = [],
                u = [];
              let n,
                d = p.step;
              S = S || c.points;
              const g = S.reversed;
              return (
                g && S.reverse(),
                (d = { right: 1, center: 2 }[d] || (d && 3)) &&
                  g &&
                  (d = 4 - d),
                (S = this.getValidPoints(S, !1, !(p.connectNulls && !N && !D))),
                S.forEach(function (M, C) {
                  const P = M.plotX,
                    j = M.plotY,
                    m = S[C - 1],
                    h = M.isNull || typeof j != "number";
                  (M.leftCliff || (m && m.rightCliff)) && !D && (n = !0),
                    h && !G(N) && 0 < C
                      ? (n = !p.connectNulls)
                      : h && !N
                      ? (n = !0)
                      : (C === 0 || n
                          ? (C = [["M", M.plotX, M.plotY]])
                          : c.getPointSpline
                          ? (C = [c.getPointSpline(S, M, C)])
                          : d
                          ? ((C =
                              d === 1
                                ? [["L", m.plotX, j]]
                                : d === 2
                                ? [
                                    ["L", (m.plotX + P) / 2, m.plotY],
                                    ["L", (m.plotX + P) / 2, j],
                                  ]
                                : [["L", P, m.plotY]]),
                            C.push(["L", P, j]))
                          : (C = [["L", P, j]]),
                        u.push(M.x),
                        d && (u.push(M.x), d === 2 && u.push(M.x)),
                        f.push.apply(f, C),
                        (n = !1));
                }),
                (f.xMap = u),
                (c.graphPath = f)
              );
            }
            getZonesGraphs(S) {
              return (
                this.zones.forEach(function (N, D) {
                  (D = [
                    "zone-graph-" + D,
                    "highcharts-graph highcharts-zone-graph-" +
                      D +
                      " " +
                      (N.className || ""),
                  ]),
                    this.chart.styledMode ||
                      D.push(
                        N.color || this.color,
                        N.dashStyle || this.options.dashStyle
                      ),
                    S.push(D);
                }, this),
                S
              );
            }
          }
          return (
            (H.defaultOptions = U(A.defaultOptions, {
              legendSymbol: "lineMarker",
            })),
            O.registerSeriesType("line", H),
            H
          );
        }
      ),
      T(
        y,
        "Series/Area/AreaSeries.js",
        [
          y["Core/Color/Color.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const {
              seriesTypes: { line: G },
            } = O,
            { extend: U, merge: H, objectEach: Y, pick: S } = F;
          class N extends G {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            drawGraph() {
              (this.areaPath = []), super.drawGraph.apply(this);
              const c = this,
                p = this.areaPath,
                f = this.options,
                u = [["area", "highcharts-area", this.color, f.fillColor]];
              this.zones.forEach(function (n, d) {
                u.push([
                  "zone-area-" + d,
                  "highcharts-area highcharts-zone-area-" +
                    d +
                    " " +
                    n.className,
                  n.color || c.color,
                  n.fillColor || f.fillColor,
                ]);
              }),
                u.forEach(function (n) {
                  const d = n[0],
                    g = {};
                  let M = c[d];
                  const C = M ? "animate" : "attr";
                  M
                    ? ((M.endX = c.preventGraphAnimation ? null : p.xMap),
                      M.animate({ d: p }))
                    : ((g.zIndex = 0),
                      (M = c[d] =
                        c.chart.renderer.path(p).addClass(n[1]).add(c.group)),
                      (M.isArea = !0)),
                    c.chart.styledMode ||
                      (n[3]
                        ? (g.fill = n[3])
                        : ((g.fill = n[2]),
                          (g["fill-opacity"] = S(f.fillOpacity, 0.75)))),
                    M[C](g),
                    (M.startX = p.xMap),
                    (M.shiftUnit = f.step ? 2 : 1);
                });
            }
            getGraphPath(c) {
              var p = G.prototype.getGraphPath,
                f = this.options;
              const u = f.stacking,
                n = this.yAxis,
                d = [],
                g = [],
                M = this.index,
                C = n.stacking.stacks[this.stackKey],
                P = f.threshold,
                j = Math.round(n.getThreshold(f.threshold));
              f = S(f.connectNulls, u === "percent");
              var m = function (o, i, t) {
                var e = c[o];
                o = u && C[e.x].points[M];
                const s = e[t + "Null"] || 0;
                t = e[t + "Cliff"] || 0;
                let a, b;
                (e = !0),
                  t || s
                    ? ((a = (s ? o[0] : o[1]) + t), (b = o[0] + t), (e = !!s))
                    : !u && c[i] && c[i].isNull && (a = b = P),
                  typeof a < "u" &&
                    (g.push({
                      plotX: h,
                      plotY: a === null ? j : n.getThreshold(a),
                      isNull: e,
                      isCliff: !0,
                    }),
                    d.push({
                      plotX: h,
                      plotY: b === null ? j : n.getThreshold(b),
                      doCurve: !1,
                    }));
              };
              let h;
              (c = c || this.points), u && (c = this.getStackPoints(c));
              for (let o = 0, i = c.length; o < i; ++o) {
                u ||
                  (c[o].leftCliff =
                    c[o].rightCliff =
                    c[o].leftNull =
                    c[o].rightNull =
                      void 0);
                var v = c[o].isNull;
                h = S(c[o].rectPlotX, c[o].plotX);
                var l = u ? S(c[o].yBottom, j) : j;
                (!v || f) &&
                  (f || m(o, o - 1, "left"),
                  (v && !u && f) ||
                    (g.push(c[o]), d.push({ x: o, plotX: h, plotY: l })),
                  f || m(o, o + 1, "right"));
              }
              return (
                (m = p.call(this, g, !0, !0)),
                (d.reversed = !0),
                (v = p.call(this, d, !0, !0)),
                (l = v[0]) && l[0] === "M" && (v[0] = ["L", l[1], l[2]]),
                (v = m.concat(v)),
                v.length && v.push(["Z"]),
                (p = p.call(this, g, !1, f)),
                (v.xMap = m.xMap),
                (this.areaPath = v),
                p
              );
            }
            getStackPoints(c) {
              const p = this,
                f = [],
                u = [],
                n = this.xAxis,
                d = this.yAxis,
                g = d.stacking.stacks[this.stackKey],
                M = {},
                C = d.series,
                P = C.length,
                j = d.options.reversedStacks ? 1 : -1,
                m = C.indexOf(p);
              if (((c = c || this.points), this.options.stacking)) {
                for (let v = 0; v < c.length; v++)
                  (c[v].leftNull = c[v].rightNull = void 0), (M[c[v].x] = c[v]);
                Y(g, function (v, l) {
                  v.total !== null && u.push(l);
                }),
                  u.sort(function (v, l) {
                    return v - l;
                  });
                const h = C.map((v) => v.visible);
                u.forEach(function (v, l) {
                  let o = 0,
                    i,
                    t;
                  if (M[v] && !M[v].isNull)
                    f.push(M[v]),
                      [-1, 1].forEach(function (e) {
                        const s = e === 1 ? "rightNull" : "leftNull",
                          a = g[u[l + e]];
                        let b = 0;
                        if (a) {
                          let r = m;
                          for (; 0 <= r && r < P; ) {
                            const w = C[r].index;
                            (i = a.points[w]),
                              i ||
                                (w === p.index
                                  ? (M[v][s] = !0)
                                  : h[r] &&
                                    (t = g[v].points[w]) &&
                                    (b -= t[1] - t[0])),
                              (r += j);
                          }
                        }
                        M[v][e === 1 ? "rightCliff" : "leftCliff"] = b;
                      });
                  else {
                    let e = m;
                    for (; 0 <= e && e < P; ) {
                      if ((i = g[v].points[C[e].index])) {
                        o = i[1];
                        break;
                      }
                      e += j;
                    }
                    (o = S(o, 0)),
                      (o = d.translate(o, 0, 1, 0, 1)),
                      f.push({
                        isNull: !0,
                        plotX: n.translate(v, 0, 0, 0, 1),
                        x: v,
                        plotY: o,
                        yBottom: o,
                      });
                  }
                });
              }
              return f;
            }
          }
          return (
            (N.defaultOptions = H(G.defaultOptions, {
              threshold: 0,
              legendSymbol: "rectangle",
            })),
            U(N.prototype, { singleStacks: !1 }),
            O.registerSeriesType("area", N),
            N
          );
        }
      ),
      T(
        y,
        "Series/Spline/SplineSeries.js",
        [y["Core/Series/SeriesRegistry.js"], y["Core/Utilities.js"]],
        function (A, O) {
          const { line: F } = A.seriesTypes,
            { merge: G, pick: U } = O;
          class H extends F {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            getPointSpline(S, N, D) {
              const c = N.plotX || 0,
                p = N.plotY || 0,
                f = S[D - 1];
              D = S[D + 1];
              let u, n, d;
              if (
                f &&
                !f.isNull &&
                f.doCurve !== !1 &&
                !N.isCliff &&
                D &&
                !D.isNull &&
                D.doCurve !== !1 &&
                !N.isCliff
              ) {
                S = f.plotY || 0;
                var g = D.plotX || 0;
                D = D.plotY || 0;
                let M = 0;
                (u = (1.5 * c + (f.plotX || 0)) / 2.5),
                  (n = (1.5 * p + S) / 2.5),
                  (g = (1.5 * c + g) / 2.5),
                  (d = (1.5 * p + D) / 2.5),
                  g !== u && (M = ((d - n) * (g - c)) / (g - u) + p - d),
                  (n += M),
                  (d += M),
                  n > S && n > p
                    ? ((n = Math.max(S, p)), (d = 2 * p - n))
                    : n < S && n < p && ((n = Math.min(S, p)), (d = 2 * p - n)),
                  d > D && d > p
                    ? ((d = Math.max(D, p)), (n = 2 * p - d))
                    : d < D && d < p && ((d = Math.min(D, p)), (n = 2 * p - d)),
                  (N.rightContX = g),
                  (N.rightContY = d);
              }
              return (
                (N = [
                  "C",
                  U(f.rightContX, f.plotX, 0),
                  U(f.rightContY, f.plotY, 0),
                  U(u, c, 0),
                  U(n, p, 0),
                  c,
                  p,
                ]),
                (f.rightContX = f.rightContY = void 0),
                N
              );
            }
          }
          return (
            (H.defaultOptions = G(F.defaultOptions)),
            A.registerSeriesType("spline", H),
            H
          );
        }
      ),
      T(
        y,
        "Series/AreaSpline/AreaSplineSeries.js",
        [
          y["Series/Spline/SplineSeries.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const {
              area: G,
              area: { prototype: U },
            } = O.seriesTypes,
            { extend: H, merge: Y } = F;
          class S extends A {
            constructor() {
              super(...arguments),
                (this.options = this.points = this.data = void 0);
            }
          }
          return (
            (S.defaultOptions = Y(A.defaultOptions, G.defaultOptions)),
            H(S.prototype, {
              getGraphPath: U.getGraphPath,
              getStackPoints: U.getStackPoints,
              drawGraph: U.drawGraph,
            }),
            O.registerSeriesType("areaspline", S),
            S
          );
        }
      ),
      T(y, "Series/Column/ColumnSeriesDefaults.js", [], function () {
        return {
          borderRadius: 3,
          centerInCategory: !1,
          groupPadding: 0.2,
          marker: null,
          pointPadding: 0.1,
          minPointLength: 0,
          cropThreshold: 50,
          pointRange: null,
          states: {
            hover: { halo: !1, brightness: 0.1 },
            select: { color: "#cccccc", borderColor: "#000000" },
          },
          dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 },
          startFromThreshold: !0,
          stickyTracking: !1,
          tooltip: { distance: 6 },
          threshold: 0,
          borderColor: "#ffffff",
        };
      }),
      T(
        y,
        "Series/Column/ColumnSeries.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Color/Color.js"],
          y["Series/Column/ColumnSeriesDefaults.js"],
          y["Core/Globals.js"],
          y["Core/Series/Series.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y) {
          const { animObject: S } = A,
            { parse: N } = O,
            { hasTouch: D, noop: c } = G,
            {
              clamp: p,
              defined: f,
              extend: u,
              fireEvent: n,
              isArray: d,
              isNumber: g,
              merge: M,
              pick: C,
              objectEach: P,
            } = Y;
          class j extends U {
            constructor() {
              super(...arguments),
                (this.points =
                  this.options =
                  this.group =
                  this.data =
                  this.borderWidth =
                    void 0);
            }
            animate(h) {
              const v = this,
                l = this.yAxis,
                o = l.pos,
                i = v.options,
                t = this.chart.inverted,
                e = {},
                s = t ? "translateX" : "translateY";
              let a;
              h
                ? ((e.scaleY = 0.001),
                  (h = p(l.toPixels(i.threshold), o, o + l.len)),
                  t ? (e.translateX = h - l.len) : (e.translateY = h),
                  v.clipBox && v.setClip(),
                  v.group.attr(e))
                : ((a = Number(v.group.attr(s))),
                  v.group.animate(
                    { scaleY: 1 },
                    u(S(v.options.animation), {
                      step: function (b, r) {
                        v.group &&
                          ((e[s] = a + r.pos * (o - a)), v.group.attr(e));
                      },
                    })
                  ));
            }
            init(h, v) {
              super.init.apply(this, arguments);
              const l = this;
              (h = l.chart),
                h.hasRendered &&
                  h.series.forEach(function (o) {
                    o.type === l.type && (o.isDirty = !0);
                  });
            }
            getColumnMetrics() {
              const h = this;
              var v = h.options;
              const l = h.xAxis,
                o = h.yAxis;
              var i = l.options.reversedStacks;
              i = (l.reversed && !i) || (!l.reversed && i);
              const t = {};
              let e,
                s = 0;
              v.grouping === !1
                ? (s = 1)
                : h.chart.series.forEach(function (w) {
                    const L = w.yAxis,
                      I = w.options;
                    let V;
                    w.type !== h.type ||
                      (!w.visible &&
                        h.chart.options.chart.ignoreHiddenSeries) ||
                      o.len !== L.len ||
                      o.pos !== L.pos ||
                      (I.stacking && I.stacking !== "group"
                        ? ((e = w.stackKey),
                          typeof t[e] > "u" && (t[e] = s++),
                          (V = t[e]))
                        : I.grouping !== !1 && (V = s++),
                      (w.columnIndex = V));
                  });
              const a = Math.min(
                  Math.abs(l.transA) *
                    ((l.ordinal && l.ordinal.slope) ||
                      v.pointRange ||
                      l.closestPointRange ||
                      l.tickInterval ||
                      1),
                  l.len
                ),
                b = a * v.groupPadding,
                r = (a - 2 * b) / (s || 1);
              return (
                (v = Math.min(
                  v.maxPointWidth || l.len,
                  C(v.pointWidth, r * (1 - 2 * v.pointPadding))
                )),
                (h.columnMetrics = {
                  width: v,
                  offset:
                    (r - v) / 2 +
                    (b + ((h.columnIndex || 0) + (i ? 1 : 0)) * r - a / 2) *
                      (i ? -1 : 1),
                  paddedWidth: r,
                  columnCount: s,
                }),
                h.columnMetrics
              );
            }
            crispCol(h, v, l, o) {
              var i = this.borderWidth,
                t = -(i % 2 ? 0.5 : 0);
              return (
                (i = i % 2 ? 0.5 : 1),
                this.options.crisp &&
                  ((l = Math.round(h + l) + t),
                  (h = Math.round(h) + t),
                  (l -= h)),
                (o = Math.round(v + o) + i),
                (t = 0.5 >= Math.abs(v) && 0.5 < o),
                (v = Math.round(v) + i),
                (o -= v),
                t && o && (--v, (o += 1)),
                { x: h, y: v, width: l, height: o }
              );
            }
            adjustForMissingColumns(h, v, l, o) {
              const i = this.options.stacking;
              if (!l.isNull && 1 < o.columnCount) {
                const t = this.yAxis.options.reversedStacks;
                let e = 0,
                  s = t ? 0 : -o.columnCount;
                P(this.yAxis.stacking && this.yAxis.stacking.stacks, (a) => {
                  if (typeof l.x == "number") {
                    const b = a[l.x.toString()];
                    b &&
                      ((a = b.points[this.index]),
                      i
                        ? (a && (e = s), b.hasValidPoints && (t ? s++ : s--))
                        : d(a) &&
                          ((a = Object.keys(b.points)
                            .filter(
                              (r) =>
                                !r.match(",") &&
                                b.points[r] &&
                                1 < b.points[r].length
                            )
                            .map(parseFloat)
                            .sort((r, w) => w - r)),
                          (e = a.indexOf(this.index)),
                          (s = a.length)));
                  }
                }),
                  (h =
                    (l.plotX || 0) +
                    ((s - 1) * o.paddedWidth + v) / 2 -
                    v -
                    e * o.paddedWidth);
              }
              return h;
            }
            translate() {
              const h = this,
                v = h.chart,
                l = h.options;
              var o = (h.dense = 2 > h.closestPointRange * h.xAxis.transA);
              o = h.borderWidth = C(l.borderWidth, o ? 0 : 1);
              const i = h.xAxis,
                t = h.yAxis,
                e = l.threshold,
                s = C(l.minPointLength, 5),
                a = h.getColumnMetrics(),
                b = a.width,
                r = (h.pointXOffset = a.offset),
                w = h.dataMin,
                L = h.dataMax;
              let I = (h.barW = Math.max(b, 1 + 2 * o)),
                V = (h.translatedThreshold = t.getThreshold(e));
              v.inverted && (V -= 0.5),
                l.pointPadding && (I = Math.ceil(I)),
                U.prototype.translate.apply(h),
                h.points.forEach(function (B) {
                  const x = C(B.yBottom, V);
                  var R = 999 + Math.abs(x),
                    W = B.plotX || 0;
                  R = p(B.plotY, -R, t.len + R);
                  let X = Math.min(R, x),
                    Z = Math.max(R, x) - X,
                    E = b,
                    _ = W + r,
                    z = I;
                  s &&
                    Math.abs(Z) < s &&
                    ((Z = s),
                    (W =
                      (!t.reversed && !B.negative) ||
                      (t.reversed && B.negative)),
                    g(e) &&
                      g(L) &&
                      B.y === e &&
                      L <= e &&
                      (t.min || 0) < e &&
                      (w !== L || (t.max || 0) <= e) &&
                      ((W = !W), (B.negative = !B.negative)),
                    (X = Math.abs(X - V) > s ? x - s : V - (W ? s : 0))),
                    f(B.options.pointWidth) &&
                      ((E = z = Math.ceil(B.options.pointWidth)),
                      (_ -= Math.round((E - b) / 2))),
                    l.centerInCategory &&
                      (_ = h.adjustForMissingColumns(_, E, B, a)),
                    (B.barX = _),
                    (B.pointWidth = E),
                    (B.tooltipPos = v.inverted
                      ? [
                          p(
                            t.len + t.pos - v.plotLeft - R,
                            t.pos - v.plotLeft,
                            t.len + t.pos - v.plotLeft
                          ),
                          i.len + i.pos - v.plotTop - _ - z / 2,
                          Z,
                        ]
                      : [
                          i.left - v.plotLeft + _ + z / 2,
                          p(
                            R + t.pos - v.plotTop,
                            t.pos - v.plotTop,
                            t.len + t.pos - v.plotTop
                          ),
                          Z,
                        ]),
                    (B.shapeType =
                      h.pointClass.prototype.shapeType || "roundedRect"),
                    (B.shapeArgs = h.crispCol(
                      _,
                      B.isNull ? V : X,
                      z,
                      B.isNull ? 0 : Z
                    ));
                }),
                n(this, "afterColumnTranslate");
            }
            drawGraph() {
              this.group[this.dense ? "addClass" : "removeClass"](
                "highcharts-dense-data"
              );
            }
            pointAttribs(h, v) {
              const l = this.options;
              var o = this.pointAttrToOptions || {},
                i = o.stroke || "borderColor";
              const t = o["stroke-width"] || "borderWidth";
              let e,
                s = (h && h.color) || this.color,
                a = (h && h[i]) || l[i] || s;
              o = (h && h.options.dashStyle) || l.dashStyle;
              let b = (h && h[t]) || l[t] || this[t] || 0,
                r = C(h && h.opacity, l.opacity, 1);
              return (
                h &&
                  this.zones.length &&
                  ((e = h.getZone()),
                  (s =
                    h.options.color ||
                    (e && (e.color || h.nonZonedColor)) ||
                    this.color),
                  e &&
                    ((a = e.borderColor || a),
                    (o = e.dashStyle || o),
                    (b = e.borderWidth || b))),
                v &&
                  h &&
                  ((h = M(
                    l.states[v],
                    (h.options.states && h.options.states[v]) || {}
                  )),
                  (v = h.brightness),
                  (s =
                    h.color ||
                    (typeof v < "u" && N(s).brighten(h.brightness).get()) ||
                    s),
                  (a = h[i] || a),
                  (b = h[t] || b),
                  (o = h.dashStyle || o),
                  (r = C(h.opacity, r))),
                (i = { fill: s, stroke: a, "stroke-width": b, opacity: r }),
                o && (i.dashstyle = o),
                i
              );
            }
            drawPoints(h = this.points) {
              const v = this,
                l = this.chart,
                o = v.options,
                i = l.renderer,
                t = o.animationLimit || 250;
              let e;
              h.forEach(function (s) {
                let a = s.graphic,
                  b = !!a,
                  r = a && l.pointCount < t ? "animate" : "attr";
                g(s.plotY) && s.y !== null
                  ? ((e = s.shapeArgs),
                    a && s.hasNewShapeType() && (a = a.destroy()),
                    v.enabledDataSorting &&
                      (s.startXPos = v.xAxis.reversed
                        ? -((e && e.width) || 0)
                        : v.xAxis.width),
                    a ||
                      ((s.graphic = a =
                        i[s.shapeType](e).add(s.group || v.group)) &&
                        v.enabledDataSorting &&
                        l.hasRendered &&
                        l.pointCount < t &&
                        (a.attr({ x: s.startXPos }),
                        (b = !0),
                        (r = "animate"))),
                    a && b && a[r](M(e)),
                    l.styledMode ||
                      a[r](v.pointAttribs(s, s.selected && "select")).shadow(
                        s.allowShadow !== !1 && o.shadow
                      ),
                    a &&
                      (a.addClass(s.getClassName(), !0),
                      a.attr({ visibility: s.visible ? "inherit" : "hidden" })))
                  : a && (s.graphic = a.destroy());
              });
            }
            drawTracker(h = this.points) {
              const v = this,
                l = v.chart,
                o = l.pointer,
                i = function (e) {
                  const s = o.getPointFromEvent(e);
                  typeof s < "u" &&
                    v.options.enableMouseTracking &&
                    ((o.isDirectTouch = !0), s.onMouseOver(e));
                };
              let t;
              h.forEach(function (e) {
                (t = d(e.dataLabels)
                  ? e.dataLabels
                  : e.dataLabel
                  ? [e.dataLabel]
                  : []),
                  e.graphic && (e.graphic.element.point = e),
                  t.forEach(function (s) {
                    s.div ? (s.div.point = e) : (s.element.point = e);
                  });
              }),
                v._hasTracking ||
                  (v.trackerGroups.forEach(function (e) {
                    v[e] &&
                      (v[e]
                        .addClass("highcharts-tracker")
                        .on("mouseover", i)
                        .on("mouseout", function (s) {
                          o.onTrackerMouseOut(s);
                        }),
                      D && v[e].on("touchstart", i),
                      !l.styledMode &&
                        v.options.cursor &&
                        v[e].css({ cursor: v.options.cursor }));
                  }),
                  (v._hasTracking = !0)),
                n(this, "afterDrawTracker");
            }
            remove() {
              const h = this,
                v = h.chart;
              v.hasRendered &&
                v.series.forEach(function (l) {
                  l.type === h.type && (l.isDirty = !0);
                }),
                U.prototype.remove.apply(h, arguments);
            }
          }
          return (
            (j.defaultOptions = M(U.defaultOptions, F)),
            u(j.prototype, {
              cropShoulder: 0,
              directTouch: !0,
              getSymbol: c,
              negStacks: !0,
              trackerGroups: ["group", "dataLabelsGroup"],
            }),
            H.registerSeriesType("column", j),
            j
          );
        }
      ),
      T(
        y,
        "Core/Series/DataLabel.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Templating.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { getDeferredAnimation: G } = A,
            { format: U } = O,
            {
              defined: H,
              extend: Y,
              fireEvent: S,
              isArray: N,
              isString: D,
              merge: c,
              objectEach: p,
              pick: f,
              splat: u,
            } = F;
          var n;
          return (
            (function (d) {
              function g(o, i, t, e, s) {
                const a = this.chart;
                var b = this.isCartesian && a.inverted;
                const r = this.enabledDataSorting;
                var w = o.plotX,
                  L = o.plotY;
                const I = t.rotation;
                var V = t.align;
                L =
                  H(w) &&
                  H(L) &&
                  a.isInsidePlot(w, Math.round(L), {
                    inverted: b,
                    paneCoordinates: !0,
                    series: this,
                  });
                let B = f(t.overflow, r ? "none" : "justify") === "justify";
                if (
                  ((b =
                    this.visible &&
                    o.visible !== !1 &&
                    H(w) &&
                    (o.series.forceDL ||
                      (r && !B) ||
                      L ||
                      (f(t.inside, !!this.options.stacking) &&
                        e &&
                        a.isInsidePlot(w, b ? e.x + 1 : e.y + e.height - 1, {
                          inverted: b,
                          paneCoordinates: !0,
                          series: this,
                        })))),
                  (w = o.pos()),
                  b && w)
                ) {
                  I && i.attr({ align: V }), (V = i.getBBox(!0));
                  var x = [0, 0],
                    R = a.renderer.fontMetrics(i).b;
                  if (
                    ((e = Y(
                      { x: w[0], y: Math.round(w[1]), width: 0, height: 0 },
                      e
                    )),
                    Y(t, { width: V.width, height: V.height }),
                    I
                      ? ((B = !1),
                        (x = a.renderer.rotCorr(R, I)),
                        (R = {
                          x: e.x + (t.x || 0) + e.width / 2 + x.x,
                          y:
                            e.y +
                            (t.y || 0) +
                            { top: 0, middle: 0.5, bottom: 1 }[
                              t.verticalAlign
                            ] *
                              e.height,
                        }),
                        (x = [
                          V.x - Number(i.attr("x")),
                          V.y - Number(i.attr("y")),
                        ]),
                        r &&
                          this.xAxis &&
                          !B &&
                          this.setDataLabelStartPos(o, i, s, L, R),
                        i[s ? "attr" : "animate"](R))
                      : (r &&
                          this.xAxis &&
                          !B &&
                          this.setDataLabelStartPos(o, i, s, L, e),
                        i.align(t, void 0, e),
                        (R = i.alignAttr)),
                    B && 0 <= e.height)
                  )
                    this.justifyDataLabel(i, t, R, V, e, s);
                  else if (f(t.crop, !0)) {
                    let { x: W, y: X } = R;
                    (W += x[0]),
                      (X += x[1]),
                      (b =
                        a.isInsidePlot(W, X, {
                          paneCoordinates: !0,
                          series: this,
                        }) &&
                        a.isInsidePlot(W + V.width, X + V.height, {
                          paneCoordinates: !0,
                          series: this,
                        }));
                  }
                  t.shape &&
                    !I &&
                    i[s ? "attr" : "animate"]({ anchorX: w[0], anchorY: w[1] });
                }
                s && r && (i.placed = !1),
                  b || (r && !B) ? i.show() : (i.hide(), (i.placed = !1));
              }
              function M(o, i) {
                var t = i.filter;
                return t
                  ? ((i = t.operator),
                    (o = o[t.property]),
                    (t = t.value),
                    (i === ">" && o > t) ||
                      (i === "<" && o < t) ||
                      (i === ">=" && o >= t) ||
                      (i === "<=" && o <= t) ||
                      (i === "==" && o == t) ||
                      (i === "===" && o === t))
                  : !0;
              }
              function C() {
                return this.plotGroup(
                  "dataLabelsGroup",
                  "data-labels",
                  this.hasRendered ? "inherit" : "hidden",
                  this.options.dataLabels.zIndex || 6
                );
              }
              function P(o) {
                const i = this.hasRendered || 0,
                  t = this.initDataLabelsGroup().attr({ opacity: +i });
                return (
                  !i &&
                    t &&
                    (this.visible && t.show(),
                    this.options.animation
                      ? t.animate({ opacity: 1 }, o)
                      : t.attr({ opacity: 1 })),
                  t
                );
              }
              function j(o = this.points) {
                var i, t;
                const e = this,
                  s = e.chart,
                  a = e.options,
                  b = s.renderer,
                  { backgroundColor: r, plotBackgroundColor: w } =
                    s.options.chart,
                  L = s.options.plotOptions,
                  I = b.getContrast((D(w) && w) || (D(r) && r) || "#000000");
                let V = a.dataLabels,
                  B,
                  x;
                var R = u(V)[0];
                const W = R.animation;
                (R = R.defer ? G(s, W, e) : { defer: 0, duration: 0 }),
                  (V = h(
                    h(
                      (i = L == null ? void 0 : L.series) === null ||
                        i === void 0
                        ? void 0
                        : i.dataLabels,
                      (t = L == null ? void 0 : L[e.type]) === null ||
                        t === void 0
                        ? void 0
                        : t.dataLabels
                    ),
                    V
                  )),
                  S(this, "drawDataLabels"),
                  (N(V) || V.enabled || e._hasPointLabels) &&
                    ((x = this.initDataLabels(R)),
                    o.forEach((X) => {
                      var Z;
                      const E = X.dataLabels || [];
                      for (
                        B = u(
                          h(
                            V,
                            X.dlOptions ||
                              ((Z = X.options) === null || Z === void 0
                                ? void 0
                                : Z.dataLabels)
                          )
                        ),
                          B.forEach((_, z) => {
                            var J,
                              tt =
                                _.enabled &&
                                (!X.isNull || X.dataLabelOnNull) &&
                                M(X, _);
                            const $ = X.connectors
                                ? X.connectors[z]
                                : X.connector,
                              it = _.style || {};
                            let nt = {},
                              rt = E[z],
                              at = !rt;
                            const ct = f(_.distance, X.labelDistance);
                            if (tt) {
                              var Q = f(_[X.formatPrefix + "Format"], _.format),
                                K = X.getLabelConfig();
                              if (
                                ((K = H(Q)
                                  ? U(Q, K, s)
                                  : (
                                      _[X.formatPrefix + "Formatter"] ||
                                      _.formatter
                                    ).call(K, _)),
                                (Q = _.rotation),
                                s.styledMode ||
                                  ((it.color = f(
                                    _.color,
                                    it.color,
                                    D(e.color) ? e.color : void 0,
                                    "#000000"
                                  )),
                                  it.color === "contrast"
                                    ? ((X.contrastColor = b.getContrast(
                                        X.color || e.color
                                      )),
                                      (it.color =
                                        (!H(ct) && _.inside) ||
                                        0 > (ct || 0) ||
                                        a.stacking
                                          ? X.contrastColor
                                          : I))
                                    : delete X.contrastColor,
                                  a.cursor && (it.cursor = a.cursor)),
                                (nt = {
                                  r: _.borderRadius || 0,
                                  rotation: Q,
                                  padding: _.padding,
                                  zIndex: 1,
                                }),
                                !s.styledMode)
                              ) {
                                const { backgroundColor: st, borderColor: et } =
                                  _;
                                (nt.fill = st === "auto" ? X.color : st),
                                  (nt.stroke = et === "auto" ? X.color : et),
                                  (nt["stroke-width"] = _.borderWidth);
                              }
                              p(nt, (st, et) => {
                                typeof st > "u" && delete nt[et];
                              });
                            }
                            !rt ||
                              (tt &&
                                H(K) &&
                                !!rt.div == !!_.useHTML &&
                                ((rt.rotation && _.rotation) ||
                                  rt.rotation === _.rotation)) ||
                              ((rt = void 0),
                              (at = !0),
                              $ &&
                                X.connector &&
                                ((X.connector = X.connector.destroy()),
                                X.connectors &&
                                  (X.connectors.length === 1
                                    ? delete X.connectors
                                    : delete X.connectors[z]))),
                              tt &&
                                H(K) &&
                                (rt
                                  ? (nt.text = K)
                                  : (rt = Q
                                      ? b
                                          .text(K, 0, 0, _.useHTML)
                                          .addClass("highcharts-data-label")
                                      : b.label(
                                          K,
                                          0,
                                          0,
                                          _.shape,
                                          void 0,
                                          void 0,
                                          _.useHTML,
                                          void 0,
                                          "data-label"
                                        )) &&
                                    rt.addClass(
                                      " highcharts-data-label-color-" +
                                        X.colorIndex +
                                        " " +
                                        (_.className || "") +
                                        (_.useHTML ? " highcharts-tracker" : "")
                                    ),
                                rt &&
                                  ((rt.options = _),
                                  rt.attr(nt),
                                  s.styledMode || rt.css(it).shadow(_.shadow),
                                  (tt =
                                    _[X.formatPrefix + "TextPath"] ||
                                    _.textPath) &&
                                    !_.useHTML &&
                                    (rt.setTextPath(
                                      ((J = X.getDataLabelPath) === null ||
                                      J === void 0
                                        ? void 0
                                        : J.call(X, rt)) || X.graphic,
                                      tt
                                    ),
                                    X.dataLabelPath &&
                                      !tt.enabled &&
                                      (X.dataLabelPath =
                                        X.dataLabelPath.destroy())),
                                  rt.added || rt.add(x),
                                  e.alignDataLabel(X, rt, _, void 0, at),
                                  (rt.isActive = !0),
                                  E[z] && E[z] !== rt && E[z].destroy(),
                                  (E[z] = rt)));
                          }),
                          Z = E.length;
                        Z--;

                      )
                        E[Z].isActive
                          ? (E[Z].isActive = !1)
                          : (E[Z].destroy(), E.splice(Z, 1));
                      (X.dataLabel = E[0]), (X.dataLabels = E);
                    })),
                  S(this, "afterDrawDataLabels");
              }
              function m(o, i, t, e, s, a) {
                const b = this.chart,
                  r = i.align,
                  w = i.verticalAlign,
                  L = o.box ? 0 : o.padding || 0;
                let { x: I = 0, y: V = 0 } = i,
                  B,
                  x;
                return (
                  (B = (t.x || 0) + L),
                  0 > B &&
                    (r === "right" && 0 <= I
                      ? ((i.align = "left"), (i.inside = !0))
                      : (I -= B),
                    (x = !0)),
                  (B = (t.x || 0) + e.width - L),
                  B > b.plotWidth &&
                    (r === "left" && 0 >= I
                      ? ((i.align = "right"), (i.inside = !0))
                      : (I += b.plotWidth - B),
                    (x = !0)),
                  (B = t.y + L),
                  0 > B &&
                    (w === "bottom" && 0 <= V
                      ? ((i.verticalAlign = "top"), (i.inside = !0))
                      : (V -= B),
                    (x = !0)),
                  (B = (t.y || 0) + e.height - L),
                  B > b.plotHeight &&
                    (w === "top" && 0 >= V
                      ? ((i.verticalAlign = "bottom"), (i.inside = !0))
                      : (V += b.plotHeight - B),
                    (x = !0)),
                  x &&
                    ((i.x = I),
                    (i.y = V),
                    (o.placed = !a),
                    o.align(i, void 0, s)),
                  x
                );
              }
              function h(o, i) {
                let t = [],
                  e;
                if (N(o) && !N(i))
                  t = o.map(function (s) {
                    return c(s, i);
                  });
                else if (N(i) && !N(o))
                  t = i.map(function (s) {
                    return c(o, s);
                  });
                else if (!N(o) && !N(i)) t = c(o, i);
                else if (N(o) && N(i))
                  for (e = Math.max(o.length, i.length); e--; )
                    t[e] = c(o[e], i[e]);
                return t;
              }
              function v(o, i, t, e, s) {
                const a = this.chart,
                  b = a.inverted,
                  r = this.xAxis,
                  w = r.reversed,
                  L = b ? i.height / 2 : i.width / 2;
                (o = (o = o.pointWidth) ? o / 2 : 0),
                  (i.startXPos = b ? s.x : w ? -L - o : r.width - L + o),
                  (i.startYPos = b
                    ? w
                      ? this.yAxis.height - L + o
                      : -L - o
                    : s.y),
                  e
                    ? i.visibility === "hidden" &&
                      (i.show(), i.attr({ opacity: 0 }).animate({ opacity: 1 }))
                    : i
                        .attr({ opacity: 1 })
                        .animate({ opacity: 0 }, void 0, i.hide),
                  a.hasRendered &&
                    (t && i.attr({ x: i.startXPos, y: i.startYPos }),
                    (i.placed = !0));
              }
              const l = [];
              d.compose = function (o) {
                F.pushUnique(l, o) &&
                  ((o = o.prototype),
                  (o.initDataLabelsGroup = C),
                  (o.initDataLabels = P),
                  (o.alignDataLabel = g),
                  (o.drawDataLabels = j),
                  (o.justifyDataLabel = m),
                  (o.setDataLabelStartPos = v));
              };
            })(n || (n = {})),
            n
          );
        }
      ),
      T(
        y,
        "Series/Column/ColumnDataLabel.js",
        [
          y["Core/Series/DataLabel.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { series: G } = O,
            { merge: U, pick: H } = F;
          var Y;
          return (
            (function (S) {
              function N(c, p, f, u, n) {
                let d = this.chart.inverted;
                var g = c.series;
                let M = (g.xAxis ? g.xAxis.len : this.chart.plotSizeX) || 0;
                g = (g.yAxis ? g.yAxis.len : this.chart.plotSizeY) || 0;
                var C = c.dlBox || c.shapeArgs;
                let P = H(c.below, c.plotY > H(this.translatedThreshold, g)),
                  j = H(f.inside, !!this.options.stacking);
                C &&
                  ((u = U(C)),
                  0 > u.y && ((u.height += u.y), (u.y = 0)),
                  (C = u.y + u.height - g),
                  0 < C && C < u.height && (u.height -= C),
                  d &&
                    (u = {
                      x: g - u.y - u.height,
                      y: M - u.x - u.width,
                      width: u.height,
                      height: u.width,
                    }),
                  j ||
                    (d
                      ? ((u.x += P ? 0 : u.width), (u.width = 0))
                      : ((u.y += P ? u.height : 0), (u.height = 0)))),
                  (f.align = H(
                    f.align,
                    !d || j ? "center" : P ? "right" : "left"
                  )),
                  (f.verticalAlign = H(
                    f.verticalAlign,
                    d || j ? "middle" : P ? "top" : "bottom"
                  )),
                  G.prototype.alignDataLabel.call(this, c, p, f, u, n),
                  f.inside &&
                    c.contrastColor &&
                    p.css({ color: c.contrastColor });
              }
              const D = [];
              S.compose = function (c) {
                A.compose(G),
                  F.pushUnique(D, c) && (c.prototype.alignDataLabel = N);
              };
            })(Y || (Y = {})),
            Y
          );
        }
      ),
      T(
        y,
        "Series/Bar/BarSeries.js",
        [
          y["Series/Column/ColumnSeries.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { extend: G, merge: U } = F;
          class H extends A {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
          }
          return (
            (H.defaultOptions = U(A.defaultOptions, {})),
            G(H.prototype, { inverted: !0 }),
            O.registerSeriesType("bar", H),
            H
          );
        }
      ),
      T(y, "Series/Scatter/ScatterSeriesDefaults.js", [], function () {
        return {
          lineWidth: 0,
          findNearestPointBy: "xy",
          jitter: { x: 0, y: 0 },
          marker: { enabled: !0 },
          tooltip: {
            headerFormat:
              '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
          },
        };
      }),
      T(
        y,
        "Series/Scatter/ScatterSeries.js",
        [
          y["Series/Scatter/ScatterSeriesDefaults.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { column: G, line: U } = O.seriesTypes,
            { addEvent: H, extend: Y, merge: S } = F;
          class N extends U {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            applyJitter() {
              const c = this,
                p = this.options.jitter,
                f = this.points.length;
              p &&
                this.points.forEach(function (u, n) {
                  ["x", "y"].forEach(function (d, g) {
                    let M = "plot" + d.toUpperCase(),
                      C,
                      P;
                    if (p[d] && !u.isNull) {
                      var j = c[d + "Axis"];
                      (P = p[d] * j.transA),
                        j &&
                          !j.isLog &&
                          ((C = Math.max(0, u[M] - P)),
                          (j = Math.min(j.len, u[M] + P)),
                          (g = 1e4 * Math.sin(n + g * f)),
                          (g -= Math.floor(g)),
                          (u[M] = C + (j - C) * g),
                          d === "x" && (u.clientX = u.plotX));
                    }
                  });
                });
            }
            drawGraph() {
              this.options.lineWidth
                ? super.drawGraph()
                : this.graph && (this.graph = this.graph.destroy());
            }
          }
          return (
            (N.defaultOptions = S(U.defaultOptions, A)),
            Y(N.prototype, {
              drawTracker: G.prototype.drawTracker,
              sorted: !1,
              requireSorting: !1,
              noSharedTooltip: !0,
              trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
              takeOrdinalPosition: !1,
            }),
            H(N, "afterTranslate", function () {
              this.applyJitter();
            }),
            O.registerSeriesType("scatter", N),
            N
          );
        }
      ),
      T(
        y,
        "Series/CenteredUtilities.js",
        [
          y["Core/Globals.js"],
          y["Core/Series/Series.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { deg2rad: G } = A,
            { fireEvent: U, isNumber: H, pick: Y, relativeLength: S } = F;
          var N;
          return (
            (function (D) {
              (D.getCenter = function () {
                var c = this.options,
                  p = this.chart;
                const f = 2 * (c.slicedOffset || 0),
                  u = p.plotWidth - 2 * f,
                  n = p.plotHeight - 2 * f;
                var d = c.center;
                const g = Math.min(u, n),
                  M = c.thickness;
                var C = c.size;
                let P = c.innerSize || 0;
                for (
                  typeof C == "string" && (C = parseFloat(C)),
                    typeof P == "string" && (P = parseFloat(P)),
                    c = [
                      Y(d[0], "50%"),
                      Y(d[1], "50%"),
                      Y(C && 0 > C ? void 0 : c.size, "100%"),
                      Y(P && 0 > P ? void 0 : c.innerSize || 0, "0%"),
                    ],
                    !p.angular || this instanceof O || (c[3] = 0),
                    d = 0;
                  4 > d;
                  ++d
                )
                  (C = c[d]),
                    (p = 2 > d || (d === 2 && /%$/.test(C))),
                    (c[d] = S(C, [u, n, g, c[2]][d]) + (p ? f : 0));
                return (
                  c[3] > c[2] && (c[3] = c[2]),
                  H(M) && 2 * M < c[2] && 0 < M && (c[3] = c[2] - 2 * M),
                  U(this, "afterGetCenter", { positions: c }),
                  c
                );
              }),
                (D.getStartAndEndRadians = function (c, p) {
                  return (
                    (c = H(c) ? c : 0),
                    (p = H(p) && p > c && 360 > p - c ? p : c + 360),
                    { start: G * (c + -90), end: G * (p + -90) }
                  );
                });
            })(N || (N = {})),
            N
          );
        }
      ),
      T(
        y,
        "Series/Pie/PiePoint.js",
        [
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Series/Point.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { setAnimation: G } = A,
            {
              addEvent: U,
              defined: H,
              extend: Y,
              isNumber: S,
              pick: N,
              relativeLength: D,
            } = F;
          class c extends O {
            constructor() {
              super(...arguments),
                (this.series = this.options = this.labelDistance = void 0);
            }
            getConnectorPath() {
              const f = this.labelPosition,
                u = this.series.options.dataLabels,
                n = this.connectorShapes;
              let d = u.connectorShape;
              return (
                n[d] && (d = n[d]),
                d.call(
                  this,
                  { x: f.computed.x, y: f.computed.y, alignment: f.alignment },
                  f.connectorPosition,
                  u
                )
              );
            }
            getTranslate() {
              return this.sliced
                ? this.slicedTranslation
                : { translateX: 0, translateY: 0 };
            }
            haloPath(f) {
              const u = this.shapeArgs;
              return this.sliced || !this.visible
                ? []
                : this.series.chart.renderer.symbols.arc(
                    u.x,
                    u.y,
                    u.r + f,
                    u.r + f,
                    {
                      innerR: u.r - 1,
                      start: u.start,
                      end: u.end,
                      borderRadius: u.borderRadius,
                    }
                  );
            }
            init() {
              super.init.apply(this, arguments),
                (this.name = N(this.name, "Slice"));
              const f = (u) => {
                this.slice(u.type === "select");
              };
              return U(this, "select", f), U(this, "unselect", f), this;
            }
            isValid() {
              return S(this.y) && 0 <= this.y;
            }
            setVisible(f, u) {
              const n = this.series,
                d = n.chart,
                g = n.options.ignoreHiddenPoint;
              (u = N(u, g)),
                f !== this.visible &&
                  ((this.visible =
                    this.options.visible =
                    f =
                      typeof f > "u" ? !this.visible : f),
                  (n.options.data[n.data.indexOf(this)] = this.options),
                  ["graphic", "dataLabel", "connector"].forEach((M) => {
                    this[M] && this[M][f ? "show" : "hide"](f);
                  }),
                  this.legendItem && d.legend.colorizeItem(this, f),
                  f || this.state !== "hover" || this.setState(""),
                  g && (n.isDirty = !0),
                  u && d.redraw());
            }
            slice(f, u, n) {
              const d = this.series;
              G(n, d.chart),
                N(u, !0),
                (this.sliced = this.options.sliced = H(f) ? f : !this.sliced),
                (d.options.data[d.data.indexOf(this)] = this.options),
                this.graphic && this.graphic.animate(this.getTranslate());
            }
          }
          return (
            Y(c.prototype, {
              connectorShapes: {
                fixedOffset: function (p, f, u) {
                  const n = f.breakAt;
                  return (
                    (f = f.touchingSliceAt),
                    [
                      ["M", p.x, p.y],
                      u.softConnector
                        ? [
                            "C",
                            p.x + (p.alignment === "left" ? -5 : 5),
                            p.y,
                            2 * n.x - f.x,
                            2 * n.y - f.y,
                            n.x,
                            n.y,
                          ]
                        : ["L", n.x, n.y],
                      ["L", f.x, f.y],
                    ]
                  );
                },
                straight: function (p, f) {
                  return (
                    (f = f.touchingSliceAt),
                    [
                      ["M", p.x, p.y],
                      ["L", f.x, f.y],
                    ]
                  );
                },
                crookedLine: function (p, f, u) {
                  const { breakAt: n, touchingSliceAt: d } = f;
                  ({ series: f } = this);
                  const [g, M, C] = f.center,
                    P = C / 2,
                    j = f.chart.plotWidth,
                    m = f.chart.plotLeft;
                  f = p.alignment === "left";
                  const { x: h, y: v } = p;
                  return (
                    u.crookDistance
                      ? ((p = D(u.crookDistance, 1)),
                        (p = f
                          ? g + P + (j + m - g - P) * (1 - p)
                          : m + (g - P) * p))
                      : (p =
                          g +
                          (M - v) * Math.tan((this.angle || 0) - Math.PI / 2)),
                    (u = [["M", h, v]]),
                    (f ? p <= h && p >= n.x : p >= h && p <= n.x) &&
                      u.push(["L", p, v]),
                    u.push(["L", n.x, n.y], ["L", d.x, d.y]),
                    u
                  );
                },
              },
            }),
            c
          );
        }
      ),
      T(y, "Series/Pie/PieSeriesDefaults.js", [], function () {
        return {
          borderRadius: 3,
          center: [null, null],
          clip: !1,
          colorByPoint: !0,
          dataLabels: {
            allowOverlap: !0,
            connectorPadding: 5,
            connectorShape: "crookedLine",
            crookDistance: void 0,
            distance: 30,
            enabled: !0,
            formatter: function () {
              return this.point.isNull ? void 0 : this.point.name;
            },
            softConnector: !0,
            x: 0,
          },
          fillColor: void 0,
          ignoreHiddenPoint: !0,
          inactiveOtherPoints: !0,
          legendType: "point",
          marker: null,
          size: null,
          showInLegend: !1,
          slicedOffset: 10,
          stickyTracking: !1,
          tooltip: { followPointer: !0 },
          borderColor: "#ffffff",
          borderWidth: 1,
          lineWidth: void 0,
          states: { hover: { brightness: 0.1 } },
        };
      }),
      T(
        y,
        "Series/Pie/PieSeries.js",
        [
          y["Series/CenteredUtilities.js"],
          y["Series/Column/ColumnSeries.js"],
          y["Core/Globals.js"],
          y["Series/Pie/PiePoint.js"],
          y["Series/Pie/PieSeriesDefaults.js"],
          y["Core/Series/Series.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Renderer/SVG/Symbols.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y, S, N) {
          const { getStartAndEndRadians: D } = A;
          ({ noop: F } = F);
          const {
            clamp: c,
            extend: p,
            fireEvent: f,
            merge: u,
            pick: n,
            relativeLength: d,
          } = N;
          class g extends H {
            constructor() {
              super(...arguments),
                (this.points =
                  this.options =
                  this.maxLabelDistance =
                  this.data =
                  this.center =
                    void 0);
            }
            animate(C) {
              const P = this,
                j = P.points,
                m = P.startAngleRad;
              C ||
                j.forEach(function (h) {
                  const v = h.graphic,
                    l = h.shapeArgs;
                  v &&
                    l &&
                    (v.attr({
                      r: n(h.startR, P.center && P.center[3] / 2),
                      start: m,
                      end: m,
                    }),
                    v.animate(
                      { r: l.r, start: l.start, end: l.end },
                      P.options.animation
                    ));
                });
            }
            drawEmpty() {
              const C = this.startAngleRad,
                P = this.endAngleRad,
                j = this.options;
              let m, h;
              this.total === 0 && this.center
                ? ((m = this.center[0]),
                  (h = this.center[1]),
                  this.graph ||
                    (this.graph = this.chart.renderer
                      .arc(m, h, this.center[1] / 2, 0, C, P)
                      .addClass("highcharts-empty-series")
                      .add(this.group)),
                  this.graph.attr({
                    d: S.arc(m, h, this.center[2] / 2, 0, {
                      start: C,
                      end: P,
                      innerR: this.center[3] / 2,
                    }),
                  }),
                  this.chart.styledMode ||
                    this.graph.attr({
                      "stroke-width": j.borderWidth,
                      fill: j.fillColor || "none",
                      stroke: j.color || "#cccccc",
                    }))
                : this.graph && (this.graph = this.graph.destroy());
            }
            drawPoints() {
              const C = this.chart.renderer;
              this.points.forEach(function (P) {
                P.graphic &&
                  P.hasNewShapeType() &&
                  (P.graphic = P.graphic.destroy()),
                  P.graphic ||
                    ((P.graphic = C[P.shapeType](P.shapeArgs).add(
                      P.series.group
                    )),
                    (P.delayedRendering = !0));
              });
            }
            generatePoints() {
              super.generatePoints(), this.updateTotals();
            }
            getX(C, P, j) {
              const m = this.center,
                h = this.radii ? this.radii[j.index] || 0 : m[2] / 2;
              return (
                (C = Math.asin(c((C - m[1]) / (h + j.labelDistance), -1, 1))),
                m[0] +
                  (P ? -1 : 1) * Math.cos(C) * (h + j.labelDistance) +
                  (0 < j.labelDistance
                    ? (P ? -1 : 1) * this.options.dataLabels.padding
                    : 0)
              );
            }
            hasData() {
              return !!this.processedXData.length;
            }
            redrawPoints() {
              const C = this,
                P = C.chart;
              let j, m, h, v;
              this.drawEmpty(),
                C.group && !P.styledMode && C.group.shadow(C.options.shadow),
                C.points.forEach(function (l) {
                  const o = {};
                  (m = l.graphic),
                    !l.isNull && m
                      ? ((v = l.shapeArgs),
                        (j = l.getTranslate()),
                        P.styledMode ||
                          (h = C.pointAttribs(l, l.selected && "select")),
                        l.delayedRendering
                          ? (m.setRadialReference(C.center).attr(v).attr(j),
                            P.styledMode ||
                              m.attr(h).attr({ "stroke-linejoin": "round" }),
                            (l.delayedRendering = !1))
                          : (m.setRadialReference(C.center),
                            P.styledMode || u(!0, o, h),
                            u(!0, o, v, j),
                            m.animate(o)),
                        m.attr({
                          visibility: l.visible ? "inherit" : "hidden",
                        }),
                        m.addClass(l.getClassName(), !0))
                      : m && (l.graphic = m.destroy());
                });
            }
            sortByAngle(C, P) {
              C.sort(function (j, m) {
                return typeof j.angle < "u" && (m.angle - j.angle) * P;
              });
            }
            translate(C) {
              f(this, "translate"), this.generatePoints();
              var P = this.options;
              const j = P.slicedOffset,
                m = j + (P.borderWidth || 0);
              var h = D(P.startAngle, P.endAngle);
              const v = (this.startAngleRad = h.start);
              h = (this.endAngleRad = h.end) - v;
              const l = this.points,
                o = P.dataLabels.distance;
              P = P.ignoreHiddenPoint;
              const i = l.length;
              let t,
                e,
                s,
                a = 0;
              for (
                C || (this.center = C = this.getCenter()), e = 0;
                e < i;
                e++
              ) {
                s = l[e];
                var b = v + a * h;
                !s.isValid() || (P && !s.visible) || (a += s.percentage / 100);
                var r = v + a * h,
                  w = {
                    x: C[0],
                    y: C[1],
                    r: C[2] / 2,
                    innerR: C[3] / 2,
                    start: Math.round(1e3 * b) / 1e3,
                    end: Math.round(1e3 * r) / 1e3,
                  };
                (s.shapeType = "arc"),
                  (s.shapeArgs = w),
                  (s.labelDistance = n(
                    s.options.dataLabels && s.options.dataLabels.distance,
                    o
                  )),
                  (s.labelDistance = d(s.labelDistance, w.r)),
                  (this.maxLabelDistance = Math.max(
                    this.maxLabelDistance || 0,
                    s.labelDistance
                  )),
                  (r = (r + b) / 2),
                  r > 1.5 * Math.PI
                    ? (r -= 2 * Math.PI)
                    : r < -Math.PI / 2 && (r += 2 * Math.PI),
                  (s.slicedTranslation = {
                    translateX: Math.round(Math.cos(r) * j),
                    translateY: Math.round(Math.sin(r) * j),
                  }),
                  (w = (Math.cos(r) * C[2]) / 2),
                  (t = (Math.sin(r) * C[2]) / 2),
                  (s.tooltipPos = [C[0] + 0.7 * w, C[1] + 0.7 * t]),
                  (s.half = r < -Math.PI / 2 || r > Math.PI / 2 ? 1 : 0),
                  (s.angle = r),
                  (b = Math.min(m, s.labelDistance / 5)),
                  (s.labelPosition = {
                    natural: {
                      x: C[0] + w + Math.cos(r) * s.labelDistance,
                      y: C[1] + t + Math.sin(r) * s.labelDistance,
                    },
                    computed: {},
                    alignment:
                      0 > s.labelDistance
                        ? "center"
                        : s.half
                        ? "right"
                        : "left",
                    connectorPosition: {
                      breakAt: {
                        x: C[0] + w + Math.cos(r) * b,
                        y: C[1] + t + Math.sin(r) * b,
                      },
                      touchingSliceAt: { x: C[0] + w, y: C[1] + t },
                    },
                  });
              }
              f(this, "afterTranslate");
            }
            updateTotals() {
              const C = this.points,
                P = C.length,
                j = this.options.ignoreHiddenPoint;
              let m,
                h,
                v = 0;
              for (m = 0; m < P; m++)
                (h = C[m]), !h.isValid() || (j && !h.visible) || (v += h.y);
              for (this.total = v, m = 0; m < P; m++)
                (h = C[m]),
                  (h.percentage =
                    0 < v && (h.visible || !j) ? (h.y / v) * 100 : 0),
                  (h.total = v);
            }
          }
          return (
            (g.defaultOptions = u(H.defaultOptions, U)),
            p(g.prototype, {
              axisTypes: [],
              directTouch: !0,
              drawGraph: void 0,
              drawTracker: O.prototype.drawTracker,
              getCenter: A.getCenter,
              getSymbol: F,
              isCartesian: !1,
              noSharedTooltip: !0,
              pointAttribs: O.prototype.pointAttribs,
              pointClass: G,
              requireSorting: !1,
              searchPoint: F,
              trackerGroups: ["group", "dataLabelsGroup"],
            }),
            Y.registerSeriesType("pie", g),
            g
          );
        }
      ),
      T(
        y,
        "Series/Pie/PieDataLabel.js",
        [
          y["Core/Series/DataLabel.js"],
          y["Core/Globals.js"],
          y["Core/Renderer/RendererUtilities.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U) {
          const { noop: H } = O,
            { distribute: Y } = F,
            { series: S } = G,
            {
              arrayMax: N,
              clamp: D,
              defined: c,
              merge: p,
              pick: f,
              relativeLength: u,
            } = U;
          var n;
          return (
            (function (d) {
              function g() {
                const m = this,
                  h = m.data,
                  v = m.chart,
                  l = m.options.dataLabels || {},
                  o = l.connectorPadding,
                  i = v.plotWidth,
                  t = v.plotHeight,
                  e = v.plotLeft,
                  s = Math.round(v.chartWidth / 3),
                  a = m.center,
                  b = a[2] / 2,
                  r = a[1],
                  w = [[], []],
                  L = [0, 0, 0, 0],
                  I = m.dataLabelPositioners;
                let V, B, x, R, W, X, Z, E, _, z, J, tt;
                m.visible &&
                  (l.enabled || m._hasPointLabels) &&
                  (h.forEach(function ($) {
                    $.dataLabel &&
                      $.visible &&
                      $.dataLabel.shortened &&
                      ($.dataLabel
                        .attr({ width: "auto" })
                        .css({ width: "auto", textOverflow: "clip" }),
                      ($.dataLabel.shortened = !1));
                  }),
                  S.prototype.drawDataLabels.apply(m),
                  h.forEach(function ($) {
                    $.dataLabel &&
                      ($.visible
                        ? (w[$.half].push($),
                          ($.dataLabel._pos = null),
                          !c(l.style.width) &&
                            !c(
                              $.options.dataLabels &&
                                $.options.dataLabels.style &&
                                $.options.dataLabels.style.width
                            ) &&
                            $.dataLabel.getBBox().width > s &&
                            ($.dataLabel.css({
                              width: Math.round(0.7 * s) + "px",
                            }),
                            ($.dataLabel.shortened = !0)))
                        : (($.dataLabel = $.dataLabel.destroy()),
                          $.dataLabels &&
                            $.dataLabels.length === 1 &&
                            delete $.dataLabels));
                  }),
                  w.forEach(($, it) => {
                    const nt = $.length,
                      rt = [];
                    let at,
                      ct = 0;
                    if (nt) {
                      if (
                        (m.sortByAngle($, it - 0.5), 0 < m.maxLabelDistance)
                      ) {
                        var Q = Math.max(0, r - b - m.maxLabelDistance);
                        (at = Math.min(
                          r + b + m.maxLabelDistance,
                          v.plotHeight
                        )),
                          $.forEach(function (K) {
                            0 < K.labelDistance &&
                              K.dataLabel &&
                              ((K.top = Math.max(0, r - b - K.labelDistance)),
                              (K.bottom = Math.min(
                                r + b + K.labelDistance,
                                v.plotHeight
                              )),
                              (ct = K.dataLabel.getBBox().height || 21),
                              (K.distributeBox = {
                                target:
                                  K.labelPosition.natural.y - K.top + ct / 2,
                                size: ct,
                                rank: K.y,
                              }),
                              rt.push(K.distributeBox));
                          }),
                          (Q = at + ct - Q),
                          Y(rt, Q, Q / 5);
                      }
                      for (J = 0; J < nt; J++) {
                        if (
                          ((V = $[J]),
                          (X = V.labelPosition),
                          (R = V.dataLabel),
                          (z = V.visible === !1 ? "hidden" : "inherit"),
                          (_ = Q = X.natural.y),
                          rt &&
                            c(V.distributeBox) &&
                            (typeof V.distributeBox.pos > "u"
                              ? (z = "hidden")
                              : ((Z = V.distributeBox.size),
                                (_ = I.radialDistributionY(V)))),
                          delete V.positionIndex,
                          l.justify)
                        )
                          E = I.justify(V, b, a);
                        else
                          switch (l.alignTo) {
                            case "connectors":
                              E = I.alignToConnectors($, it, i, e);
                              break;
                            case "plotEdges":
                              E = I.alignToPlotEdges(R, it, i, e);
                              break;
                            default:
                              E = I.radialDistributionX(m, V, _, Q);
                          }
                        (R._attr = { visibility: z, align: X.alignment }),
                          (tt = V.options.dataLabels || {}),
                          (R._pos = {
                            x:
                              E +
                              f(tt.x, l.x) +
                              ({ left: o, right: -o }[X.alignment] || 0),
                            y: _ + f(tt.y, l.y) - R.getBBox().height / 2,
                          }),
                          X && ((X.computed.x = E), (X.computed.y = _)),
                          f(l.crop, !0) &&
                            ((W = R.getBBox().width),
                            (Q = null),
                            E - W < o && it === 1
                              ? ((Q = Math.round(W - E + o)),
                                (L[3] = Math.max(Q, L[3])))
                              : E + W > i - o &&
                                it === 0 &&
                                ((Q = Math.round(E + W - i + o)),
                                (L[1] = Math.max(Q, L[1]))),
                            0 > _ - Z / 2
                              ? (L[0] = Math.max(Math.round(-_ + Z / 2), L[0]))
                              : _ + Z / 2 > t &&
                                (L[2] = Math.max(
                                  Math.round(_ + Z / 2 - t),
                                  L[2]
                                )),
                            (R.sideOverflow = Q));
                      }
                    }
                  }),
                  N(L) === 0 || this.verifyDataLabelOverflow(L)) &&
                  (this.placeDataLabels(),
                  this.points.forEach(function ($) {
                    if (
                      ((tt = p(l, $.options.dataLabels)),
                      (B = f(tt.connectorWidth, 1)))
                    ) {
                      let it;
                      (x = $.connector),
                        (R = $.dataLabel) &&
                        R._pos &&
                        $.visible &&
                        0 < $.labelDistance
                          ? ((z = R._attr.visibility),
                            (it = !x) &&
                              (($.connector = x =
                                v.renderer
                                  .path()
                                  .addClass(
                                    "highcharts-data-label-connector  highcharts-color-" +
                                      $.colorIndex +
                                      ($.className ? " " + $.className : "")
                                  )
                                  .add(m.dataLabelsGroup)),
                              v.styledMode ||
                                x.attr({
                                  "stroke-width": B,
                                  stroke:
                                    tt.connectorColor || $.color || "#666666",
                                })),
                            x[it ? "attr" : "animate"]({
                              d: $.getConnectorPath(),
                            }),
                            x.attr("visibility", z))
                          : x && ($.connector = x.destroy());
                    }
                  }));
              }
              function M() {
                this.points.forEach(function (m) {
                  let h = m.dataLabel,
                    v;
                  h &&
                    m.visible &&
                    ((v = h._pos)
                      ? (h.sideOverflow &&
                          ((h._attr.width = Math.max(
                            h.getBBox().width - h.sideOverflow,
                            0
                          )),
                          h.css({
                            width: h._attr.width + "px",
                            textOverflow:
                              (this.options.dataLabels.style || {})
                                .textOverflow || "ellipsis",
                          }),
                          (h.shortened = !0)),
                        h.attr(h._attr),
                        h[h.moved ? "animate" : "attr"](v),
                        (h.moved = !0))
                      : h && h.attr({ y: -9999 })),
                    delete m.distributeBox;
                }, this);
              }
              function C(m) {
                let h = this.center,
                  v = this.options,
                  l = v.center,
                  o = v.minSize || 80,
                  i,
                  t = v.size !== null;
                return (
                  t ||
                    (l[0] !== null
                      ? (i = Math.max(h[2] - Math.max(m[1], m[3]), o))
                      : ((i = Math.max(h[2] - m[1] - m[3], o)),
                        (h[0] += (m[3] - m[1]) / 2)),
                    l[1] !== null
                      ? (i = D(i, o, h[2] - Math.max(m[0], m[2])))
                      : ((i = D(i, o, h[2] - m[0] - m[2])),
                        (h[1] += (m[0] - m[2]) / 2)),
                    i < h[2]
                      ? ((h[2] = i),
                        (h[3] = Math.min(
                          v.thickness
                            ? Math.max(0, i - 2 * v.thickness)
                            : Math.max(0, u(v.innerSize || 0, i)),
                          i
                        )),
                        this.translate(h),
                        this.drawDataLabels && this.drawDataLabels())
                      : (t = !0)),
                  t
                );
              }
              const P = [],
                j = {
                  radialDistributionY: function (m) {
                    return m.top + m.distributeBox.pos;
                  },
                  radialDistributionX: function (m, h, v, l) {
                    return m.getX(
                      v < h.top + 2 || v > h.bottom - 2 ? l : v,
                      h.half,
                      h
                    );
                  },
                  justify: function (m, h, v) {
                    return v[0] + (m.half ? -1 : 1) * (h + m.labelDistance);
                  },
                  alignToPlotEdges: function (m, h, v, l) {
                    return (m = m.getBBox().width), h ? m + l : v - m - l;
                  },
                  alignToConnectors: function (m, h, v, l) {
                    let o = 0,
                      i;
                    return (
                      m.forEach(function (t) {
                        (i = t.dataLabel.getBBox().width), i > o && (o = i);
                      }),
                      h ? o + l : v - o - l
                    );
                  },
                };
              d.compose = function (m) {
                A.compose(S),
                  U.pushUnique(P, m) &&
                    ((m = m.prototype),
                    (m.dataLabelPositioners = j),
                    (m.alignDataLabel = H),
                    (m.drawDataLabels = g),
                    (m.placeDataLabels = M),
                    (m.verifyDataLabelOverflow = C));
              };
            })(n || (n = {})),
            n
          );
        }
      ),
      T(
        y,
        "Extensions/OverlappingDataLabels.js",
        [y["Core/Chart/Chart.js"], y["Core/Utilities.js"]],
        function (A, O) {
          function F(D, c) {
            let p,
              f = !1;
            return (
              D &&
                ((p = D.newOpacity),
                D.oldOpacity !== p &&
                  (D.alignAttr && D.placed
                    ? (D[p ? "removeClass" : "addClass"](
                        "highcharts-data-label-hidden"
                      ),
                      (f = !0),
                      (D.alignAttr.opacity = p),
                      D[D.isOld ? "animate" : "attr"](
                        D.alignAttr,
                        null,
                        function () {
                          c.styledMode ||
                            D.css({ pointerEvents: p ? "auto" : "none" });
                        }
                      ),
                      U(c, "afterHideOverlappingLabel"))
                    : D.attr({ opacity: p })),
                (D.isOld = !0)),
              f
            );
          }
          const {
            addEvent: G,
            fireEvent: U,
            isArray: H,
            isNumber: Y,
            objectEach: S,
            pick: N,
          } = O;
          G(A, "render", function () {
            let D = this,
              c = [];
            (this.labelCollectors || []).forEach(function (p) {
              c = c.concat(p());
            }),
              (this.yAxis || []).forEach(function (p) {
                p.stacking &&
                  p.options.stackLabels &&
                  !p.options.stackLabels.allowOverlap &&
                  S(p.stacking.stacks, function (f) {
                    S(f, function (u) {
                      u.label && c.push(u.label);
                    });
                  });
              }),
              (this.series || []).forEach(function (p) {
                var f = p.options.dataLabels;
                p.visible &&
                  (f.enabled !== !1 || p._hasPointLabels) &&
                  ((f = (u) =>
                    u.forEach((n) => {
                      n.visible &&
                        (H(n.dataLabels)
                          ? n.dataLabels
                          : n.dataLabel
                          ? [n.dataLabel]
                          : []
                        ).forEach(function (d) {
                          const g = d.options;
                          (d.labelrank = N(
                            g.labelrank,
                            n.labelrank,
                            n.shapeArgs && n.shapeArgs.height
                          )),
                            g.allowOverlap
                              ? ((d.oldOpacity = d.opacity),
                                (d.newOpacity = 1),
                                F(d, D))
                              : c.push(d);
                        });
                    })),
                  f(p.nodes || []),
                  f(p.points));
              }),
              this.hideOverlappingLabels(c);
          }),
            (A.prototype.hideOverlappingLabels = function (D) {
              let c = this,
                p = D.length,
                f = c.renderer;
              var u;
              let n,
                d,
                g,
                M,
                C = !1;
              var P = function (j) {
                let m, h;
                var v;
                let l = j.box ? 0 : j.padding || 0,
                  o = (v = 0),
                  i,
                  t;
                if (j && (!j.alignAttr || j.placed))
                  return (
                    (m = j.alignAttr || { x: j.attr("x"), y: j.attr("y") }),
                    (h = j.parentGroup),
                    j.width ||
                      ((v = j.getBBox()),
                      (j.width = v.width),
                      (j.height = v.height),
                      (v = f.fontMetrics(j.element).h)),
                    (i = j.width - 2 * l),
                    (t = { left: "0", center: "0.5", right: "1" }[j.alignValue])
                      ? (o = +t * i)
                      : Y(j.x) &&
                        Math.round(j.x) !== j.translateX &&
                        (o = j.x - j.translateX),
                    {
                      x: m.x + (h.translateX || 0) + l - (o || 0),
                      y: m.y + (h.translateY || 0) + l - v,
                      width: j.width - 2 * l,
                      height: j.height - 2 * l,
                    }
                  );
              };
              for (n = 0; n < p; n++)
                (u = D[n]) &&
                  ((u.oldOpacity = u.opacity),
                  (u.newOpacity = 1),
                  (u.absoluteBox = P(u)));
              for (
                D.sort(function (j, m) {
                  return (m.labelrank || 0) - (j.labelrank || 0);
                }),
                  n = 0;
                n < p;
                n++
              )
                for (g = (P = D[n]) && P.absoluteBox, u = n + 1; u < p; ++u)
                  (M = (d = D[u]) && d.absoluteBox),
                    !g ||
                      !M ||
                      P === d ||
                      P.newOpacity === 0 ||
                      d.newOpacity === 0 ||
                      P.visibility === "hidden" ||
                      d.visibility === "hidden" ||
                      M.x >= g.x + g.width ||
                      M.x + M.width <= g.x ||
                      M.y >= g.y + g.height ||
                      M.y + M.height <= g.y ||
                      ((P.labelrank < d.labelrank ? P : d).newOpacity = 0);
              D.forEach(function (j) {
                F(j, c) && (C = !0);
              }),
                C && U(c, "afterHideAllOverlappingLabels");
            });
        }
      ),
      T(
        y,
        "Extensions/BorderRadius.js",
        [
          y["Core/Defaults.js"],
          y["Core/Series/Series.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Renderer/SVG/SVGRenderer.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H) {
          const { defaultOptions: Y } = A;
          ({ seriesTypes: A } = F);
          const {
              addEvent: S,
              extend: N,
              isObject: D,
              merge: c,
              relativeLength: p,
            } = H,
            f = { radius: 0, scope: "stack", where: void 0 },
            u = (n, d) => (D(n) || (n = { radius: n || 0 }), c(f, d, n));
          if (G.symbolCustomAttribs.indexOf("borderRadius") === -1) {
            G.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY");
            const n = U.prototype.symbols.arc;
            U.prototype.symbols.arc = function (g, M, C, P, j = {}) {
              g = n(g, M, C, P, j);
              const { innerR: m = 0, r: h = C, start: v = 0, end: l = 0 } = j;
              if (j.open || !j.borderRadius) return g;
              for (
                C = l - v,
                  M = Math.sin(C / 2),
                  j = Math.max(
                    Math.min(
                      p(j.borderRadius || 0, h - m),
                      (h - m) / 2,
                      (h * M) / (1 + M)
                    ),
                    0
                  ),
                  C = Math.min(j, (C / Math.PI) * 2 * m),
                  M = g.length - 1;
                M--;

              ) {
                let b, r, w;
                P = g;
                var o = M,
                  i = 1 < M ? C : j,
                  t = P[o],
                  e = P[o + 1];
                if (
                  (e[0] === "Z" && (e = P[0]),
                  (t[0] !== "M" && t[0] !== "L") || e[0] !== "A"
                    ? t[0] !== "A" ||
                      (e[0] !== "M" && e[0] !== "L") ||
                      ((w = e), (r = t))
                    : ((w = t), (r = e), (b = !0)),
                  w && r && r.params)
                ) {
                  t = r[1];
                  var s = r[5];
                  e = r.params;
                  const { start: L, end: I, cx: V, cy: B } = e;
                  var a = s ? t - i : t + i;
                  const x = a ? Math.asin(i / a) : 0;
                  (s = s ? x : -x),
                    (a *= Math.cos(x)),
                    b
                      ? ((e.start = L + s),
                        (w[1] = V + a * Math.cos(L)),
                        (w[2] = B + a * Math.sin(L)),
                        P.splice(o + 1, 0, [
                          "A",
                          i,
                          i,
                          0,
                          0,
                          1,
                          V + t * Math.cos(e.start),
                          B + t * Math.sin(e.start),
                        ]))
                      : ((e.end = I - s),
                        (r[6] = V + t * Math.cos(e.end)),
                        (r[7] = B + t * Math.sin(e.end)),
                        P.splice(o + 1, 0, [
                          "A",
                          i,
                          i,
                          0,
                          0,
                          1,
                          V + a * Math.cos(I),
                          B + a * Math.sin(I),
                        ])),
                    (r[4] = Math.abs(e.end - e.start) < Math.PI ? 0 : 1);
                }
              }
              return g;
            };
            const d = U.prototype.symbols.roundedRect;
            (U.prototype.symbols.roundedRect = function (g, M, C, P, j = {}) {
              const m = d(g, M, C, P, j),
                { r: h = 0, brBoxHeight: v = P, brBoxY: l = M } = j;
              var o = M - l,
                i = l + v - (M + P);
              j = -0.1 < o - h ? 0 : h;
              const t = -0.1 < i - h ? 0 : h;
              var e = Math.max(j && o, 0);
              const s = Math.max(t && i, 0);
              (i = [g + j, M]), (o = [g + C - j, M]);
              const a = [g + C, M + j],
                b = [g + C, M + P - t],
                r = [g + C - t, M + P],
                w = [g + t, M + P],
                L = [g, M + P - t],
                I = [g, M + j];
              if (e) {
                const V = Math.sqrt(Math.pow(j, 2) - Math.pow(j - e, 2));
                (i[0] -= V), (o[0] += V), (a[1] = I[1] = M + j - e);
              }
              return (
                P < j - e &&
                  ((e = Math.sqrt(Math.pow(j, 2) - Math.pow(j - e - P, 2))),
                  (a[0] = b[0] = g + C - j + e),
                  (r[0] = Math.min(a[0], r[0])),
                  (w[0] = Math.max(b[0], w[0])),
                  (L[0] = I[0] = g + j - e),
                  (a[1] = I[1] = M + P)),
                s &&
                  ((e = Math.sqrt(Math.pow(t, 2) - Math.pow(t - s, 2))),
                  (r[0] += e),
                  (w[0] -= e),
                  (b[1] = L[1] = M + P - t + s)),
                P < t - s &&
                  ((P = Math.sqrt(Math.pow(t, 2) - Math.pow(t - s - P, 2))),
                  (a[0] = b[0] = g + C - t + P),
                  (o[0] = Math.min(a[0], o[0])),
                  (i[0] = Math.max(b[0], i[0])),
                  (L[0] = I[0] = g + t - P),
                  (b[1] = L[1] = M)),
                (m.length = 0),
                m.push(
                  ["M", ...i],
                  ["L", ...o],
                  ["A", j, j, 0, 0, 1, ...a],
                  ["L", ...b],
                  ["A", t, t, 0, 0, 1, ...r],
                  ["L", ...w],
                  ["A", t, t, 0, 0, 1, ...L],
                  ["L", ...I],
                  ["A", j, j, 0, 0, 1, ...i],
                  ["Z"]
                ),
                m
              );
            }),
              S(A.pie, "afterTranslate", function () {
                const g = u(this.options.borderRadius);
                for (const M of this.points) {
                  const C = M.shapeArgs;
                  C &&
                    (C.borderRadius = p(
                      g.radius,
                      (C.r || 0) - (C.innerR || 0)
                    ));
                }
              }),
              S(
                O,
                "afterColumnTranslate",
                function () {
                  var g, M;
                  if (
                    this.options.borderRadius &&
                    (!this.chart.is3d || !this.chart.is3d())
                  ) {
                    const { options: m, yAxis: h } = this,
                      v = m.stacking === "percent";
                    var C =
                      (M =
                        (g = Y.plotOptions) === null || g === void 0
                          ? void 0
                          : g[this.type]) === null || M === void 0
                        ? void 0
                        : M.borderRadius;
                    (g = u(m.borderRadius, D(C) ? C : {})),
                      (M = h.options.reversed);
                    for (const l of this.points)
                      if (
                        (({ shapeArgs: C } = l),
                        l.shapeType === "roundedRect" && C)
                      ) {
                        const { width: o = 0, height: i = 0, y: t = 0 } = C;
                        var P = t,
                          j = i;
                        g.scope === "stack" &&
                          l.stackTotal &&
                          ((P = h.translate(
                            v ? 100 : l.stackTotal,
                            !1,
                            !0,
                            !1,
                            !0
                          )),
                          (j = h.translate(m.threshold || 0, !1, !0, !1, !0)),
                          (j = this.crispCol(
                            0,
                            Math.min(P, j),
                            0,
                            Math.abs(P - j)
                          )),
                          (P = j.y),
                          (j = j.height));
                        const e = (l.negative ? -1 : 1) * (M ? -1 : 1) === -1;
                        let s = g.where;
                        !s &&
                          this.is("waterfall") &&
                          Math.abs(
                            (l.yBottom || 0) - (this.translatedThreshold || 0)
                          ) > this.borderWidth &&
                          (s = "all"),
                          s || (s = "end");
                        const a =
                          Math.min(
                            p(g.radius, o),
                            o / 2,
                            s === "all" ? i / 2 : 1 / 0
                          ) || 0;
                        s === "end" && (e && (P -= a), (j += a)),
                          N(C, { brBoxHeight: j, brBoxY: P, r: a });
                      }
                  }
                },
                { order: 9 }
              );
          }
          return (O = { optionsToObject: u }), O;
        }
      ),
      T(y, "Core/Responsive.js", [y["Core/Utilities.js"]], function (A) {
        const {
          diffObjects: O,
          extend: F,
          find: G,
          merge: U,
          pick: H,
          uniqueKey: Y,
        } = A;
        var S;
        return (
          (function (N) {
            function D(f, u) {
              const n = f.condition;
              (
                n.callback ||
                function () {
                  return (
                    this.chartWidth <= H(n.maxWidth, Number.MAX_VALUE) &&
                    this.chartHeight <= H(n.maxHeight, Number.MAX_VALUE) &&
                    this.chartWidth >= H(n.minWidth, 0) &&
                    this.chartHeight >= H(n.minHeight, 0)
                  );
                }
              ).call(this) && u.push(f._id);
            }
            function c(f, u) {
              const n = this.options.responsive;
              var d = this.currentResponsive;
              let g = [];
              !u &&
                n &&
                n.rules &&
                n.rules.forEach((M) => {
                  typeof M._id > "u" && (M._id = Y()),
                    this.matchResponsiveRule(M, g);
                }, this),
                (u = U(
                  ...g
                    .map((M) => G((n || {}).rules || [], (C) => C._id === M))
                    .map((M) => M && M.chartOptions)
                )),
                (u.isResponsiveOptions = !0),
                (g = g.toString() || void 0),
                g !== (d && d.ruleIds) &&
                  (d && this.update(d.undoOptions, f, !0),
                  g
                    ? ((d = O(u, this.options, !0, this.collectionsWithUpdate)),
                      (d.isResponsiveOptions = !0),
                      (this.currentResponsive = {
                        ruleIds: g,
                        mergedOptions: u,
                        undoOptions: d,
                      }),
                      this.update(u, f, !0))
                    : (this.currentResponsive = void 0));
            }
            const p = [];
            N.compose = function (f) {
              return (
                A.pushUnique(p, f) &&
                  F(f.prototype, { matchResponsiveRule: D, setResponsive: c }),
                f
              );
            };
          })(S || (S = {})),
          S
        );
      }),
      T(
        y,
        "masters/highcharts.src.js",
        [
          y["Core/Globals.js"],
          y["Core/Utilities.js"],
          y["Core/Defaults.js"],
          y["Core/Animation/Fx.js"],
          y["Core/Animation/AnimationUtilities.js"],
          y["Core/Renderer/HTML/AST.js"],
          y["Core/Templating.js"],
          y["Core/Renderer/RendererUtilities.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Renderer/SVG/SVGRenderer.js"],
          y["Core/Renderer/HTML/HTMLElement.js"],
          y["Core/Renderer/HTML/HTMLRenderer.js"],
          y["Core/Axis/Axis.js"],
          y["Core/Axis/DateTimeAxis.js"],
          y["Core/Axis/LogarithmicAxis.js"],
          y["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
          y["Core/Axis/Tick.js"],
          y["Core/Tooltip.js"],
          y["Core/Series/Point.js"],
          y["Core/Pointer.js"],
          y["Core/Legend/Legend.js"],
          y["Core/Chart/Chart.js"],
          y["Core/Axis/Stacking/StackingAxis.js"],
          y["Core/Axis/Stacking/StackItem.js"],
          y["Core/Series/Series.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Series/Column/ColumnSeries.js"],
          y["Series/Column/ColumnDataLabel.js"],
          y["Series/Pie/PieSeries.js"],
          y["Series/Pie/PieDataLabel.js"],
          y["Core/Series/DataLabel.js"],
          y["Core/Responsive.js"],
          y["Core/Color/Color.js"],
          y["Core/Time.js"],
        ],
        function (
          A,
          O,
          F,
          G,
          U,
          H,
          Y,
          S,
          N,
          D,
          c,
          p,
          f,
          u,
          n,
          d,
          g,
          M,
          C,
          P,
          j,
          m,
          h,
          v,
          l,
          o,
          i,
          t,
          e,
          s,
          a,
          b,
          r,
          w
        ) {
          return (
            (A.animate = U.animate),
            (A.animObject = U.animObject),
            (A.getDeferredAnimation = U.getDeferredAnimation),
            (A.setAnimation = U.setAnimation),
            (A.stop = U.stop),
            (A.timers = G.timers),
            (A.AST = H),
            (A.Axis = f),
            (A.Chart = m),
            (A.chart = m.chart),
            (A.Fx = G),
            (A.Legend = j),
            (A.PlotLineOrBand = d),
            (A.Point = C),
            (A.Pointer = P),
            (A.Series = l),
            (A.StackItem = v),
            (A.SVGElement = N),
            (A.SVGRenderer = D),
            (A.Templating = Y),
            (A.Tick = g),
            (A.Time = w),
            (A.Tooltip = M),
            (A.Color = r),
            (A.color = r.parse),
            p.compose(D),
            c.compose(N),
            P.compose(m),
            j.compose(m),
            (A.defaultOptions = F.defaultOptions),
            (A.getOptions = F.getOptions),
            (A.time = F.defaultTime),
            (A.setOptions = F.setOptions),
            (A.dateFormat = Y.dateFormat),
            (A.format = Y.format),
            (A.numberFormat = Y.numberFormat),
            (A.addEvent = O.addEvent),
            (A.arrayMax = O.arrayMax),
            (A.arrayMin = O.arrayMin),
            (A.attr = O.attr),
            (A.clearTimeout = O.clearTimeout),
            (A.correctFloat = O.correctFloat),
            (A.createElement = O.createElement),
            (A.css = O.css),
            (A.defined = O.defined),
            (A.destroyObjectProperties = O.destroyObjectProperties),
            (A.discardElement = O.discardElement),
            (A.distribute = S.distribute),
            (A.erase = O.erase),
            (A.error = O.error),
            (A.extend = O.extend),
            (A.extendClass = O.extendClass),
            (A.find = O.find),
            (A.fireEvent = O.fireEvent),
            (A.getMagnitude = O.getMagnitude),
            (A.getStyle = O.getStyle),
            (A.inArray = O.inArray),
            (A.isArray = O.isArray),
            (A.isClass = O.isClass),
            (A.isDOMElement = O.isDOMElement),
            (A.isFunction = O.isFunction),
            (A.isNumber = O.isNumber),
            (A.isObject = O.isObject),
            (A.isString = O.isString),
            (A.keys = O.keys),
            (A.merge = O.merge),
            (A.normalizeTickInterval = O.normalizeTickInterval),
            (A.objectEach = O.objectEach),
            (A.offset = O.offset),
            (A.pad = O.pad),
            (A.pick = O.pick),
            (A.pInt = O.pInt),
            (A.relativeLength = O.relativeLength),
            (A.removeEvent = O.removeEvent),
            (A.seriesType = o.seriesType),
            (A.splat = O.splat),
            (A.stableSort = O.stableSort),
            (A.syncTimeout = O.syncTimeout),
            (A.timeUnits = O.timeUnits),
            (A.uniqueKey = O.uniqueKey),
            (A.useSerialIds = O.useSerialIds),
            (A.wrap = O.wrap),
            t.compose(i),
            a.compose(l),
            u.compose(f),
            n.compose(f),
            s.compose(e),
            d.compose(f),
            b.compose(m),
            h.compose(f, m, l),
            M.compose(P),
            A
          );
        }
      ),
      T(
        y,
        "Core/Axis/BrokenAxis.js",
        [y["Core/Axis/Stacking/StackItem.js"], y["Core/Utilities.js"]],
        function (A, O) {
          const {
            addEvent: F,
            find: G,
            fireEvent: U,
            isArray: H,
            isNumber: Y,
            pick: S,
          } = O;
          var N;
          return (
            (function (D) {
              function c() {
                typeof this.brokenAxis < "u" &&
                  this.brokenAxis.setBreaks(this.options.breaks, !1);
              }
              function p() {
                this.brokenAxis &&
                  this.brokenAxis.hasBreaks &&
                  (this.options.ordinal = !1);
              }
              function f() {
                const j = this.brokenAxis;
                if (j && j.hasBreaks) {
                  const m = this.tickPositions,
                    h = this.tickPositions.info,
                    v = [];
                  for (let l = 0; l < m.length; l++)
                    j.isInAnyBreak(m[l]) || v.push(m[l]);
                  (this.tickPositions = v), (this.tickPositions.info = h);
                }
              }
              function u() {
                this.brokenAxis || (this.brokenAxis = new P(this));
              }
              function n() {
                const {
                  isDirty: j,
                  options: { connectNulls: m },
                  points: h,
                  xAxis: v,
                  yAxis: l,
                } = this;
                if (j) {
                  let o = h.length;
                  for (; o--; ) {
                    const i = h[o],
                      t =
                        !(i.y === null && m === !1) &&
                        ((v &&
                          v.brokenAxis &&
                          v.brokenAxis.isInAnyBreak(i.x, !0)) ||
                          (l &&
                            l.brokenAxis &&
                            l.brokenAxis.isInAnyBreak(i.y, !0)));
                    i.visible = t ? !1 : i.options.visible !== !1;
                  }
                }
              }
              function d() {
                this.drawBreaks(this.xAxis, ["x"]),
                  this.drawBreaks(this.yAxis, S(this.pointArrayMap, ["y"]));
              }
              function g(j, m) {
                const h = this,
                  v = h.points;
                let l, o, i, t;
                if (j && j.brokenAxis && j.brokenAxis.hasBreaks) {
                  const e = j.brokenAxis;
                  m.forEach(function (s) {
                    (l = (e && e.breakArray) || []),
                      (o = j.isXAxis ? j.min : S(h.options.threshold, j.min)),
                      v.forEach(function (a) {
                        (t = S(a["stack" + s.toUpperCase()], a[s])),
                          l.forEach(function (b) {
                            Y(o) &&
                              Y(t) &&
                              ((i = !1),
                              (o < b.from && t > b.to) ||
                              (o > b.from && t < b.from)
                                ? (i = "pointBreak")
                                : ((o < b.from && t > b.from && t < b.to) ||
                                    (o > b.from && t > b.to && t < b.from)) &&
                                  (i = "pointInBreak"),
                              i && U(j, i, { point: a, brk: b }));
                          });
                      });
                  });
                }
              }
              function M() {
                var j = this.currentDataGrouping,
                  m = j && j.gapSize;
                j = this.points.slice();
                const h = this.yAxis;
                let v = this.options.gapSize,
                  l = j.length - 1;
                var o;
                if (v && 0 < l)
                  for (
                    this.options.gapUnit !== "value" &&
                      (v *= this.basePointRange),
                      m && m > v && m >= this.basePointRange && (v = m);
                    l--;

                  )
                    (o && o.visible !== !1) || (o = j[l + 1]),
                      (m = j[l]),
                      o.visible !== !1 &&
                        m.visible !== !1 &&
                        (o.x - m.x > v &&
                          ((o = (m.x + o.x) / 2),
                          j.splice(l + 1, 0, { isNull: !0, x: o }),
                          h.stacking &&
                            this.options.stacking &&
                            ((o = h.stacking.stacks[this.stackKey][o] =
                              new A(
                                h,
                                h.options.stackLabels,
                                !1,
                                o,
                                this.stack
                              )),
                            (o.total = 0))),
                        (o = m));
                return this.getGraphPath(j);
              }
              const C = [];
              D.compose = function (j, m) {
                if (
                  (O.pushUnique(C, j) &&
                    (j.keepProps.push("brokenAxis"),
                    F(j, "init", u),
                    F(j, "afterInit", c),
                    F(j, "afterSetTickPositions", f),
                    F(j, "afterSetOptions", p)),
                  O.pushUnique(C, m))
                ) {
                  const h = m.prototype;
                  (h.drawBreaks = g),
                    (h.gappedPath = M),
                    F(m, "afterGeneratePoints", n),
                    F(m, "afterRender", d);
                }
                return j;
              };
              class P {
                static isInBreak(m, h) {
                  const v = m.repeat || 1 / 0,
                    l = m.from,
                    o = m.to - m.from;
                  return (
                    (h = h >= l ? (h - l) % v : v - ((l - h) % v)),
                    m.inclusive ? h <= o : h < o && h !== 0
                  );
                }
                static lin2Val(m) {
                  var h = this.brokenAxis;
                  if (((h = h && h.breakArray), !h || !Y(m))) return m;
                  let v, l;
                  for (l = 0; l < h.length && ((v = h[l]), !(v.from >= m)); l++)
                    (v.to < m || P.isInBreak(v, m)) && (m += v.len);
                  return m;
                }
                static val2Lin(m) {
                  var h = this.brokenAxis;
                  if (((h = h && h.breakArray), !h || !Y(m))) return m;
                  let v = m,
                    l,
                    o;
                  for (o = 0; o < h.length; o++)
                    if (((l = h[o]), l.to <= m)) v -= l.len;
                    else {
                      if (l.from >= m) break;
                      if (P.isInBreak(l, m)) {
                        v -= m - l.from;
                        break;
                      }
                    }
                  return v;
                }
                constructor(m) {
                  (this.hasBreaks = !1), (this.axis = m);
                }
                findBreakAt(m, h) {
                  return G(h, function (v) {
                    return v.from < m && m < v.to;
                  });
                }
                isInAnyBreak(m, h) {
                  const v = this.axis,
                    l = v.options.breaks || [];
                  let o = l.length,
                    i,
                    t,
                    e;
                  if (o && Y(m)) {
                    for (; o--; )
                      P.isInBreak(l[o], m) &&
                        ((i = !0), t || (t = S(l[o].showPoints, !v.isXAxis)));
                    e = i && h ? i && !t : i;
                  }
                  return e;
                }
                setBreaks(m, h) {
                  const v = this,
                    l = v.axis,
                    o = H(m) && !!m.length;
                  (l.isDirty = v.hasBreaks !== o),
                    (v.hasBreaks = o),
                    m !== l.options.breaks &&
                      (l.options.breaks = l.userOptions.breaks = m),
                    (l.forceRedraw = !0),
                    l.series.forEach(function (i) {
                      i.isDirty = !0;
                    }),
                    o ||
                      l.val2lin !== P.val2Lin ||
                      (delete l.val2lin, delete l.lin2val),
                    o &&
                      ((l.userOptions.ordinal = !1),
                      (l.lin2val = P.lin2Val),
                      (l.val2lin = P.val2Lin),
                      (l.setExtremes = function (i, t, e, s, a) {
                        if (v.hasBreaks) {
                          const b = this.options.breaks || [];
                          let r;
                          for (; (r = v.findBreakAt(i, b)); ) i = r.to;
                          for (; (r = v.findBreakAt(t, b)); ) t = r.from;
                          t < i && (t = i);
                        }
                        l.constructor.prototype.setExtremes.call(
                          this,
                          i,
                          t,
                          e,
                          s,
                          a
                        );
                      }),
                      (l.setAxisTranslation = function () {
                        if (
                          (l.constructor.prototype.setAxisTranslation.call(
                            this
                          ),
                          (v.unitLength = void 0),
                          v.hasBreaks)
                        ) {
                          const i = l.options.breaks || [],
                            t = [],
                            e = [],
                            s = S(l.pointRangePadding, 0);
                          let a = 0,
                            b,
                            r,
                            w = l.userMin || l.min,
                            L = l.userMax || l.max,
                            I,
                            V;
                          i.forEach(function (B) {
                            (r = B.repeat || 1 / 0),
                              Y(w) &&
                                Y(L) &&
                                (P.isInBreak(B, w) &&
                                  (w += (B.to % r) - (w % r)),
                                P.isInBreak(B, L) &&
                                  (L -= (L % r) - (B.from % r)));
                          }),
                            i.forEach(function (B) {
                              if (
                                ((I = B.from),
                                (r = B.repeat || 1 / 0),
                                Y(w) && Y(L))
                              ) {
                                for (; I - r > w; ) I -= r;
                                for (; I < w; ) I += r;
                                for (V = I; V < L; V += r)
                                  t.push({ value: V, move: "in" }),
                                    t.push({
                                      value: V + B.to - B.from,
                                      move: "out",
                                      size: B.breakSize,
                                    });
                              }
                            }),
                            t.sort(function (B, x) {
                              return B.value === x.value
                                ? (B.move === "in" ? 0 : 1) -
                                    (x.move === "in" ? 0 : 1)
                                : B.value - x.value;
                            }),
                            (b = 0),
                            (I = w),
                            t.forEach(function (B) {
                              (b += B.move === "in" ? 1 : -1),
                                b === 1 && B.move === "in" && (I = B.value),
                                b === 0 &&
                                  Y(I) &&
                                  (e.push({
                                    from: I,
                                    to: B.value,
                                    len: B.value - I - (B.size || 0),
                                  }),
                                  (a += B.value - I - (B.size || 0)));
                            }),
                            (v.breakArray = e),
                            Y(w) &&
                              Y(L) &&
                              Y(l.min) &&
                              ((v.unitLength = L - w - a + s),
                              U(l, "afterBreaks"),
                              l.staticScale
                                ? (l.transA = l.staticScale)
                                : v.unitLength &&
                                  (l.transA *= (L - l.min + s) / v.unitLength),
                              s &&
                                (l.minPixelPadding =
                                  l.transA * (l.minPointOffset || 0)),
                              (l.min = w),
                              (l.max = L));
                        }
                      })),
                    S(h, !0) && l.chart.redraw();
                }
              }
              D.Additions = P;
            })(N || (N = {})),
            N
          );
        }
      ),
      T(
        y,
        "masters/modules/broken-axis.src.js",
        [y["Core/Globals.js"], y["Core/Axis/BrokenAxis.js"]],
        function (A, O) {
          O.compose(A.Axis, A.Series);
        }
      ),
      T(y, "Extensions/DataGrouping/ApproximationRegistry.js", [], function () {
        return {};
      }),
      T(
        y,
        "Extensions/DataGrouping/ApproximationDefaults.js",
        [
          y["Extensions/DataGrouping/ApproximationRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O) {
          function F(D) {
            const c = D.length;
            return (D = G(D)), N(D) && c && (D = Y(D / c)), D;
          }
          function G(D) {
            let c = D.length,
              p;
            if (!c && D.hasNulls) p = null;
            else if (c) for (p = 0; c--; ) p += D[c];
            return p;
          }
          const {
            arrayMax: U,
            arrayMin: H,
            correctFloat: Y,
            extend: S,
            isNumber: N,
          } = O;
          return (
            (O = {
              average: F,
              averages: function () {
                const D = [];
                return (
                  [].forEach.call(arguments, function (c) {
                    D.push(F(c));
                  }),
                  typeof D[0] > "u" ? void 0 : D
                );
              },
              close: function (D) {
                return D.length ? D[D.length - 1] : D.hasNulls ? null : void 0;
              },
              high: function (D) {
                return D.length ? U(D) : D.hasNulls ? null : void 0;
              },
              hlc: function (D, c, p) {
                if (
                  ((D = A.high(D)),
                  (c = A.low(c)),
                  (p = A.close(p)),
                  N(D) || N(c) || N(p))
                )
                  return [D, c, p];
              },
              low: function (D) {
                return D.length ? H(D) : D.hasNulls ? null : void 0;
              },
              ohlc: function (D, c, p, f) {
                if (
                  ((D = A.open(D)),
                  (c = A.high(c)),
                  (p = A.low(p)),
                  (f = A.close(f)),
                  N(D) || N(c) || N(p) || N(f))
                )
                  return [D, c, p, f];
              },
              open: function (D) {
                return D.length ? D[0] : D.hasNulls ? null : void 0;
              },
              range: function (D, c) {
                if (((D = A.low(D)), (c = A.high(c)), N(D) || N(c)))
                  return [D, c];
                if (D === null && c === null) return null;
              },
              sum: G,
            }),
            S(A, O),
            O
          );
        }
      ),
      T(y, "Extensions/DataGrouping/DataGroupingDefaults.js", [], function () {
        return {
          common: {
            groupPixelWidth: 2,
            dateTimeLabelFormats: {
              millisecond: [
                "%A, %e %b, %H:%M:%S.%L",
                "%A, %e %b, %H:%M:%S.%L",
                "-%H:%M:%S.%L",
              ],
              second: [
                "%A, %e %b, %H:%M:%S",
                "%A, %e %b, %H:%M:%S",
                "-%H:%M:%S",
              ],
              minute: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"],
              hour: ["%A, %e %b, %H:%M", "%A, %e %b, %H:%M", "-%H:%M"],
              day: ["%A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"],
              week: ["Week from %A, %e %b %Y", "%A, %e %b", "-%A, %e %b %Y"],
              month: ["%B %Y", "%B", "-%B %Y"],
              year: ["%Y", "%Y", "-%Y"],
            },
          },
          seriesSpecific: {
            line: {},
            spline: {},
            area: {},
            areaspline: {},
            arearange: {},
            column: { groupPixelWidth: 10 },
            columnrange: { groupPixelWidth: 10 },
            candlestick: { groupPixelWidth: 10 },
            ohlc: { groupPixelWidth: 5 },
            hlc: { groupPixelWidth: 5 },
            heikinashi: { groupPixelWidth: 10 },
          },
          units: [
            ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
            ["second", [1, 2, 5, 10, 15, 30]],
            ["minute", [1, 2, 5, 10, 15, 30]],
            ["hour", [1, 2, 3, 4, 6, 8, 12]],
            ["day", [1]],
            ["week", [1]],
            ["month", [1, 3, 6]],
            ["year", null],
          ],
        };
      }),
      T(
        y,
        "Extensions/DataGrouping/DataGroupingAxisComposition.js",
        [
          y["Extensions/DataGrouping/DataGroupingDefaults.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O) {
          function F(f) {
            const u = this,
              n = u.series;
            n.forEach(function (d) {
              d.groupPixelWidth = void 0;
            }),
              n.forEach(function (d) {
                (d.groupPixelWidth =
                  u.getGroupPixelWidth && u.getGroupPixelWidth()),
                  d.groupPixelWidth && (d.hasProcessed = !0),
                  d.applyGrouping(!!f.hasExtremesChanged);
              });
          }
          function G() {
            const f = this.series;
            let u = f.length,
              n = 0,
              d = !1,
              g,
              M;
            for (; u--; )
              (M = f[u].options.dataGrouping) &&
                ((n = Math.max(
                  n,
                  D(M.groupPixelWidth, A.common.groupPixelWidth)
                )),
                (g = (f[u].processedXData || f[u].data).length),
                (f[u].groupPixelWidth ||
                  g > this.chart.plotSizeX / n ||
                  (g && M.forced)) &&
                  (d = !0));
            return d ? n : 0;
          }
          function U() {
            this.series.forEach(function (f) {
              f.hasProcessed = !1;
            });
          }
          function H(f, u) {
            let n;
            if (
              ((u = D(u, !0)),
              f || (f = { forced: !1, units: null }),
              this instanceof p)
            )
              for (n = this.series.length; n--; )
                this.series[n].update({ dataGrouping: f }, !1);
            else
              this.chart.options.series.forEach(function (d) {
                d.dataGrouping =
                  typeof f == "boolean" ? f : N(f, d.dataGrouping);
              });
            this.ordinal && (this.ordinal.slope = void 0),
              u && this.chart.redraw();
          }
          const { addEvent: Y, extend: S, merge: N, pick: D } = O,
            c = [];
          let p;
          return {
            compose: function (f) {
              (p = f),
                O.pushUnique(c, f) &&
                  (Y(f, "afterSetScale", U),
                  Y(f, "postProcessData", F),
                  S(f.prototype, {
                    applyGrouping: F,
                    getGroupPixelWidth: G,
                    setDataGrouping: H,
                  }));
            },
          };
        }
      ),
      T(
        y,
        "Extensions/DataGrouping/DataGroupingSeriesComposition.js",
        [
          y["Extensions/DataGrouping/ApproximationRegistry.js"],
          y["Extensions/DataGrouping/DataGroupingDefaults.js"],
          y["Core/Axis/DateTimeAxis.js"],
          y["Core/Defaults.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H) {
          function Y(h) {
            var v = this.chart,
              l = this.options.dataGrouping,
              o = this.allowDG !== !1 && l && P(l.enabled, v.options.isStock),
              i = this.visible || !v.options.chart.ignoreHiddenSeries;
            const t = this.currentDataGrouping;
            var e = !1;
            if (
              (o && !this.requireSorting && (this.requireSorting = e = !0),
              (h =
                !!(
                  this.isCartesian &&
                  !this.isDirty &&
                  !this.xAxis.isDirty &&
                  !this.yAxis.isDirty &&
                  !h
                ) || !o),
              e && (this.requireSorting = !1),
              !h)
            ) {
              this.destroyGroupedData(),
                (h = l.groupAll ? this.xData : this.processedXData),
                (o = l.groupAll ? this.yData : this.processedYData);
              var s = v.plotSizeX;
              e = this.xAxis;
              var a = e.options.ordinal,
                b = this.groupPixelWidth,
                r;
              let R;
              if (b && h && h.length && s) {
                (this.isDirty = R = !0), (this.points = null);
                var w = e.getExtremes(),
                  L = w.min;
                (w = w.max),
                  (a =
                    (a &&
                      e.ordinal &&
                      e.ordinal.getGroupIntervalFactor(L, w, this)) ||
                    1),
                  (s = e.getTimeTicks(
                    F.Additions.prototype.normalizeTimeTickInterval(
                      ((b * (w - L)) / s) * a,
                      l.units || O.units
                    ),
                    Math.min(L, h[0]),
                    Math.max(w, h[h.length - 1]),
                    e.options.startOfWeek,
                    h,
                    this.closestPointRange
                  )),
                  (b = f.groupData.apply(this, [h, o, s, l.approximation])),
                  (h = b.groupedXData),
                  (o = b.groupedYData),
                  (a = 0),
                  l &&
                    l.smoothed &&
                    h.length &&
                    ((l.firstAnchor = "firstPoint"),
                    (l.anchor = "middle"),
                    (l.lastAnchor = "lastPoint"),
                    d(32, !1, v, {
                      "dataGrouping.smoothed": "use dataGrouping.anchor",
                    })),
                  (v = h);
                var I = w,
                  V = this.options.dataGrouping;
                if (
                  ((w =
                    this.currentDataGrouping &&
                    this.currentDataGrouping.gapSize),
                  V && this.xData && w && this.groupMap)
                ) {
                  L = v.length - 1;
                  var B = V.anchor;
                  const W = P(V.firstAnchor, B);
                  if (((V = P(V.lastAnchor, B)), B && B !== "start")) {
                    var x = w * { middle: 0.5, end: 1 }[B];
                    for (B = v.length - 1; B-- && 0 < B; ) v[B] += x;
                  }
                  W &&
                    W !== "start" &&
                    this.xData[0] >= v[0] &&
                    ((B = this.groupMap[0].start),
                    (x = this.groupMap[0].length),
                    M(B) && M(x) && (r = B + (x - 1)),
                    (v[0] = {
                      middle: v[0] + 0.5 * w,
                      end: v[0] + w,
                      firstPoint: this.xData[0],
                      lastPoint: r && this.xData[r],
                    }[W])),
                    V &&
                      V !== "start" &&
                      w &&
                      v[L] >= I - w &&
                      ((r = this.groupMap[this.groupMap.length - 1].start),
                      (v[L] = {
                        middle: v[L] + 0.5 * w,
                        end: v[L] + w,
                        firstPoint: r && this.xData[r],
                        lastPoint: this.xData[this.xData.length - 1],
                      }[V]));
                }
                for (r = 1; r < s.length; r++)
                  (s.info.segmentStarts &&
                    s.info.segmentStarts.indexOf(r) !== -1) ||
                    (a = Math.max(s[r] - s[r - 1], a));
                (w = s.info),
                  (w.gapSize = a),
                  (this.closestPointRange = s.info.totalRange),
                  (this.groupMap = b.groupMap),
                  i &&
                    ((i = e),
                    (r = h),
                    n(r[0]) &&
                      M(i.min) &&
                      M(i.dataMin) &&
                      r[0] < i.min &&
                      (((!n(i.options.min) && i.min <= i.dataMin) ||
                        i.min === i.dataMin) &&
                        (i.min = Math.min(r[0], i.min)),
                      (i.dataMin = Math.min(r[0], i.dataMin))),
                    n(r[r.length - 1]) &&
                      M(i.max) &&
                      M(i.dataMax) &&
                      r[r.length - 1] > i.max &&
                      (((!n(i.options.max) &&
                        M(i.dataMax) &&
                        i.max >= i.dataMax) ||
                        i.max === i.dataMax) &&
                        (i.max = Math.max(r[r.length - 1], i.max)),
                      (i.dataMax = Math.max(r[r.length - 1], i.dataMax)))),
                  l.groupAll &&
                    ((this.allGroupedData = o),
                    (l = this.cropData(h, o, e.min, e.max, 1)),
                    (h = l.xData),
                    (o = l.yData),
                    (this.cropStart = l.start)),
                  (this.processedXData = h),
                  (this.processedYData = o);
              } else this.groupMap = null;
              (this.hasGroupedData = R),
                (this.currentDataGrouping = w),
                (this.preventGraphAnimation =
                  (t && t.totalRange) !== (w && w.totalRange));
            }
          }
          function S() {
            this.groupedData &&
              (this.groupedData.forEach(function (h, v) {
                h && (this.groupedData[v] = h.destroy ? h.destroy() : null);
              }, this),
              (this.groupedData.length = 0));
          }
          function N() {
            j.apply(this),
              this.destroyGroupedData(),
              (this.groupedData = this.hasGroupedData ? this.points : null);
          }
          function D() {
            return this.is("arearange")
              ? "range"
              : this.is("ohlc")
              ? "ohlc"
              : this.is("hlc")
              ? "hlc"
              : this.is("column") || this.options.cumulative
              ? "sum"
              : "average";
          }
          function c(h, v, l, o) {
            const i = this,
              t = i.data,
              e = i.options && i.options.data,
              s = [],
              a = [],
              b = [],
              r = h.length,
              w = !!v,
              L = [],
              I = i.pointArrayMap,
              V = I && I.length,
              B = ["x"].concat(I || ["y"]),
              x =
                this.options.dataGrouping && this.options.dataGrouping.groupAll;
            let R = 0,
              W = 0;
            if (
              ((o =
                typeof o == "function"
                  ? o
                  : o && A[o]
                  ? A[o]
                  : A[
                      (i.getDGApproximation && i.getDGApproximation()) ||
                        "average"
                    ]),
              V)
            )
              for (var X = I.length; X--; ) L.push([]);
            else L.push([]);
            X = V || 1;
            for (let _ = 0; _ <= r; _++)
              if (!(h[_] < l[0])) {
                for (
                  ;
                  (typeof l[R + 1] < "u" && h[_] >= l[R + 1]) || _ === r;

                ) {
                  var Z = l[R];
                  i.dataGroupInfo = {
                    start: x ? W : i.cropStart + W,
                    length: L[0].length,
                  };
                  var E = o.apply(i, L);
                  for (
                    i.pointClass &&
                      !n(i.dataGroupInfo.options) &&
                      ((i.dataGroupInfo.options = C(
                        i.pointClass.prototype.optionsToObject.call(
                          { series: i },
                          i.options.data[i.cropStart + W]
                        )
                      )),
                      B.forEach(function (z) {
                        delete i.dataGroupInfo.options[z];
                      })),
                      typeof E < "u" &&
                        (s.push(Z), a.push(E), b.push(i.dataGroupInfo)),
                      W = _,
                      Z = 0;
                    Z < X;
                    Z++
                  )
                    (L[Z].length = 0), (L[Z].hasNulls = !1);
                  if (((R += 1), _ === r)) break;
                }
                if (_ === r) break;
                if (I) {
                  (Z =
                    i.options.dataGrouping && i.options.dataGrouping.groupAll
                      ? _
                      : i.cropStart + _),
                    (Z =
                      (t && t[Z]) ||
                      i.pointClass.prototype.applyOptions.apply({ series: i }, [
                        e[Z],
                      ]));
                  for (let z = 0; z < V; z++)
                    (E = Z[I[z]]),
                      M(E) ? L[z].push(E) : E === null && (L[z].hasNulls = !0);
                } else
                  (Z = w ? v[_] : null),
                    M(Z) ? L[0].push(Z) : Z === null && (L[0].hasNulls = !0);
              }
            return { groupedXData: s, groupedYData: a, groupMap: b };
          }
          function p(h) {
            h = h.options;
            const v = this.type,
              l = this.chart.options.plotOptions,
              o = this.useCommonDataGrouping && O.common,
              i = O.seriesSpecific;
            let t = G.defaultOptions.plotOptions[v].dataGrouping;
            if (l && (i[v] || o)) {
              const e = this.chart.rangeSelector;
              t || (t = C(O.common, i[v])),
                (h.dataGrouping = C(
                  o,
                  t,
                  l.series && l.series.dataGrouping,
                  l[v].dataGrouping,
                  this.userOptions.dataGrouping,
                  !h.isInternal &&
                    e &&
                    M(e.selected) &&
                    e.buttonOptions[e.selected].dataGrouping
                ));
            }
          }
          const {
              series: { prototype: f },
            } = U,
            {
              addEvent: u,
              defined: n,
              error: d,
              extend: g,
              isNumber: M,
              merge: C,
              pick: P,
            } = H,
            j = f.generatePoints,
            m = [];
          return {
            compose: function (h) {
              const v = h.prototype.pointClass;
              H.pushUnique(m, v) &&
                u(v, "update", function () {
                  if (this.dataGroup) return d(24, !1, this.series.chart), !1;
                }),
                H.pushUnique(m, h) &&
                  (u(h, "afterSetOptions", p),
                  u(h, "destroy", S),
                  g(h.prototype, {
                    applyGrouping: Y,
                    destroyGroupedData: S,
                    generatePoints: N,
                    getDGApproximation: D,
                    groupData: c,
                  }));
            },
            groupData: c,
          };
        }
      ),
      T(
        y,
        "Extensions/DataGrouping/DataGrouping.js",
        [
          y["Extensions/DataGrouping/DataGroupingAxisComposition.js"],
          y["Extensions/DataGrouping/DataGroupingDefaults.js"],
          y["Extensions/DataGrouping/DataGroupingSeriesComposition.js"],
          y["Core/Templating.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U) {
          function H(p) {
            const f = this.chart,
              u = f.time,
              n = p.labelConfig,
              d = n.series;
            var g = d.tooltipOptions,
              M = d.options.dataGrouping;
            const C = d.xAxis;
            var P = g.xDateFormat;
            let j,
              m,
              h = g[p.isFooter ? "footerFormat" : "headerFormat"];
            C &&
              C.options.type === "datetime" &&
              M &&
              D(n.key) &&
              ((m = d.currentDataGrouping),
              (M = M.dateTimeLabelFormats || O.common.dateTimeLabelFormats),
              m
                ? ((g = M[m.unitName]),
                  m.count === 1 ? (P = g[0]) : ((P = g[1]), (j = g[2])))
                : !P &&
                  M &&
                  C.dateTime &&
                  (P = C.dateTime.getXDateFormat(n.x, g.dateTimeLabelFormats)),
              (P = u.dateFormat(P, n.key)),
              j && (P += u.dateFormat(j, n.key + m.totalRange - 1)),
              d.chart.styledMode && (h = this.styledModeFormat(h)),
              (p.text = Y(h, { point: N(n.point, { key: P }), series: d }, f)),
              p.preventDefault());
          }
          const { format: Y } = G,
            { addEvent: S, extend: N, isNumber: D } = U,
            c = [];
          return (
            (G = {
              compose: function (p, f, u) {
                A.compose(p),
                  F.compose(f),
                  u && U.pushUnique(c, u) && S(u, "headerFormatter", H);
              },
              groupData: F.groupData,
            }),
            G
          );
        }
      ),
      T(
        y,
        "masters/modules/datagrouping.src.js",
        [
          y["Core/Globals.js"],
          y["Extensions/DataGrouping/ApproximationDefaults.js"],
          y["Extensions/DataGrouping/ApproximationRegistry.js"],
          y["Extensions/DataGrouping/DataGrouping.js"],
        ],
        function (A, O, F, G) {
          (A.dataGrouping = { approximationDefaults: O, approximations: F }),
            G.compose(A.Axis, A.Series, A.Tooltip);
        }
      ),
      T(
        y,
        "Extensions/MouseWheelZoom/MouseWheelZoom.js",
        [y["Core/Utilities.js"]],
        function (A) {
          function O() {
            const n = this,
              d = D(n.options.chart.zooming.mouseWheel);
            d.enabled &&
              F(this.container, "wheel", (g) => {
                if (
                  ((g = this.pointer.normalize(g)),
                  n.isInsidePlot(g.chartX - n.plotLeft, g.chartY - n.plotTop))
                ) {
                  const M = U(d.sensitivity, 1.1);
                  u(
                    n,
                    Math.pow(M, g.detail || (g.deltaY || 0) / 120),
                    n.xAxis[0].toValue(g.chartX),
                    n.yAxis[0].toValue(g.chartY),
                    g.chartX,
                    g.chartY,
                    d
                  );
                }
                g.preventDefault && g.preventDefault();
              });
          }
          const { addEvent: F, isObject: G, pick: U, defined: H, merge: Y } = A,
            S = [],
            N = { enabled: !0, sensitivity: 1.1 },
            D = (n) => (G(n) ? Y(N, n) : Y(N, { enabled: H(n) ? n : !0 })),
            c = function (n, d) {
              return (
                n.x + n.width > d.x + d.width &&
                  (n.width > d.width
                    ? ((n.width = d.width), (n.x = d.x))
                    : (n.x = d.x + d.width - n.width)),
                n.width > d.width && (n.width = d.width),
                n.x < d.x && (n.x = d.x),
                n.y + n.height > d.y + d.height &&
                  (n.height > d.height
                    ? ((n.height = d.height), (n.y = d.y))
                    : (n.y = d.y + d.height - n.height)),
                n.height > d.height && (n.height = d.height),
                n.y < d.y && (n.y = d.y),
                n
              );
            };
          let p, f;
          const u = function (n, d, g, M, C, P, j) {
            const m = n.xAxis[0],
              h = n.yAxis[0];
            var v = U(j.type, n.options.chart.zooming.type, "x");
            if (
              ((j = /x/.test(v)),
              (v = /y/.test(v)),
              H(m.max) &&
                H(m.min) &&
                H(h.max) &&
                H(h.min) &&
                H(m.dataMax) &&
                H(m.dataMin) &&
                H(h.dataMax) &&
                H(h.dataMin))
            ) {
              if (v) {
                H(p) && clearTimeout(p);
                const { startOnTick: a, endOnTick: b } = h.options;
                f || (f = { startOnTick: a, endOnTick: b }),
                  (a || b) && h.setOptions({ startOnTick: !1, endOnTick: !1 }),
                  (p = setTimeout(() => {
                    if (f) {
                      h.setOptions(f);
                      const { min: r, max: w } = h.getExtremes();
                      (h.forceRedraw = !0), h.setExtremes(r, w), (f = void 0);
                    }
                  }, 400));
              }
              if (n.inverted) {
                var l = h.pos + h.len;
                (g = m.toValue(P)), (M = h.toValue(C));
                var o = C;
                (C = P), (P = l - o + h.pos);
              }
              (C = C ? (C - m.pos) / m.len : 0.5),
                ((m.reversed && !n.inverted) || (n.inverted && !m.reversed)) &&
                  (C = 1 - C),
                (P = 1 - (P ? (P - h.pos) / h.len : 0.5)),
                h.reversed && (P = 1 - P),
                (l = m.max - m.min),
                (g = U(g, m.min + l / 2)),
                (l *= d),
                (o = h.max - h.min),
                (M = U(M, h.min + o / 2));
              const e = o * d;
              var i = m.dataMax - m.dataMin,
                t = h.dataMax - h.dataMin;
              (o = m.dataMin - i * m.options.minPadding),
                (i = i + i * m.options.minPadding + i * m.options.maxPadding);
              const s = h.dataMin - t * h.options.minPadding;
              (t = t + t * h.options.minPadding + t * h.options.maxPadding),
                (C = c(
                  { x: g - l * C, y: M - e * P, width: l, height: e },
                  { x: o, y: s, width: i, height: t }
                )),
                (P = C.x <= o && C.width >= i && C.y <= s && C.height >= t),
                H(d) && !P
                  ? (j && m.setExtremes(C.x, C.x + C.width, !1),
                    v && h.setExtremes(C.y, C.y + C.height, !1))
                  : (j && m.setExtremes(void 0, void 0, !1),
                    v && h.setExtremes(void 0, void 0, !1)),
                n.redraw(!1);
            }
          };
          return {
            compose: function (n) {
              S.indexOf(n) === -1 && (S.push(n), F(n, "afterGetContainer", O));
            },
          };
        }
      ),
      T(
        y,
        "masters/modules/mouse-wheel-zoom.src.js",
        [
          y["Core/Globals.js"],
          y["Extensions/MouseWheelZoom/MouseWheelZoom.js"],
        ],
        function (A, O) {
          O.compose(A.Chart);
        }
      ),
      T(
        y,
        "Series/DataModifyComposition.js",
        [
          y["Core/Axis/Axis.js"],
          y["Core/Series/Point.js"],
          y["Core/Series/Series.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          const {
              prototype: { tooltipFormatter: U },
            } = O,
            {
              addEvent: H,
              arrayMax: Y,
              arrayMin: S,
              correctFloat: N,
              defined: D,
              isArray: c,
              isNumber: p,
              isString: f,
              pick: u,
            } = G;
          var n;
          return (
            (function (d) {
              function g(t, e, s) {
                this.isXAxis ||
                  (this.series.forEach(function (a) {
                    t === "compare" && typeof e != "boolean"
                      ? a.setCompare(e, !1)
                      : t !== "cumulative" || f(e) || a.setCumulative(e, !1);
                  }),
                  u(s, !0) && this.chart.redraw());
              }
              function M(t) {
                const e = this,
                  { numberFormatter: s } = e.series.chart,
                  a = function (b) {
                    t = t.replace(
                      "{point." + b + "}",
                      (0 < e[b] && b === "change" ? "+" : "") +
                        s(e[b], u(e.series.tooltipOptions.changeDecimals, 2))
                    );
                  };
                return (
                  D(e.change) && a("change"),
                  D(e.cumulativeSum) && a("cumulativeSum"),
                  U.apply(this, [t])
                );
              }
              function C() {
                const t = this.options.compare;
                let e;
                (t === "percent" || t === "value" || this.options.cumulative) &&
                  ((e = new i(this)),
                  t === "percent" || t === "value"
                    ? e.initCompare(t)
                    : e.initCumulative()),
                  (this.dataModify = e);
              }
              function P(t) {
                t = t.dataExtremes;
                const e = t.activeYData;
                if (this.dataModify && t) {
                  let s;
                  this.options.compare
                    ? (s = [
                        this.dataModify.modifyValue(t.dataMin),
                        this.dataModify.modifyValue(t.dataMax),
                      ])
                    : this.options.cumulative &&
                      c(e) &&
                      2 <= e.length &&
                      (s = i.getCumulativeExtremes(e)),
                    s && ((t.dataMin = S(s)), (t.dataMax = Y(s)));
                }
              }
              function j(t, e) {
                (this.options.compare = this.userOptions.compare = t),
                  this.update({}, u(e, !0)),
                  !this.dataModify || (t !== "value" && t !== "percent")
                    ? this.points.forEach((s) => {
                        delete s.change;
                      })
                    : this.dataModify.initCompare(t);
              }
              function m() {
                if (this.xAxis && this.processedYData && this.dataModify) {
                  const t = this.processedXData,
                    e = this.processedYData,
                    s = e.length,
                    a = this.options.compareStart === !0 ? 0 : 1;
                  let b = -1,
                    r;
                  for (
                    this.pointArrayMap &&
                      (b = this.pointArrayMap.indexOf(
                        this.options.pointValKey || this.pointValKey || "y"
                      )),
                      r = 0;
                    r < s - a;
                    r++
                  ) {
                    const w = e[r] && -1 < b ? e[r][b] : e[r];
                    if (p(w) && w !== 0 && t[r + a] >= (this.xAxis.min || 0)) {
                      this.dataModify.compareValue = w;
                      break;
                    }
                  }
                }
              }
              function h(t, e) {
                this.setModifier("compare", t, e);
              }
              function v(t, e) {
                (t = u(t, !1)),
                  (this.options.cumulative = this.userOptions.cumulative = t),
                  this.update({}, u(e, !0)),
                  this.dataModify
                    ? this.dataModify.initCumulative()
                    : this.points.forEach((s) => {
                        delete s.cumulativeSum;
                      });
              }
              function l(t, e) {
                this.setModifier("cumulative", t, e);
              }
              const o = [];
              d.compose = function (t, e, s) {
                if (G.pushUnique(o, t)) {
                  const a = t.prototype;
                  (a.setCompare = j),
                    (a.setCumulative = v),
                    H(t, "afterInit", C),
                    H(t, "afterGetExtremes", P),
                    H(t, "afterProcessData", m);
                }
                return (
                  G.pushUnique(o, e) &&
                    ((e = e.prototype),
                    (e.setCompare = h),
                    (e.setModifier = g),
                    (e.setCumulative = l)),
                  G.pushUnique(o, s) && (s.prototype.tooltipFormatter = M),
                  t
                );
              };
              class i {
                constructor(e) {
                  this.series = e;
                }
                modifyValue() {
                  return 0;
                }
                static getCumulativeExtremes(e) {
                  let s = 1 / 0,
                    a = -1 / 0;
                  return (
                    e.reduce(
                      (b, r) => (
                        (r = b + r),
                        (s = Math.min(s, r, b)),
                        (a = Math.max(a, r, b)),
                        r
                      )
                    ),
                    [s, a]
                  );
                }
                initCompare(e) {
                  this.modifyValue = function (s, a) {
                    s === null && (s = 0);
                    const b = this.compareValue;
                    return typeof s < "u" && typeof b < "u"
                      ? ((s =
                          e === "value"
                            ? s - b
                            : (s / b) * 100 -
                              (this.series.options.compareBase === 100
                                ? 0
                                : 100)),
                        typeof a < "u" &&
                          (a = this.series.points[a]) &&
                          (a.change = s),
                        s)
                      : 0;
                  };
                }
                initCumulative() {
                  this.modifyValue = function (e, s) {
                    if ((e === null && (e = 0), e !== void 0 && s !== void 0)) {
                      const a = 0 < s ? this.series.points[s - 1] : null;
                      return (
                        a && a.cumulativeSum && (e = N(a.cumulativeSum + e)),
                        (s = this.series.points[s]) && (s.cumulativeSum = e),
                        e
                      );
                    }
                    return 0;
                  };
                }
              }
              d.Additions = i;
            })(n || (n = {})),
            n
          );
        }
      ),
      T(
        y,
        "Core/Axis/NavigatorAxisComposition.js",
        [y["Core/Globals.js"], y["Core/Utilities.js"]],
        function (A, O) {
          function F() {
            this.navigatorAxis || (this.navigatorAxis = new p(this));
          }
          function G(f) {
            var u = this.chart,
              n = u.options,
              d = n.navigator;
            const g = this.navigatorAxis,
              M = u.zooming.pinchType;
            (n = n.rangeSelector),
              (u = u.zooming.type),
              this.isXAxis &&
                ((d && d.enabled) || (n && n.enabled)) &&
                (u === "y"
                  ? (f.zoomed = !1)
                  : ((!U && u === "xy") || (U && M === "xy")) &&
                    this.options.range &&
                    ((d = g.previousZoom),
                    S(f.newMin)
                      ? (g.previousZoom = [this.min, this.max])
                      : d &&
                        ((f.newMin = d[0]),
                        (f.newMax = d[1]),
                        (g.previousZoom = void 0)))),
              typeof f.zoomed < "u" && f.preventDefault();
          }
          const { isTouchDevice: U } = A,
            {
              addEvent: H,
              correctFloat: Y,
              defined: S,
              isNumber: N,
              pick: D,
            } = O,
            c = [];
          class p {
            static compose(u) {
              O.pushUnique(c, u) &&
                (u.keepProps.push("navigatorAxis"),
                H(u, "init", F),
                H(u, "zoom", G));
            }
            constructor(u) {
              this.axis = u;
            }
            destroy() {
              this.axis = void 0;
            }
            toFixedRange(u, n, d, g) {
              const M = this.axis;
              var C = M.chart;
              (u = D(d, M.translate(u, !0, !M.horiz))),
                (n = D(g, M.translate(n, !0, !M.horiz))),
                (C = C && C.fixedRange);
              const P = (M.pointRange || 0) / 2;
              return (
                S(d) || (u = Y(u + P)),
                S(g) || (n = Y(n - P)),
                C &&
                  M.dataMin &&
                  M.dataMax &&
                  (n >= M.dataMax && (u = Y(M.dataMax - C)),
                  u <= M.dataMin && (n = Y(M.dataMin + C))),
                (N(u) && N(n)) || (u = n = void 0),
                { min: u, max: n }
              );
            }
          }
          return p;
        }
      ),
      T(
        y,
        "Stock/Navigator/NavigatorDefaults.js",
        [y["Core/Color/Color.js"], y["Core/Series/SeriesRegistry.js"]],
        function (A, O) {
          return (
            ({ parse: A } = A),
            ({ seriesTypes: O } = O),
            (O = {
              height: 40,
              margin: 25,
              maskInside: !0,
              handles: {
                width: 7,
                height: 15,
                symbols: ["navigator-handle", "navigator-handle"],
                enabled: !0,
                lineWidth: 1,
                backgroundColor: "#f2f2f2",
                borderColor: "#999999",
              },
              maskFill: A("#667aff").setOpacity(0.3).get(),
              outlineColor: "#999999",
              outlineWidth: 1,
              series: {
                type: typeof O.areaspline > "u" ? "line" : "areaspline",
                fillOpacity: 0.05,
                lineWidth: 1,
                compare: null,
                sonification: { enabled: !1 },
                dataGrouping: {
                  approximation: "average",
                  enabled: !0,
                  groupPixelWidth: 2,
                  firstAnchor: "firstPoint",
                  anchor: "middle",
                  lastAnchor: "lastPoint",
                  units: [
                    ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
                    ["second", [1, 2, 5, 10, 15, 30]],
                    ["minute", [1, 2, 5, 10, 15, 30]],
                    ["hour", [1, 2, 3, 4, 6, 8, 12]],
                    ["day", [1, 2, 3, 4]],
                    ["week", [1, 2, 3]],
                    ["month", [1, 3, 6]],
                    ["year", null],
                  ],
                },
                dataLabels: { enabled: !1, zIndex: 2 },
                id: "highcharts-navigator-series",
                className: "highcharts-navigator-series",
                lineColor: null,
                marker: { enabled: !1 },
                threshold: null,
              },
              xAxis: {
                overscroll: 0,
                className: "highcharts-navigator-xaxis",
                tickLength: 0,
                lineWidth: 0,
                gridLineColor: "#e6e6e6",
                gridLineWidth: 1,
                tickPixelInterval: 200,
                labels: {
                  align: "left",
                  style: {
                    color: "#000000",
                    fontSize: "0.7em",
                    opacity: 0.6,
                    textOutline: "2px contrast",
                  },
                  x: 3,
                  y: -4,
                },
                crosshair: !1,
              },
              yAxis: {
                className: "highcharts-navigator-yaxis",
                gridLineWidth: 0,
                startOnTick: !1,
                endOnTick: !1,
                minPadding: 0.1,
                maxPadding: 0.1,
                labels: { enabled: !1 },
                crosshair: !1,
                title: { text: null },
                tickLength: 0,
                tickWidth: 0,
              },
            }),
            O
          );
        }
      ),
      T(y, "Stock/Navigator/NavigatorSymbols.js", [], function () {
        return {
          "navigator-handle": function (A, O, F, G, U = {}) {
            return (
              (A = U.width ? U.width / 2 : F),
              (O = Math.round(A / 3) + 0.5),
              (G = U.height || G),
              [
                ["M", -A - 1, 0.5],
                ["L", A, 0.5],
                ["L", A, G + 0.5],
                ["L", -A - 1, G + 0.5],
                ["L", -A - 1, 0.5],
                ["M", -O, 4],
                ["L", -O, G - 3],
                ["M", O - 1, 4],
                ["L", O - 1, G - 3],
              ]
            );
          },
        };
      }),
      T(
        y,
        "Stock/Navigator/NavigatorComposition.js",
        [
          y["Core/Defaults.js"],
          y["Core/Globals.js"],
          y["Core/Axis/NavigatorAxisComposition.js"],
          y["Stock/Navigator/NavigatorDefaults.js"],
          y["Stock/Navigator/NavigatorSymbols.js"],
          y["Core/Renderer/RendererRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y) {
          function S() {
            this.navigator && this.navigator.setBaseSeries(null, !1);
          }
          function N() {
            var o;
            const i = this.legend,
              t = this.navigator;
            let e, s, a;
            if (t) {
              (e = i && i.options), (s = t.xAxis), (a = t.yAxis);
              const { scrollbarHeight: b, scrollButtonSize: r } = t;
              this.inverted
                ? ((t.left = t.opposite
                    ? this.chartWidth - b - t.height
                    : this.spacing[3] + b),
                  (t.top = this.plotTop + r))
                : ((t.left = h(s.left, this.plotLeft + r)),
                  (t.top =
                    t.navigatorOptions.top ||
                    this.chartHeight -
                      t.height -
                      b -
                      (((o = this.scrollbar) === null || o === void 0
                        ? void 0
                        : o.options.margin) || 0) -
                      this.spacing[2] -
                      (this.rangeSelector && this.extraBottomMargin
                        ? this.rangeSelector.getHeight()
                        : 0) -
                      (e &&
                      e.verticalAlign === "bottom" &&
                      e.layout !== "proximate" &&
                      e.enabled &&
                      !e.floating
                        ? i.legendHeight + h(e.margin, 10)
                        : 0) -
                      (this.titleOffset ? this.titleOffset[2] : 0))),
                s &&
                  a &&
                  (this.inverted
                    ? (s.options.left = a.options.left = t.left)
                    : (s.options.top = a.options.top = t.top),
                  s.setAxisSize(),
                  a.setAxisSize());
            }
          }
          function D(o) {
            this.navigator ||
              this.scroller ||
              (!this.options.navigator.enabled &&
                !this.options.scrollbar.enabled) ||
              ((this.scroller = this.navigator = new l(this)),
              h(o.redraw, !0) && this.redraw(o.animation));
          }
          function c() {
            const o = this.options;
            (o.navigator.enabled || o.scrollbar.enabled) &&
              (this.scroller = this.navigator = new l(this));
          }
          function p() {
            var o = this.options;
            const i = o.navigator;
            if (
              ((o = o.rangeSelector),
              ((i && i.enabled) || (o && o.enabled)) &&
                ((!M && this.zooming.type === "x") ||
                  (M && this.zooming.pinchType === "x")))
            )
              return !1;
          }
          function f(o) {
            const i = o.navigator;
            i &&
              o.xAxis[0] &&
              ((o = o.xAxis[0].getExtremes()), i.render(o.min, o.max));
          }
          function u(o) {
            const i = o.options.navigator || {},
              t = o.options.scrollbar || {};
            this.navigator ||
              this.scroller ||
              (!i.enabled && !t.enabled) ||
              (m(!0, this.options.navigator, i),
              m(!0, this.options.scrollbar, t),
              delete o.options.navigator,
              delete o.options.scrollbar);
          }
          function n() {
            this.chart.navigator &&
              !this.options.isInternal &&
              this.chart.navigator.setBaseSeries(null, !1);
          }
          const { defaultOptions: d, setOptions: g } = A,
            { isTouchDevice: M } = O,
            { getRendererType: C } = H,
            { addEvent: P, extend: j, merge: m, pick: h } = Y,
            v = [];
          let l;
          return {
            compose: function (o, i, t, e) {
              F.compose(o),
                (l = t),
                Y.pushUnique(v, i) &&
                  (i.prototype.callbacks.push(f),
                  P(i, "afterAddSeries", S),
                  P(i, "afterSetChartSize", N),
                  P(i, "afterUpdate", D),
                  P(i, "beforeRender", c),
                  P(i, "beforeShowResetZoom", p),
                  P(i, "update", u)),
                Y.pushUnique(v, e) && P(e, "afterUpdate", n),
                Y.pushUnique(v, C) && j(C().prototype.symbols, U),
                Y.pushUnique(v, g) && j(d, { navigator: G });
            },
          };
        }
      ),
      T(
        y,
        "Core/Axis/ScrollbarAxis.js",
        [y["Core/Utilities.js"]],
        function (A) {
          const { addEvent: O, defined: F, pick: G } = A,
            U = [];
          class H {
            static compose(S, N) {
              if (!A.pushUnique(U, S)) return S;
              const D = (c) => {
                const p = G(c.options && c.options.min, c.min),
                  f = G(c.options && c.options.max, c.max);
                return {
                  axisMin: p,
                  axisMax: f,
                  scrollMin: F(c.dataMin)
                    ? Math.min(p, c.min, c.dataMin, G(c.threshold, 1 / 0))
                    : p,
                  scrollMax: F(c.dataMax)
                    ? Math.max(f, c.max, c.dataMax, G(c.threshold, -1 / 0))
                    : f,
                };
              };
              return (
                O(S, "afterInit", function () {
                  const c = this;
                  c.options &&
                    c.options.scrollbar &&
                    c.options.scrollbar.enabled &&
                    ((c.options.scrollbar.vertical = !c.horiz),
                    (c.options.startOnTick = c.options.endOnTick = !1),
                    (c.scrollbar = new N(
                      c.chart.renderer,
                      c.options.scrollbar,
                      c.chart
                    )),
                    O(c.scrollbar, "changed", function (p) {
                      let {
                        axisMin: f,
                        axisMax: u,
                        scrollMin: n,
                        scrollMax: d,
                      } = D(c);
                      var g = d - n;
                      let M;
                      F(f) &&
                        F(u) &&
                        ((c.horiz && !c.reversed) || (!c.horiz && c.reversed)
                          ? ((M = n + g * this.to), (g = n + g * this.from))
                          : ((M = n + g * (1 - this.from)),
                            (g = n + g * (1 - this.to))),
                        this.shouldUpdateExtremes(p.DOMType)
                          ? c.setExtremes(
                              g,
                              M,
                              !0,
                              p.DOMType === "mousemove" ||
                                p.DOMType === "touchmove"
                                ? !1
                                : void 0,
                              p
                            )
                          : this.setRange(this.from, this.to));
                    }));
                }),
                O(S, "afterRender", function () {
                  let { scrollMin: c, scrollMax: p } = D(this),
                    f = this.scrollbar;
                  var u = this.axisTitleMargin + (this.titleOffset || 0),
                    n = this.chart.scrollbarsOffsets;
                  let d = this.options.margin || 0;
                  f &&
                    (this.horiz
                      ? (this.opposite || (n[1] += u),
                        f.position(
                          this.left,
                          this.top +
                            this.height +
                            2 +
                            n[1] -
                            (this.opposite ? d : 0),
                          this.width,
                          this.height
                        ),
                        this.opposite || (n[1] += d),
                        (u = 1))
                      : (this.opposite && (n[0] += u),
                        f.position(
                          f.options.opposite
                            ? this.left +
                                this.width +
                                2 +
                                n[0] -
                                (this.opposite ? 0 : d)
                            : this.opposite
                            ? 0
                            : d,
                          this.top,
                          this.width,
                          this.height
                        ),
                        this.opposite && (n[0] += d),
                        (u = 0)),
                    (n[u] += f.size + (f.options.margin || 0)),
                    isNaN(c) ||
                    isNaN(p) ||
                    !F(this.min) ||
                    !F(this.max) ||
                    this.min === this.max
                      ? f.setRange(0, 1)
                      : ((n = (this.min - c) / (p - c)),
                        (u = (this.max - c) / (p - c)),
                        (this.horiz && !this.reversed) ||
                        (!this.horiz && this.reversed)
                          ? f.setRange(n, u)
                          : f.setRange(1 - u, 1 - n)));
                }),
                O(S, "afterGetOffset", function () {
                  const c = this.scrollbar;
                  var p = c && !c.options.opposite;
                  (p = this.horiz ? 2 : p ? 3 : 1),
                    c &&
                      ((this.chart.scrollbarsOffsets = [0, 0]),
                      (this.chart.axisOffset[p] +=
                        c.size + (c.options.margin || 0)));
                }),
                S
              );
            }
          }
          return H;
        }
      ),
      T(
        y,
        "Stock/Scrollbar/ScrollbarDefaults.js",
        [y["Core/Globals.js"]],
        function (A) {
          return {
            height: 10,
            barBorderRadius: 5,
            buttonBorderRadius: 0,
            buttonsEnabled: !1,
            liveRedraw: void 0,
            margin: void 0,
            minWidth: 6,
            opposite: !0,
            step: 0.2,
            zIndex: 3,
            barBackgroundColor: "#cccccc",
            barBorderWidth: 0,
            barBorderColor: "#cccccc",
            buttonArrowColor: "#333333",
            buttonBackgroundColor: "#e6e6e6",
            buttonBorderColor: "#cccccc",
            buttonBorderWidth: 1,
            rifleColor: "none",
            trackBackgroundColor: "rgba(255, 255, 255, 0.001)",
            trackBorderColor: "#cccccc",
            trackBorderRadius: 5,
            trackBorderWidth: 1,
          };
        }
      ),
      T(
        y,
        "Stock/Scrollbar/Scrollbar.js",
        [
          y["Core/Defaults.js"],
          y["Core/Globals.js"],
          y["Core/Axis/ScrollbarAxis.js"],
          y["Stock/Scrollbar/ScrollbarDefaults.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U) {
          const { defaultOptions: H } = A,
            {
              addEvent: Y,
              correctFloat: S,
              defined: N,
              destroyObjectProperties: D,
              fireEvent: c,
              merge: p,
              pick: f,
              removeEvent: u,
            } = U;
          class n {
            static compose(g) {
              F.compose(g, n);
            }
            static swapXY(g, M) {
              return (
                M &&
                  g.forEach((C) => {
                    const P = C.length;
                    let j;
                    for (let m = 0; m < P; m += 2)
                      (j = C[m + 1]),
                        typeof j == "number" &&
                          ((C[m + 1] = C[m + 2]), (C[m + 2] = j));
                  }),
                g
              );
            }
            constructor(g, M, C) {
              (this._events = []),
                (this.chart = void 0),
                (this.from = this.chartY = this.chartX = 0),
                (this.scrollbar =
                  this.renderer =
                  this.options =
                  this.group =
                    void 0),
                (this.scrollbarButtons = []),
                (this.scrollbarGroup = void 0),
                (this.scrollbarLeft = 0),
                (this.scrollbarRifles = void 0),
                (this.scrollbarStrokeWidth = 1),
                (this.to = this.size = this.scrollbarTop = 0),
                (this.track = void 0),
                (this.trackBorderWidth = 1),
                (this.userOptions = void 0),
                (this.y = this.x = 0),
                this.init(g, M, C);
            }
            addEvents() {
              var g = this.options.inverted ? [1, 0] : [0, 1];
              const M = this.scrollbarButtons,
                C = this.scrollbarGroup.element,
                P = this.track.element,
                j = this.mouseDownHandler.bind(this),
                m = this.mouseMoveHandler.bind(this),
                h = this.mouseUpHandler.bind(this);
              (g = [
                [M[g[0]].element, "click", this.buttonToMinClick.bind(this)],
                [M[g[1]].element, "click", this.buttonToMaxClick.bind(this)],
                [P, "click", this.trackClick.bind(this)],
                [C, "mousedown", j],
                [C.ownerDocument, "mousemove", m],
                [C.ownerDocument, "mouseup", h],
              ]),
                O.hasTouch &&
                  g.push(
                    [C, "touchstart", j],
                    [C.ownerDocument, "touchmove", m],
                    [C.ownerDocument, "touchend", h]
                  ),
                g.forEach(function (v) {
                  Y.apply(null, v);
                }),
                (this._events = g);
            }
            buttonToMaxClick(g) {
              const M = (this.to - this.from) * f(this.options.step, 0.2);
              this.updatePosition(this.from + M, this.to + M),
                c(this, "changed", {
                  from: this.from,
                  to: this.to,
                  trigger: "scrollbar",
                  DOMEvent: g,
                });
            }
            buttonToMinClick(g) {
              const M = S(this.to - this.from) * f(this.options.step, 0.2);
              this.updatePosition(S(this.from - M), S(this.to - M)),
                c(this, "changed", {
                  from: this.from,
                  to: this.to,
                  trigger: "scrollbar",
                  DOMEvent: g,
                });
            }
            cursorToScrollbarPosition(g) {
              var M = this.options;
              return (
                (M = M.minWidth > this.calculatedWidth ? M.minWidth : 0),
                {
                  chartX:
                    (g.chartX - this.x - this.xOffset) / (this.barWidth - M),
                  chartY:
                    (g.chartY - this.y - this.yOffset) / (this.barWidth - M),
                }
              );
            }
            destroy() {
              const g = this,
                M = g.chart.scroller;
              g.removeEvents(),
                [
                  "track",
                  "scrollbarRifles",
                  "scrollbar",
                  "scrollbarGroup",
                  "group",
                ].forEach(function (C) {
                  g[C] && g[C].destroy && (g[C] = g[C].destroy());
                }),
                M &&
                  g === M.scrollbar &&
                  ((M.scrollbar = null), D(M.scrollbarButtons));
            }
            drawScrollbarButton(g) {
              const M = this.renderer,
                C = this.scrollbarButtons,
                P = this.options,
                j = this.size;
              var m = M.g().add(this.group);
              C.push(m),
                P.buttonsEnabled &&
                  ((m = M.rect()
                    .addClass("highcharts-scrollbar-button")
                    .add(m)),
                  this.chart.styledMode ||
                    m.attr({
                      stroke: P.buttonBorderColor,
                      "stroke-width": P.buttonBorderWidth,
                      fill: P.buttonBackgroundColor,
                    }),
                  m.attr(
                    m.crisp(
                      {
                        x: -0.5,
                        y: -0.5,
                        width: j + 1,
                        height: j + 1,
                        r: P.buttonBorderRadius,
                      },
                      m.strokeWidth()
                    )
                  ),
                  (g = M.path(
                    n.swapXY(
                      [
                        ["M", j / 2 + (g ? -1 : 1), j / 2 - 3],
                        ["L", j / 2 + (g ? -1 : 1), j / 2 + 3],
                        ["L", j / 2 + (g ? 2 : -2), j / 2],
                      ],
                      P.vertical
                    )
                  )
                    .addClass("highcharts-scrollbar-arrow")
                    .add(C[g])),
                  this.chart.styledMode ||
                    g.attr({ fill: P.buttonArrowColor }));
            }
            init(g, M, C) {
              (this.scrollbarButtons = []),
                (this.renderer = g),
                (this.userOptions = M),
                (this.options = p(G, H.scrollbar, M)),
                (this.options.margin = f(this.options.margin, 10)),
                (this.chart = C),
                (this.size = f(this.options.size, this.options.height)),
                M.enabled && (this.render(), this.addEvents());
            }
            mouseDownHandler(g) {
              (g = this.chart.pointer.normalize(g)),
                (g = this.cursorToScrollbarPosition(g)),
                (this.chartX = g.chartX),
                (this.chartY = g.chartY),
                (this.initPositions = [this.from, this.to]),
                (this.grabbedCenter = !0);
            }
            mouseMoveHandler(g) {
              var M = this.chart.pointer.normalize(g),
                C = this.options.vertical ? "chartY" : "chartX";
              const P = this.initPositions || [];
              !this.grabbedCenter ||
                (g.touches && g.touches[0][C] === 0) ||
                ((M = this.cursorToScrollbarPosition(M)[C]),
                (C = this[C]),
                (C = M - C),
                (this.hasDragged = !0),
                this.updatePosition(P[0] + C, P[1] + C),
                this.hasDragged &&
                  c(this, "changed", {
                    from: this.from,
                    to: this.to,
                    trigger: "scrollbar",
                    DOMType: g.type,
                    DOMEvent: g,
                  }));
            }
            mouseUpHandler(g) {
              this.hasDragged &&
                c(this, "changed", {
                  from: this.from,
                  to: this.to,
                  trigger: "scrollbar",
                  DOMType: g.type,
                  DOMEvent: g,
                }),
                (this.grabbedCenter =
                  this.hasDragged =
                  this.chartX =
                  this.chartY =
                    null);
            }
            position(g, M, C, P) {
              const {
                  buttonsEnabled: j,
                  margin: m = 0,
                  vertical: h,
                } = this.options,
                v = this.rendered ? "animate" : "attr";
              let l = P,
                o = 0;
              this.group.show(),
                (this.x = g),
                (this.y = M + this.trackBorderWidth),
                (this.width = C),
                (this.height = P),
                (this.xOffset = l),
                (this.yOffset = o),
                h
                  ? ((this.width = this.yOffset = C = this.size),
                    (this.xOffset = l = 0),
                    (this.yOffset = o = j ? this.size : 0),
                    (this.barWidth = P - (j ? 2 * C : 0)),
                    (this.x = g += m))
                  : ((this.height = P = this.size),
                    (this.xOffset = l = j ? this.size : 0),
                    (this.barWidth = C - (j ? 2 * P : 0)),
                    (this.y += m)),
                this.group[v]({ translateX: g, translateY: this.y }),
                this.track[v]({ width: C, height: P }),
                this.scrollbarButtons[1][v]({
                  translateX: h ? 0 : C - l,
                  translateY: h ? P - o : 0,
                });
            }
            removeEvents() {
              this._events.forEach(function (g) {
                u.apply(null, g);
              }),
                (this._events.length = 0);
            }
            render() {
              const g = this.renderer,
                M = this.options,
                C = this.size,
                P = this.chart.styledMode,
                j = g.g("scrollbar").attr({ zIndex: M.zIndex }).hide().add();
              (this.group = j),
                (this.track = g
                  .rect()
                  .addClass("highcharts-scrollbar-track")
                  .attr({ r: M.trackBorderRadius || 0, height: C, width: C })
                  .add(j)),
                P ||
                  this.track.attr({
                    fill: M.trackBackgroundColor,
                    stroke: M.trackBorderColor,
                    "stroke-width": M.trackBorderWidth,
                  });
              const m = (this.trackBorderWidth = this.track.strokeWidth());
              this.track.attr({ x: (-m % 2) / 2, y: (-m % 2) / 2 }),
                (this.scrollbarGroup = g.g().add(j)),
                (this.scrollbar = g
                  .rect()
                  .addClass("highcharts-scrollbar-thumb")
                  .attr({
                    height: C - m,
                    width: C - m,
                    r: M.barBorderRadius || 0,
                  })
                  .add(this.scrollbarGroup)),
                (this.scrollbarRifles = g
                  .path(
                    n.swapXY(
                      [
                        ["M", -3, C / 4],
                        ["L", -3, (2 * C) / 3],
                        ["M", 0, C / 4],
                        ["L", 0, (2 * C) / 3],
                        ["M", 3, C / 4],
                        ["L", 3, (2 * C) / 3],
                      ],
                      M.vertical
                    )
                  )
                  .addClass("highcharts-scrollbar-rifles")
                  .add(this.scrollbarGroup)),
                P ||
                  (this.scrollbar.attr({
                    fill: M.barBackgroundColor,
                    stroke: M.barBorderColor,
                    "stroke-width": M.barBorderWidth,
                  }),
                  this.scrollbarRifles.attr({
                    stroke: M.rifleColor,
                    "stroke-width": 1,
                  })),
                (this.scrollbarStrokeWidth = this.scrollbar.strokeWidth()),
                this.scrollbarGroup.translate(
                  (-this.scrollbarStrokeWidth % 2) / 2,
                  (-this.scrollbarStrokeWidth % 2) / 2
                ),
                this.drawScrollbarButton(0),
                this.drawScrollbarButton(1);
            }
            setRange(g, M) {
              const C = this.options,
                P = C.vertical;
              var j = C.minWidth,
                m = this.barWidth;
              const h =
                !this.rendered ||
                this.hasDragged ||
                (this.chart.navigator && this.chart.navigator.hasDragged)
                  ? "attr"
                  : "animate";
              if (N(m)) {
                var v = m * Math.min(M, 1);
                g = Math.max(g, 0);
                var l = Math.ceil(m * g);
                (this.calculatedWidth = v = S(v - l)),
                  v < j && ((l = (m - j + v) * g), (v = j)),
                  (j = Math.floor(l + this.xOffset + this.yOffset)),
                  (m = v / 2 - 0.5),
                  (this.from = g),
                  (this.to = M),
                  P
                    ? (this.scrollbarGroup[h]({ translateY: j }),
                      this.scrollbar[h]({ height: v }),
                      this.scrollbarRifles[h]({ translateY: m }),
                      (this.scrollbarTop = j),
                      (this.scrollbarLeft = 0))
                    : (this.scrollbarGroup[h]({ translateX: j }),
                      this.scrollbar[h]({ width: v }),
                      this.scrollbarRifles[h]({ translateX: m }),
                      (this.scrollbarLeft = j),
                      (this.scrollbarTop = 0)),
                  12 >= v
                    ? this.scrollbarRifles.hide()
                    : this.scrollbarRifles.show(),
                  C.showFull === !1 &&
                    (0 >= g && 1 <= M ? this.group.hide() : this.group.show()),
                  (this.rendered = !0);
              }
            }
            shouldUpdateExtremes(g) {
              return (
                f(
                  this.options.liveRedraw,
                  O.svg && !O.isTouchDevice && !this.chart.boosted
                ) ||
                g === "mouseup" ||
                g === "touchend" ||
                !N(g)
              );
            }
            trackClick(g) {
              const M = this.chart.pointer.normalize(g),
                C = this.to - this.from,
                P = this.y + this.scrollbarTop,
                j = this.x + this.scrollbarLeft;
              (this.options.vertical && M.chartY > P) ||
              (!this.options.vertical && M.chartX > j)
                ? this.updatePosition(this.from + C, this.to + C)
                : this.updatePosition(this.from - C, this.to - C),
                c(this, "changed", {
                  from: this.from,
                  to: this.to,
                  trigger: "scrollbar",
                  DOMEvent: g,
                });
            }
            update(g) {
              this.destroy(),
                this.init(
                  this.chart.renderer,
                  p(!0, this.options, g),
                  this.chart
                );
            }
            updatePosition(g, M) {
              1 < M && ((g = S(1 - S(M - g))), (M = 1)),
                0 > g && ((M = S(M - g)), (g = 0)),
                (this.from = g),
                (this.to = M);
            }
          }
          return (
            (n.defaultOptions = G),
            (H.scrollbar = p(!0, n.defaultOptions, H.scrollbar)),
            n
          );
        }
      ),
      T(
        y,
        "Stock/Navigator/Navigator.js",
        [
          y["Core/Axis/Axis.js"],
          y["Core/Defaults.js"],
          y["Core/Globals.js"],
          y["Core/Axis/NavigatorAxisComposition.js"],
          y["Stock/Navigator/NavigatorComposition.js"],
          y["Stock/Scrollbar/Scrollbar.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y) {
          function S(i, ...t) {
            if (((t = [].filter.call(t, j)), t.length))
              return Math[i].apply(0, t);
          }
          const { defaultOptions: N } = O,
            { hasTouch: D, isTouchDevice: c } = F,
            {
              addEvent: p,
              clamp: f,
              correctFloat: u,
              defined: n,
              destroyObjectProperties: d,
              erase: g,
              extend: M,
              find: C,
              isArray: P,
              isNumber: j,
              merge: m,
              pick: h,
              removeEvent: v,
              splat: l,
            } = Y;
          class o {
            static compose(t, e, s) {
              U.compose(t, e, o, s);
            }
            constructor(t) {
              (this.rendered =
                this.range =
                this.outline =
                this.opposite =
                this.navigatorSize =
                this.navigatorSeries =
                this.navigatorOptions =
                this.navigatorGroup =
                this.navigatorEnabled =
                this.left =
                this.height =
                this.handles =
                this.chart =
                this.baseSeries =
                  void 0),
                (this.scrollbarHeight = 0),
                (this.zoomedMin =
                  this.zoomedMax =
                  this.yAxis =
                  this.xAxis =
                  this.top =
                  this.size =
                  this.shades =
                  this.scrollButtonSize =
                    void 0),
                this.init(t);
            }
            drawHandle(t, e, s, a) {
              const b = this.navigatorOptions.handles.height;
              this.handles[e][a](
                s
                  ? {
                      translateX: Math.round(this.left + this.height / 2),
                      translateY: Math.round(
                        this.top + parseInt(t, 10) + 0.5 - b
                      ),
                    }
                  : {
                      translateX: Math.round(this.left + parseInt(t, 10)),
                      translateY: Math.round(
                        this.top + this.height / 2 - b / 2 - 1
                      ),
                    }
              );
            }
            drawOutline(t, e, s, a) {
              const b = this.navigatorOptions.maskInside;
              var r = this.outline.strokeWidth();
              const w = r / 2;
              var L = (r % 2) / 2;
              const I = this.scrollButtonSize,
                V = this.size,
                B = this.top;
              r = this.height;
              const x = B - w,
                R = B + r;
              let W = this.left;
              s
                ? ((s = B + e + L),
                  (e = B + t + L),
                  (L = [
                    ["M", W + r, B - I - L],
                    ["L", W + r, s],
                    ["L", W, s],
                    ["M", W, e],
                    ["L", W + r, e],
                    ["L", W + r, B + V + I],
                  ]),
                  b && L.push(["M", W + r, s - w], ["L", W + r, e + w]))
                : ((W -= I),
                  (t += W + I - L),
                  (e += W + I - L),
                  (L = [
                    ["M", W, x],
                    ["L", t, x],
                    ["L", t, R],
                    ["M", e, R],
                    ["L", e, x],
                    ["L", W + V + 2 * I, B + w],
                  ]),
                  b && L.push(["M", t - w, x], ["L", e + w, x])),
                this.outline[a]({ d: L });
            }
            drawMasks(t, e, s, a) {
              const b = this.left,
                r = this.top,
                w = this.height;
              let L, I, V, B;
              s
                ? ((V = [b, b, b]),
                  (B = [r, r + t, r + e]),
                  (I = [w, w, w]),
                  (L = [t, e - t, this.size - e]))
                : ((V = [b, b + t, b + e]),
                  (B = [r, r, r]),
                  (I = [t, e - t, this.size - e]),
                  (L = [w, w, w])),
                this.shades.forEach((x, R) => {
                  x[a]({ x: V[R], y: B[R], width: I[R], height: L[R] });
                });
            }
            renderElements() {
              const t = this,
                e = t.navigatorOptions,
                s = e.maskInside,
                a = t.chart,
                b = a.renderer,
                r = { cursor: a.inverted ? "ns-resize" : "ew-resize" },
                w = (t.navigatorGroup = b
                  .g("navigator")
                  .attr({ zIndex: 8, visibility: "hidden" })
                  .add());
              if (
                ([!s, s, !s].forEach((L, I) => {
                  const V = b
                    .rect()
                    .addClass(
                      "highcharts-navigator-mask" +
                        (I === 1 ? "-inside" : "-outside")
                    )
                    .add(w);
                  a.styledMode ||
                    (V.attr({ fill: L ? e.maskFill : "rgba(0,0,0,0)" }),
                    I === 1 && V.css(r)),
                    (t.shades[I] = V);
                }),
                (t.outline = b
                  .path()
                  .addClass("highcharts-navigator-outline")
                  .add(w)),
                a.styledMode ||
                  t.outline.attr({
                    "stroke-width": e.outlineWidth,
                    stroke: e.outlineColor,
                  }),
                e.handles && e.handles.enabled)
              ) {
                const L = e.handles,
                  { height: I, width: V } = L;
                [0, 1].forEach((B) => {
                  (t.handles[B] = b.symbol(
                    L.symbols[B],
                    -V / 2 - 1,
                    0,
                    V,
                    I,
                    L
                  )),
                    a.inverted &&
                      t.handles[B].attr({
                        rotation: 90,
                        rotationOriginX: Math.floor(-V / 2),
                        rotationOriginY: (I + V) / 2,
                      }),
                    t.handles[B].attr({ zIndex: 7 - B })
                      .addClass(
                        "highcharts-navigator-handle highcharts-navigator-handle-" +
                          ["left", "right"][B]
                      )
                      .add(w),
                    a.styledMode ||
                      t.handles[B].attr({
                        fill: L.backgroundColor,
                        stroke: L.borderColor,
                        "stroke-width": L.lineWidth,
                      }).css(r);
                });
              }
            }
            update(t) {
              (this.series || []).forEach((e) => {
                e.baseSeries && delete e.baseSeries.navigatorSeries;
              }),
                this.destroy(),
                m(!0, this.chart.options.navigator, t),
                this.init(this.chart);
            }
            render(t, e, s, a) {
              var b = this.chart;
              const r = this.xAxis,
                w = r.pointRange || 0;
              var L = r.navigatorAxis.fake ? b.xAxis[0] : r;
              const I = this.navigatorEnabled;
              var V = this.rendered,
                B = b.inverted;
              const x = b.xAxis[0].minRange,
                R = b.xAxis[0].options.maxRange,
                W = this.scrollButtonSize;
              let X = this.scrollbarHeight,
                Z;
              if (!this.hasDragged || n(s)) {
                if (((t = u(t - w / 2)), (e = u(e + w / 2)), !j(t) || !j(e)))
                  if (V) (s = 0), (a = h(r.width, L.width));
                  else return;
                this.left = h(r.left, b.plotLeft + W + (B ? b.plotWidth : 0));
                var E =
                  (this.size =
                  Z =
                    h(r.len, (B ? b.plotHeight : b.plotWidth) - 2 * W));
                (b = B ? X : Z + 2 * W),
                  (s = h(s, r.toPixels(t, !0))),
                  (a = h(a, r.toPixels(e, !0))),
                  (j(s) && Math.abs(s) !== 1 / 0) || ((s = 0), (a = b)),
                  (t = r.toValue(s, !0)),
                  (e = r.toValue(a, !0));
                var _ = Math.abs(u(e - t));
                _ < x
                  ? this.grabbedLeft
                    ? (s = r.toPixels(e - x - w, !0))
                    : this.grabbedRight && (a = r.toPixels(t + x + w, !0))
                  : n(R) &&
                    u(_ - w) > R &&
                    (this.grabbedLeft
                      ? (s = r.toPixels(e - R - w, !0))
                      : this.grabbedRight && (a = r.toPixels(t + R + w, !0))),
                  (this.zoomedMax = f(Math.max(s, a), 0, E)),
                  (this.zoomedMin = f(
                    this.fixedWidth
                      ? this.zoomedMax - this.fixedWidth
                      : Math.min(s, a),
                    0,
                    E
                  )),
                  (this.range = this.zoomedMax - this.zoomedMin),
                  (E = Math.round(this.zoomedMax)),
                  (s = Math.round(this.zoomedMin)),
                  I &&
                    (this.navigatorGroup.attr({ visibility: "inherit" }),
                    (V = V && !this.hasDragged ? "animate" : "attr"),
                    this.drawMasks(s, E, B, V),
                    this.drawOutline(s, E, B, V),
                    this.navigatorOptions.handles.enabled &&
                      (this.drawHandle(s, 0, B, V),
                      this.drawHandle(E, 1, B, V))),
                  this.scrollbar &&
                    (B
                      ? ((B = this.top - W),
                        (L =
                          this.left -
                          X +
                          (I || !L.opposite
                            ? 0
                            : (L.titleOffset || 0) + L.axisTitleMargin)),
                        (X = Z + 2 * W))
                      : ((B = this.top + (I ? this.height : -X)),
                        (L = this.left - W)),
                    this.scrollbar.position(L, B, b, X),
                    this.scrollbar.setRange(
                      this.zoomedMin / (Z || 1),
                      this.zoomedMax / (Z || 1)
                    )),
                  (this.rendered = !0);
              }
            }
            addMouseEvents() {
              const t = this,
                e = t.chart,
                s = e.container;
              let a = [],
                b,
                r;
              (t.mouseMoveHandler = b =
                function (w) {
                  t.onMouseMove(w);
                }),
                (t.mouseUpHandler = r =
                  function (w) {
                    t.onMouseUp(w);
                  }),
                (a = t.getPartsEvents("mousedown")),
                a.push(
                  p(e.renderTo, "mousemove", b),
                  p(s.ownerDocument, "mouseup", r)
                ),
                D &&
                  (a.push(
                    p(e.renderTo, "touchmove", b),
                    p(s.ownerDocument, "touchend", r)
                  ),
                  a.concat(t.getPartsEvents("touchstart"))),
                (t.eventsToUnbind = a),
                t.series &&
                  t.series[0] &&
                  a.push(
                    p(t.series[0].xAxis, "foundExtremes", function () {
                      e.navigator.modifyNavigatorAxisExtremes();
                    })
                  );
            }
            getPartsEvents(t) {
              const e = this,
                s = [];
              return (
                ["shades", "handles"].forEach(function (a) {
                  e[a].forEach(function (b, r) {
                    s.push(
                      p(b.element, t, function (w) {
                        e[a + "Mousedown"](w, r);
                      })
                    );
                  });
                }),
                s
              );
            }
            shadesMousedown(t, e) {
              t = this.chart.pointer.normalize(t);
              const s = this.chart,
                a = this.xAxis,
                b = this.zoomedMin,
                r = this.size,
                w = this.range;
              let L = this.left,
                I = t.chartX,
                V,
                B;
              s.inverted && ((I = t.chartY), (L = this.top)),
                e === 1
                  ? ((this.grabbedCenter = I),
                    (this.fixedWidth = w),
                    (this.dragOffset = I - b))
                  : ((t = I - L - w / 2),
                    e === 0
                      ? (t = Math.max(0, t))
                      : e === 2 &&
                        t + w >= r &&
                        ((t = r - w),
                        this.reversedExtremes
                          ? ((t -= w), (B = this.getUnionExtremes().dataMin))
                          : (V = this.getUnionExtremes().dataMax)),
                    t !== b &&
                      ((this.fixedWidth = w),
                      (e = a.navigatorAxis.toFixedRange(t, t + w, B, V)),
                      n(e.min) &&
                        s.xAxis[0].setExtremes(
                          Math.min(e.min, e.max),
                          Math.max(e.min, e.max),
                          !0,
                          null,
                          { trigger: "navigator" }
                        )));
            }
            handlesMousedown(t, e) {
              this.chart.pointer.normalize(t), (t = this.chart);
              const s = t.xAxis[0],
                a = this.reversedExtremes;
              e === 0
                ? ((this.grabbedLeft = !0),
                  (this.otherHandlePos = this.zoomedMax),
                  (this.fixedExtreme = a ? s.min : s.max))
                : ((this.grabbedRight = !0),
                  (this.otherHandlePos = this.zoomedMin),
                  (this.fixedExtreme = a ? s.max : s.min)),
                (t.fixedRange = null);
            }
            onMouseMove(t) {
              const e = this;
              var s = e.chart;
              const a = e.navigatorSize,
                b = e.range,
                r = e.dragOffset,
                w = s.inverted;
              let L = e.left;
              (t.touches && t.touches[0].pageX === 0) ||
                ((t = s.pointer.normalize(t)),
                (s = t.chartX),
                w && ((L = e.top), (s = t.chartY)),
                e.grabbedLeft
                  ? ((e.hasDragged = !0),
                    e.render(0, 0, s - L, e.otherHandlePos))
                  : e.grabbedRight
                  ? ((e.hasDragged = !0),
                    e.render(0, 0, e.otherHandlePos, s - L))
                  : e.grabbedCenter &&
                    ((e.hasDragged = !0),
                    s < r ? (s = r) : s > a + r - b && (s = a + r - b),
                    e.render(0, 0, s - r, s - r + b)),
                e.hasDragged &&
                  e.scrollbar &&
                  h(
                    e.scrollbar.options.liveRedraw,
                    !c && !this.chart.boosted
                  ) &&
                  ((t.DOMType = t.type),
                  setTimeout(function () {
                    e.onMouseUp(t);
                  }, 0)));
            }
            onMouseUp(t) {
              var e = this.chart,
                s = this.xAxis,
                a = this.scrollbar;
              const b = t.DOMEvent || t,
                r = e.inverted,
                w = this.rendered && !this.hasDragged ? "animate" : "attr";
              let L, I;
              ((!this.hasDragged || (a && a.hasDragged)) &&
                t.trigger !== "scrollbar") ||
                ((a = this.getUnionExtremes()),
                this.zoomedMin === this.otherHandlePos
                  ? (L = this.fixedExtreme)
                  : this.zoomedMax === this.otherHandlePos &&
                    (I = this.fixedExtreme),
                this.zoomedMax === this.size &&
                  (I = this.reversedExtremes ? a.dataMin : a.dataMax),
                this.zoomedMin === 0 &&
                  (L = this.reversedExtremes ? a.dataMax : a.dataMin),
                (s = s.navigatorAxis.toFixedRange(
                  this.zoomedMin,
                  this.zoomedMax,
                  L,
                  I
                )),
                n(s.min) &&
                  e.xAxis[0].setExtremes(
                    Math.min(s.min, s.max),
                    Math.max(s.min, s.max),
                    !0,
                    this.hasDragged ? !1 : null,
                    {
                      trigger: "navigator",
                      triggerOp: "navigator-drag",
                      DOMEvent: b,
                    }
                  )),
                t.DOMType !== "mousemove" &&
                  t.DOMType !== "touchmove" &&
                  (this.grabbedLeft =
                    this.grabbedRight =
                    this.grabbedCenter =
                    this.fixedWidth =
                    this.fixedExtreme =
                    this.otherHandlePos =
                    this.hasDragged =
                    this.dragOffset =
                      null),
                this.navigatorEnabled &&
                  j(this.zoomedMin) &&
                  j(this.zoomedMax) &&
                  ((e = Math.round(this.zoomedMin)),
                  (t = Math.round(this.zoomedMax)),
                  this.shades && this.drawMasks(e, t, r, w),
                  this.outline && this.drawOutline(e, t, r, w),
                  this.navigatorOptions.handles.enabled &&
                    Object.keys(this.handles).length === this.handles.length &&
                    (this.drawHandle(e, 0, r, w), this.drawHandle(t, 1, r, w)));
            }
            removeEvents() {
              this.eventsToUnbind &&
                (this.eventsToUnbind.forEach(function (t) {
                  t();
                }),
                (this.eventsToUnbind = void 0)),
                this.removeBaseSeriesEvents();
            }
            removeBaseSeriesEvents() {
              const t = this.baseSeries || [];
              this.navigatorEnabled &&
                t[0] &&
                (this.navigatorOptions.adaptToUpdatedData !== !1 &&
                  t.forEach(function (e) {
                    v(e, "updatedData", this.updatedDataHandler);
                  }, this),
                t[0].xAxis &&
                  v(t[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
            }
            init(t) {
              var e = t.options,
                s = e.navigator || {},
                a = s.enabled,
                b = e.scrollbar || {},
                r = b.enabled;
              e = (a && s.height) || 0;
              var w = (r && b.height) || 0;
              const L = (b.buttonsEnabled && w) || 0;
              (this.handles = []),
                (this.shades = []),
                (this.chart = t),
                this.setBaseSeries(),
                (this.height = e),
                (this.scrollbarHeight = w),
                (this.scrollButtonSize = L),
                (this.scrollbarEnabled = r),
                (this.navigatorEnabled = a),
                (this.navigatorOptions = s),
                (this.scrollbarOptions = b),
                (this.opposite = h(s.opposite, !(a || !t.inverted)));
              const I = this;
              (a = I.baseSeries),
                (b = t.xAxis.length),
                (r = t.yAxis.length),
                (w = (a && a[0] && a[0].xAxis) ||
                  t.xAxis[0] || { options: {} }),
                (t.isDirtyBox = !0),
                I.navigatorEnabled
                  ? ((I.xAxis = new A(
                      t,
                      m(
                        {
                          breaks: w.options.breaks,
                          ordinal: w.options.ordinal,
                        },
                        s.xAxis,
                        {
                          id: "navigator-x-axis",
                          yAxis: "navigator-y-axis",
                          type: "datetime",
                          index: b,
                          isInternal: !0,
                          offset: 0,
                          keepOrdinalPadding: !0,
                          startOnTick: !1,
                          endOnTick: !1,
                          minPadding: 0,
                          maxPadding: 0,
                          zoomEnabled: !1,
                        },
                        t.inverted
                          ? { offsets: [L, 0, -L, 0], width: e }
                          : { offsets: [0, -L, 0, L], height: e }
                      ),
                      "xAxis"
                    )),
                    (I.yAxis = new A(
                      t,
                      m(
                        s.yAxis,
                        {
                          id: "navigator-y-axis",
                          alignTicks: !1,
                          offset: 0,
                          index: r,
                          isInternal: !0,
                          reversed: h(
                            s.yAxis && s.yAxis.reversed,
                            t.yAxis[0] && t.yAxis[0].reversed,
                            !1
                          ),
                          zoomEnabled: !1,
                        },
                        t.inverted ? { width: e } : { height: e }
                      ),
                      "yAxis"
                    )),
                    a || s.series.data
                      ? I.updateNavigatorSeries(!1)
                      : t.series.length === 0 &&
                        (I.unbindRedraw = p(t, "beforeRedraw", function () {
                          0 < t.series.length &&
                            !I.series &&
                            (I.setBaseSeries(), I.unbindRedraw());
                        })),
                    (I.reversedExtremes =
                      (t.inverted && !I.xAxis.reversed) ||
                      (!t.inverted && I.xAxis.reversed)),
                    I.renderElements(),
                    I.addMouseEvents())
                  : ((I.xAxis = {
                      chart: t,
                      navigatorAxis: { fake: !0 },
                      translate: function (V, B) {
                        var x = t.xAxis[0];
                        const R = x.getExtremes(),
                          W = x.len - 2 * L,
                          X = S("min", x.options.min, R.dataMin);
                        return (
                          (x = S("max", x.options.max, R.dataMax) - X),
                          B ? (V * x) / W + X : (W * (V - X)) / x
                        );
                      },
                      toPixels: function (V) {
                        return this.translate(V);
                      },
                      toValue: function (V) {
                        return this.translate(V, !0);
                      },
                    }),
                    (I.xAxis.navigatorAxis.axis = I.xAxis),
                    (I.xAxis.navigatorAxis.toFixedRange =
                      G.prototype.toFixedRange.bind(I.xAxis.navigatorAxis))),
                t.options.scrollbar.enabled &&
                  ((s = m(t.options.scrollbar, { vertical: t.inverted })),
                  !j(s.margin) &&
                    I.navigatorEnabled &&
                    (s.margin = t.inverted ? -3 : 3),
                  (t.scrollbar = I.scrollbar = new H(t.renderer, s, t)),
                  p(I.scrollbar, "changed", function (V) {
                    var B = I.size;
                    const x = B * this.to;
                    (B *= this.from),
                      (I.hasDragged = I.scrollbar.hasDragged),
                      I.render(0, 0, B, x),
                      this.shouldUpdateExtremes(V.DOMType) &&
                        setTimeout(function () {
                          I.onMouseUp(V);
                        });
                  })),
                I.addBaseSeriesEvents(),
                I.addChartEvents();
            }
            getUnionExtremes(t) {
              const e = this.chart.xAxis[0],
                s = this.xAxis,
                a = s.options,
                b = e.options;
              let r;
              return (
                (t && e.dataMin === null) ||
                  (r = {
                    dataMin: h(
                      a && a.min,
                      S("min", b.min, e.dataMin, s.dataMin, s.min)
                    ),
                    dataMax: h(
                      a && a.max,
                      S("max", b.max, e.dataMax, s.dataMax, s.max)
                    ),
                  }),
                r
              );
            }
            setBaseSeries(t, e) {
              const s = this.chart,
                a = (this.baseSeries = []);
              (t =
                t ||
                (s.options && s.options.navigator.baseSeries) ||
                (s.series.length
                  ? C(s.series, (b) => !b.options.isInternal).index
                  : 0)),
                (s.series || []).forEach((b, r) => {
                  b.options.isInternal ||
                    (!b.options.showInNavigator &&
                      ((r !== t && b.options.id !== t) ||
                        b.options.showInNavigator === !1)) ||
                    a.push(b);
                }),
                this.xAxis &&
                  !this.xAxis.navigatorAxis.fake &&
                  this.updateNavigatorSeries(!0, e);
            }
            updateNavigatorSeries(t, e) {
              const s = this,
                a = s.chart,
                b = s.baseSeries,
                r = {
                  enableMouseTracking: !1,
                  index: null,
                  linkedTo: null,
                  group: "nav",
                  padXAxis: !1,
                  xAxis: "navigator-x-axis",
                  yAxis: "navigator-y-axis",
                  showInLegend: !1,
                  stacking: void 0,
                  isInternal: !0,
                  states: { inactive: { opacity: 1 } },
                },
                w = (s.series = (s.series || []).filter((x) => {
                  const R = x.baseSeries;
                  return 0 > b.indexOf(R)
                    ? (R &&
                        (v(R, "updatedData", s.updatedDataHandler),
                        delete R.navigatorSeries),
                      x.chart && x.destroy(),
                      !1)
                    : !0;
                }));
              let L,
                I,
                V = s.navigatorOptions.series,
                B;
              b &&
                b.length &&
                b.forEach((x) => {
                  const R = x.navigatorSeries;
                  var W = M(
                    { color: x.color, visible: x.visible },
                    P(V) ? N.navigator.series : V
                  );
                  (R && s.navigatorOptions.adaptToUpdatedData === !1) ||
                    ((r.name = "Navigator " + b.length),
                    (L = x.options || {}),
                    (B = L.navigatorOptions || {}),
                    (W.dataLabels = l(W.dataLabels)),
                    (I = m(L, r, W, B)),
                    (I.pointRange = h(
                      W.pointRange,
                      B.pointRange,
                      N.plotOptions[I.type || "line"].pointRange
                    )),
                    (W = B.data || W.data),
                    (s.hasNavigatorData = s.hasNavigatorData || !!W),
                    (I.data = W || (L.data && L.data.slice(0))),
                    R && R.options
                      ? R.update(I, e)
                      : ((x.navigatorSeries = a.initSeries(I)),
                        (x.navigatorSeries.baseSeries = x),
                        w.push(x.navigatorSeries)));
                }),
                ((V.data && (!b || !b.length)) || P(V)) &&
                  ((s.hasNavigatorData = !1),
                  (V = l(V)),
                  V.forEach((x, R) => {
                    (r.name = "Navigator " + (w.length + 1)),
                      (I = m(
                        N.navigator.series,
                        {
                          color:
                            (a.series[R] &&
                              !a.series[R].options.isInternal &&
                              a.series[R].color) ||
                            a.options.colors[R] ||
                            a.options.colors[0],
                        },
                        r,
                        x
                      )),
                      (I.data = x.data),
                      I.data &&
                        ((s.hasNavigatorData = !0), w.push(a.initSeries(I)));
                  })),
                t && this.addBaseSeriesEvents();
            }
            addBaseSeriesEvents() {
              const t = this,
                e = t.baseSeries || [];
              e[0] &&
                e[0].xAxis &&
                e[0].eventsToUnbind.push(
                  p(e[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes)
                ),
                e.forEach((s) => {
                  s.eventsToUnbind.push(
                    p(s, "show", function () {
                      this.navigatorSeries &&
                        this.navigatorSeries.setVisible(!0, !1);
                    })
                  ),
                    s.eventsToUnbind.push(
                      p(s, "hide", function () {
                        this.navigatorSeries &&
                          this.navigatorSeries.setVisible(!1, !1);
                      })
                    ),
                    this.navigatorOptions.adaptToUpdatedData !== !1 &&
                      s.xAxis &&
                      s.eventsToUnbind.push(
                        p(s, "updatedData", this.updatedDataHandler)
                      ),
                    s.eventsToUnbind.push(
                      p(s, "remove", function () {
                        this.navigatorSeries &&
                          (g(t.series, this.navigatorSeries),
                          n(this.navigatorSeries.options) &&
                            this.navigatorSeries.remove(!1),
                          delete this.navigatorSeries);
                      })
                    );
                });
            }
            getBaseSeriesMin(t) {
              return this.baseSeries.reduce(function (e, s) {
                return Math.min(e, s.xData && s.xData.length ? s.xData[0] : e);
              }, t);
            }
            modifyNavigatorAxisExtremes() {
              const t = this.xAxis;
              if (typeof t.getExtremes < "u") {
                const e = this.getUnionExtremes(!0);
                !e ||
                  (e.dataMin === t.min && e.dataMax === t.max) ||
                  ((t.min = e.dataMin), (t.max = e.dataMax));
              }
            }
            modifyBaseAxisExtremes() {
              const t = this.chart.navigator;
              var e = this.getExtremes();
              const s = e.dataMin,
                a = e.dataMax;
              e = e.max - e.min;
              const b = t.stickToMin,
                r = t.stickToMax,
                w = h(this.options.overscroll, 0),
                L = t.series && t.series[0],
                I = !!this.setExtremes;
              let V, B;
              (this.eventArgs &&
                this.eventArgs.trigger === "rangeSelectorButton") ||
                (b && ((B = s), (V = B + e)),
                r &&
                  ((V = a + w),
                  b ||
                    (B = Math.max(
                      s,
                      V - e,
                      t.getBaseSeriesMin(
                        L && L.xData ? L.xData[0] : -Number.MAX_VALUE
                      )
                    ))),
                I &&
                  (b || r) &&
                  j(B) &&
                  ((this.min = this.userMin = B),
                  (this.max = this.userMax = V))),
                (t.stickToMin = t.stickToMax = null);
            }
            updatedDataHandler() {
              const t = this.chart.navigator,
                e = this.navigatorSeries;
              (t.stickToMax = h(
                this.chart.options.navigator &&
                  this.chart.options.navigator.stickToMax,
                t.reversedExtremes
                  ? Math.round(t.zoomedMin) === 0
                  : Math.round(t.zoomedMax) >= Math.round(t.size)
              )),
                (t.stickToMin = t.shouldStickToMin(this, t)),
                e &&
                  !t.hasNavigatorData &&
                  ((e.options.pointStart = this.xData[0]),
                  e.setData(this.options.data, !1, null, !1));
            }
            shouldStickToMin(t, e) {
              e = e.getBaseSeriesMin(t.xData[0]);
              var s = t.xAxis;
              t = s.max;
              const a = s.min;
              return (
                (s = s.options.range),
                j(t) && j(a) ? (s && 0 < t - e ? t - e < s : a <= e) : !1
              );
            }
            addChartEvents() {
              this.eventsToUnbind || (this.eventsToUnbind = []),
                this.eventsToUnbind.push(
                  p(this.chart, "redraw", function () {
                    const t = this.navigator,
                      e =
                        t &&
                        ((t.baseSeries &&
                          t.baseSeries[0] &&
                          t.baseSeries[0].xAxis) ||
                          this.xAxis[0]);
                    e && t.render(e.min, e.max);
                  }),
                  p(this.chart, "getMargins", function () {
                    let t = this.navigator,
                      e = t.opposite ? "plotTop" : "marginBottom";
                    this.inverted &&
                      (e = t.opposite ? "marginRight" : "plotLeft"),
                      (this[e] =
                        (this[e] || 0) +
                        (t.navigatorEnabled || !this.inverted
                          ? t.height + t.scrollbarHeight
                          : 0) +
                        t.navigatorOptions.margin);
                  })
                );
            }
            destroy() {
              this.removeEvents(),
                this.xAxis &&
                  (g(this.chart.xAxis, this.xAxis),
                  g(this.chart.axes, this.xAxis)),
                this.yAxis &&
                  (g(this.chart.yAxis, this.yAxis),
                  g(this.chart.axes, this.yAxis)),
                (this.series || []).forEach((t) => {
                  t.destroy && t.destroy();
                }),
                "series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered"
                  .split(" ")
                  .forEach((t) => {
                    this[t] && this[t].destroy && this[t].destroy(),
                      (this[t] = null);
                  }),
                [this.handles].forEach((t) => {
                  d(t);
                });
            }
          }
          return o;
        }
      ),
      T(y, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function () {
        return {
          lang: {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "→",
          },
          rangeSelector: {
            allButtonsEnabled: !1,
            buttons: void 0,
            buttonSpacing: 5,
            dropdown: "responsive",
            enabled: void 0,
            verticalAlign: "top",
            buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 },
            floating: !1,
            x: 0,
            y: 0,
            height: void 0,
            inputBoxBorderColor: "none",
            inputBoxHeight: 17,
            inputBoxWidth: void 0,
            inputDateFormat: "%e %b %Y",
            inputDateParser: void 0,
            inputEditDateFormat: "%Y-%m-%d",
            inputEnabled: !0,
            inputPosition: { align: "right", x: 0, y: 0 },
            inputSpacing: 5,
            selected: void 0,
            buttonPosition: { align: "left", x: 0, y: 0 },
            inputStyle: {
              color: "#334eff",
              cursor: "pointer",
              fontSize: "0.8em",
            },
            labelStyle: { color: "#666666", fontSize: "0.8em" },
          },
        };
      }),
      T(
        y,
        "Stock/RangeSelector/RangeSelectorComposition.js",
        [
          y["Core/Defaults.js"],
          y["Stock/RangeSelector/RangeSelectorDefaults.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          function G() {
            const v = this.range,
              l = v.type,
              o = this.max,
              i = this.chart.time,
              t = function (b, r) {
                const w = l === "year" ? "FullYear" : "Month",
                  L = new i.Date(b),
                  I = i.get(w, L);
                return (
                  i.set(w, L, I + r),
                  I === i.get(w, L) && i.set("Date", L, 0),
                  L.getTime() - b
                );
              };
            let e, s;
            M(v)
              ? ((e = o - v), (s = v))
              : v &&
                ((e = o + t(o, -(v.count || 1))),
                this.chart && (this.chart.fixedRange = o - e));
            const a = P(this.dataMin, Number.MIN_VALUE);
            return (
              M(e) || (e = a),
              e <= a &&
                ((e = a),
                typeof s > "u" && (s = t(e, v.count)),
                (this.newMax = Math.min(
                  e + s,
                  P(this.dataMax, Number.MAX_VALUE)
                ))),
              M(o)
                ? !M(v) && v && v._offsetMin && (e += v._offsetMin)
                : (e = void 0),
              e
            );
          }
          function U() {
            this.options.rangeSelector &&
              this.options.rangeSelector.enabled &&
              (this.rangeSelector = new h(this));
          }
          function H() {
            var v = this.axes;
            const l = this.rangeSelector;
            l &&
              (M(l.deferredYTDClick) &&
                (l.clickButton(l.deferredYTDClick), delete l.deferredYTDClick),
              v.forEach((o) => {
                o.updateNames(), o.setScale();
              }),
              this.getAxisMargins(),
              l.render(),
              (v = l.options.verticalAlign),
              l.options.floating ||
                (v === "bottom"
                  ? (this.extraBottomMargin = !0)
                  : v !== "middle" && (this.extraTopMargin = !0)));
          }
          function Y(v) {
            let l, o, i, t;
            const e = v.rangeSelector,
              s = () => {
                e &&
                  ((l = v.xAxis[0].getExtremes()),
                  (o = v.legend),
                  (t = e && e.options.verticalAlign),
                  M(l.min) && e.render(l.min, l.max),
                  o.display &&
                    t === "top" &&
                    t === o.options.verticalAlign &&
                    ((i = C(v.spacingBox)),
                    (i.y =
                      o.options.layout === "vertical"
                        ? v.plotTop
                        : i.y + e.getHeight()),
                    (o.group.placed = !1),
                    o.align(i)));
              };
            e &&
              (g(j, (a) => a[0] === v) ||
                j.push([
                  v,
                  [
                    u(v.xAxis[0], "afterSetExtremes", function (a) {
                      e && e.render(a.min, a.max);
                    }),
                    u(v, "redraw", s),
                  ],
                ]),
              s());
          }
          function S() {
            for (let v = 0, l = j.length; v < l; ++v) {
              const o = j[v];
              if (o[0] === this) {
                o[1].forEach((i) => i()), j.splice(v, 1);
                break;
              }
            }
          }
          function N() {
            var v = this.rangeSelector;
            v &&
              ((v = v.getHeight()),
              this.extraTopMargin && (this.plotTop += v),
              this.extraBottomMargin && (this.marginBottom += v));
          }
          function D() {
            var v = this.rangeSelector;
            v &&
              !v.options.floating &&
              (v.render(),
              (v = v.options.verticalAlign),
              v === "bottom"
                ? (this.extraBottomMargin = !0)
                : v !== "middle" && (this.extraTopMargin = !0));
          }
          function c(v) {
            var l = v.options.rangeSelector;
            v = this.extraBottomMargin;
            const o = this.extraTopMargin;
            let i = this.rangeSelector;
            l &&
              l.enabled &&
              !n(i) &&
              this.options.rangeSelector &&
              ((this.options.rangeSelector.enabled = !0),
              (this.rangeSelector = i = new h(this))),
              (this.extraTopMargin = this.extraBottomMargin = !1),
              i &&
                (Y(this),
                (l =
                  (l && l.verticalAlign) ||
                  (i.options && i.options.verticalAlign)),
                i.options.floating ||
                  (l === "bottom"
                    ? (this.extraBottomMargin = !0)
                    : l !== "middle" && (this.extraTopMargin = !0)),
                this.extraBottomMargin !== v || this.extraTopMargin !== o) &&
                (this.isDirtyBox = !0);
          }
          const { defaultOptions: p, setOptions: f } = A,
            {
              addEvent: u,
              defined: n,
              extend: d,
              find: g,
              isNumber: M,
              merge: C,
              pick: P,
            } = F,
            j = [],
            m = [];
          let h;
          return {
            compose: function (v, l, o) {
              (h = o),
                F.pushUnique(m, v) && (v.prototype.minFromRange = G),
                F.pushUnique(m, l) &&
                  (u(l, "afterGetContainer", U),
                  u(l, "beforeRender", H),
                  u(l, "destroy", S),
                  u(l, "getMargins", N),
                  u(l, "render", D),
                  u(l, "update", c),
                  l.prototype.callbacks.push(Y)),
                F.pushUnique(m, f) &&
                  (d(p, { rangeSelector: O.rangeSelector }), d(p.lang, O.lang));
            },
          };
        }
      ),
      T(
        y,
        "Stock/RangeSelector/RangeSelector.js",
        [
          y["Core/Axis/Axis.js"],
          y["Core/Defaults.js"],
          y["Core/Globals.js"],
          y["Stock/RangeSelector/RangeSelectorComposition.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H) {
          function Y(l) {
            if (l.indexOf("%L") !== -1) return "text";
            const o = "aAdewbBmoyY"
                .split("")
                .some((t) => l.indexOf("%" + t) !== -1),
              i = "HkIlMS".split("").some((t) => l.indexOf("%" + t) !== -1);
            return o && i ? "datetime-local" : o ? "date" : i ? "time" : "text";
          }
          const { defaultOptions: S } = O,
            {
              addEvent: N,
              createElement: D,
              css: c,
              defined: p,
              destroyObjectProperties: f,
              discardElement: u,
              extend: n,
              fireEvent: d,
              isNumber: g,
              merge: M,
              objectEach: C,
              pad: P,
              pick: j,
              pInt: m,
              splat: h,
            } = H;
          class v {
            static compose(o, i) {
              G.compose(o, i, v);
            }
            constructor(o) {
              (this.buttons = void 0),
                (this.buttonOptions = v.prototype.defaultButtons),
                (this.initialButtonGroupWidth = 0),
                (this.options = void 0),
                (this.chart = o),
                this.init(o);
            }
            clickButton(o, i) {
              const t = this.chart,
                e = this.buttonOptions[o],
                s = t.xAxis[0];
              var a = (t.scroller && t.scroller.getUnionExtremes()) || s || {},
                b = e.type;
              const r = e.dataGrouping;
              let w = a.dataMin,
                L = a.dataMax,
                I,
                V = s && Math.round(Math.min(s.max, j(L, s.max))),
                B;
              a = e._range;
              let x,
                R,
                W,
                X = !0;
              if (w !== null && L !== null) {
                if (
                  ((t.fixedRange = a),
                  this.setSelected(o),
                  r &&
                    ((this.forcedDataGrouping = !0),
                    A.prototype.setDataGrouping.call(
                      s || { chart: this.chart },
                      r,
                      !1
                    ),
                    (this.frozenStates = e.preserveDataGrouping)),
                  b === "month" || b === "year")
                )
                  s
                    ? ((b = {
                        range: e,
                        max: V,
                        chart: t,
                        dataMin: w,
                        dataMax: L,
                      }),
                      (I = s.minFromRange.call(b)),
                      g(b.newMax) && (V = b.newMax),
                      (X = !1))
                    : (a = e);
                else if (a)
                  (I = Math.max(V - a, w)), (V = Math.min(I + a, L)), (X = !1);
                else if (b === "ytd")
                  if (s)
                    (typeof L > "u" || typeof w > "u") &&
                      ((w = Number.MAX_VALUE),
                      (L = Number.MIN_VALUE),
                      t.series.forEach((Z) => {
                        (Z = Z.xData) &&
                          ((w = Math.min(Z[0], w)),
                          (L = Math.max(Z[Z.length - 1], L)));
                      }),
                      (i = !1)),
                      (b = this.getYTDExtremes(L, w, t.time.useUTC)),
                      (I = x = b.min),
                      (V = b.max);
                  else {
                    this.deferredYTDClick = o;
                    return;
                  }
                else
                  b === "all" &&
                    s &&
                    (t.navigator &&
                      t.navigator.baseSeries[0] &&
                      (t.navigator.baseSeries[0].xAxis.options.range = void 0),
                    (I = w),
                    (V = L));
                X && e._offsetMin && p(I) && (I += e._offsetMin),
                  e._offsetMax && p(V) && (V += e._offsetMax),
                  this.dropdown && (this.dropdown.selectedIndex = o + 1),
                  s
                    ? s.setExtremes(I, V, j(i, !0), void 0, {
                        trigger: "rangeSelectorButton",
                        rangeSelectorButton: e,
                      })
                    : ((B = h(t.options.xAxis)[0]),
                      (W = B.range),
                      (B.range = a),
                      (R = B.min),
                      (B.min = x),
                      N(t, "load", function () {
                        (B.range = W), (B.min = R);
                      })),
                  d(this, "afterBtnClick");
              }
            }
            setSelected(o) {
              this.selected = this.options.selected = o;
            }
            init(o) {
              const i = this,
                t = o.options.rangeSelector,
                e = t.buttons || i.defaultButtons.slice(),
                s = t.selected,
                a = function () {
                  const b = i.minInput,
                    r = i.maxInput;
                  b && b.blur && d(b, "blur"), r && r.blur && d(r, "blur");
                };
              (i.chart = o),
                (i.options = t),
                (i.buttons = []),
                (i.buttonOptions = e),
                (this.eventsToUnbind = []),
                this.eventsToUnbind.push(N(o.container, "mousedown", a)),
                this.eventsToUnbind.push(N(o, "resize", a)),
                e.forEach(i.computeButtonRange),
                typeof s < "u" && e[s] && this.clickButton(s, !1),
                this.eventsToUnbind.push(
                  N(o, "load", function () {
                    o.xAxis &&
                      o.xAxis[0] &&
                      N(o.xAxis[0], "setExtremes", function (b) {
                        this.max - this.min !== o.fixedRange &&
                          b.trigger !== "rangeSelectorButton" &&
                          b.trigger !== "updatedData" &&
                          i.forcedDataGrouping &&
                          !i.frozenStates &&
                          this.setDataGrouping(!1, !1);
                      });
                  })
                );
            }
            updateButtonStates() {
              const o = this;
              var i = this.chart;
              const t = this.dropdown,
                e = i.xAxis[0],
                s = Math.round(e.max - e.min),
                a = !e.hasVisibleSeries,
                b = (i.scroller && i.scroller.getUnionExtremes()) || e,
                r = b.dataMin,
                w = b.dataMax;
              i = o.getYTDExtremes(w, r, i.time.useUTC);
              const L = i.min,
                I = i.max,
                V = o.selected,
                B = o.options.allButtonsEnabled,
                x = o.buttons;
              let R = g(V);
              o.buttonOptions.forEach((W, X) => {
                var Z = W._range,
                  E = W.type,
                  _ = W.count || 1;
                const z = x[X],
                  J = W._offsetMax - W._offsetMin,
                  tt = X === V,
                  $ = Z > w - r,
                  it = Z < e.minRange;
                W = 0;
                let nt = !1,
                  rt = !1;
                (Z = Z === s),
                  (E === "month" || E === "year") &&
                  s + 36e5 >= 864e5 * { month: 28, year: 365 }[E] * _ - J &&
                  s - 36e5 <= 864e5 * { month: 31, year: 366 }[E] * _ + J
                    ? (Z = !0)
                    : E === "ytd"
                    ? ((Z = I - L + J === s), (nt = !tt))
                    : E === "all" &&
                      ((Z = e.max - e.min >= w - r), (rt = !tt && R && Z)),
                  (E = !B && ($ || it || rt || a)),
                  (_ = (tt && Z) || (Z && !R && !nt) || (tt && o.frozenStates)),
                  E ? (W = 3) : _ && ((R = !0), (W = 2)),
                  z.state !== W &&
                    (z.setState(W),
                    t &&
                      ((t.options[X + 1].disabled = E),
                      W === 2 && (t.selectedIndex = X + 1)),
                    W === 0 && V === X && o.setSelected());
              });
            }
            computeButtonRange(o) {
              const i = o.type,
                t = o.count || 1,
                e = {
                  millisecond: 1,
                  second: 1e3,
                  minute: 6e4,
                  hour: 36e5,
                  day: 864e5,
                  week: 6048e5,
                };
              e[i]
                ? (o._range = e[i] * t)
                : (i === "month" || i === "year") &&
                  (o._range = 864e5 * { month: 30, year: 365 }[i] * t),
                (o._offsetMin = j(o.offsetMin, 0)),
                (o._offsetMax = j(o.offsetMax, 0)),
                (o._range += o._offsetMax - o._offsetMin);
            }
            getInputValue(o) {
              o = o === "min" ? this.minInput : this.maxInput;
              const i = this.chart.options.rangeSelector,
                t = this.chart.time;
              return o
                ? (
                    (o.type === "text" && i.inputDateParser) ||
                    this.defaultInputDateParser
                  )(o.value, t.useUTC, t)
                : 0;
            }
            setInputValue(o, i) {
              const t = this.options,
                e = this.chart.time,
                s = o === "min" ? this.minInput : this.maxInput;
              if (((o = o === "min" ? this.minDateBox : this.maxDateBox), s)) {
                var a = s.getAttribute("data-hc-time");
                (a = p(a) ? Number(a) : void 0),
                  p(i) &&
                    (p(a) && s.setAttribute("data-hc-time-previous", a),
                    s.setAttribute("data-hc-time", i),
                    (a = i)),
                  (s.value = e.dateFormat(
                    this.inputTypeFormats[s.type] || t.inputEditDateFormat,
                    a
                  )),
                  o && o.attr({ text: e.dateFormat(t.inputDateFormat, a) });
              }
            }
            setInputExtremes(o, i, t) {
              if ((o = o === "min" ? this.minInput : this.maxInput)) {
                const e = this.inputTypeFormats[o.type],
                  s = this.chart.time;
                e &&
                  ((i = s.dateFormat(e, i)),
                  o.min !== i && (o.min = i),
                  (t = s.dateFormat(e, t)),
                  o.max !== t && (o.max = t));
              }
            }
            showInput(o) {
              const i = o === "min" ? this.minDateBox : this.maxDateBox;
              if (
                (o = o === "min" ? this.minInput : this.maxInput) &&
                i &&
                this.inputGroup
              ) {
                const t = o.type === "text",
                  { translateX: e, translateY: s } = this.inputGroup,
                  { inputBoxWidth: a } = this.options;
                c(o, {
                  width: t ? i.width + (a ? -2 : 20) + "px" : "auto",
                  height: i.height - 2 + "px",
                  border: "2px solid silver",
                }),
                  t && a
                    ? c(o, { left: e + i.x + "px", top: s + "px" })
                    : c(o, {
                        left:
                          Math.min(
                            Math.round(i.x + e - (o.offsetWidth - i.width) / 2),
                            this.chart.chartWidth - o.offsetWidth
                          ) + "px",
                        top: s - (o.offsetHeight - i.height) / 2 + "px",
                      });
              }
            }
            hideInput(o) {
              (o = o === "min" ? this.minInput : this.maxInput) &&
                c(o, {
                  top: "-9999em",
                  border: 0,
                  width: "1px",
                  height: "1px",
                });
            }
            defaultInputDateParser(o, i, t) {
              var e = o.split("/").join("-").split(" ").join("T");
              if ((e.indexOf("T") === -1 && (e += "T00:00"), i)) e += "Z";
              else {
                var s;
                (s = F.isSafari) &&
                  ((s = e),
                  (s = !(
                    6 < s.length &&
                    (s.lastIndexOf("-") === s.length - 6 ||
                      s.lastIndexOf("+") === s.length - 6)
                  ))),
                  s &&
                    ((s = new Date(e).getTimezoneOffset() / 60),
                    (e += 0 >= s ? `+${P(-s)}:00` : `-${P(s)}:00`));
              }
              return (
                (e = Date.parse(e)),
                g(e) ||
                  ((o = o.split("-")),
                  (e = Date.UTC(m(o[0]), m(o[1]) - 1, m(o[2])))),
                t && i && g(e) && (e += t.getTimezoneOffset(e)),
                e
              );
            }
            drawInput(o) {
              function i() {
                const { maxInput: x, minInput: R } = a,
                  W = t.xAxis[0];
                var X = t.scroller && t.scroller.xAxis ? t.scroller.xAxis : W;
                const Z = X.dataMin;
                X = X.dataMax;
                let E = a.getInputValue(o);
                E !== Number(V.getAttribute("data-hc-time-previous")) &&
                  g(E) &&
                  (V.setAttribute("data-hc-time-previous", E),
                  L && x && g(Z)
                    ? E > Number(x.getAttribute("data-hc-time"))
                      ? (E = void 0)
                      : E < Z && (E = Z)
                    : R &&
                      g(X) &&
                      (E < Number(R.getAttribute("data-hc-time"))
                        ? (E = void 0)
                        : E > X && (E = X)),
                  typeof E < "u" &&
                    W.setExtremes(
                      L ? E : W.min,
                      L ? W.max : E,
                      void 0,
                      void 0,
                      { trigger: "rangeSelectorInput" }
                    ));
              }
              const { chart: t, div: e, inputGroup: s } = this,
                a = this,
                b = t.renderer.style || {};
              var r = t.renderer;
              const w = t.options.rangeSelector,
                L = o === "min";
              var I = S.lang[L ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
              (I = r
                .label(I, 0)
                .addClass("highcharts-range-label")
                .attr({ padding: I ? 2 : 0, height: I ? w.inputBoxHeight : 0 })
                .add(s)),
                (r = r
                  .label("", 0)
                  .addClass("highcharts-range-input")
                  .attr({
                    padding: 2,
                    width: w.inputBoxWidth,
                    height: w.inputBoxHeight,
                    "text-align": "center",
                  })
                  .on("click", function () {
                    a.showInput(o), a[o + "Input"].focus();
                  })),
                t.styledMode ||
                  r.attr({ stroke: w.inputBoxBorderColor, "stroke-width": 1 }),
                r.add(s);
              const V = D(
                "input",
                { name: o, className: "highcharts-range-selector" },
                void 0,
                e
              );
              V.setAttribute("type", Y(w.inputDateFormat || "%e %b %Y")),
                t.styledMode ||
                  (I.css(M(b, w.labelStyle)),
                  r.css(M({ color: "#333333" }, b, w.inputStyle)),
                  c(
                    V,
                    n(
                      {
                        position: "absolute",
                        border: 0,
                        boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                        width: "1px",
                        height: "1px",
                        padding: 0,
                        textAlign: "center",
                        fontSize: b.fontSize,
                        fontFamily: b.fontFamily,
                        top: "-9999em",
                      },
                      w.inputStyle
                    )
                  )),
                (V.onfocus = () => {
                  a.showInput(o);
                }),
                (V.onblur = () => {
                  V === F.doc.activeElement && i(),
                    a.hideInput(o),
                    a.setInputValue(o),
                    V.blur();
                });
              let B = !1;
              return (
                (V.onchange = () => {
                  B || (i(), a.hideInput(o), V.blur());
                }),
                (V.onkeypress = (x) => {
                  x.keyCode === 13 && i();
                }),
                (V.onkeydown = (x) => {
                  (B = !0), (x.keyCode !== 38 && x.keyCode !== 40) || i();
                }),
                (V.onkeyup = () => {
                  B = !1;
                }),
                { dateBox: r, input: V, label: I }
              );
            }
            getPosition() {
              var o = this.chart;
              const i = o.options.rangeSelector;
              return (
                (o =
                  i.verticalAlign === "top" ? o.plotTop - o.axisOffset[0] : 0),
                {
                  buttonTop: o + i.buttonPosition.y,
                  inputTop: o + i.inputPosition.y - 10,
                }
              );
            }
            getYTDExtremes(o, i, t) {
              const e = this.chart.time;
              var s = new e.Date(o);
              const a = e.get("FullYear", s);
              return (
                (t = t ? e.Date.UTC(a, 0, 1) : +new e.Date(a, 0, 1)),
                (i = Math.max(i, t)),
                (s = s.getTime()),
                { max: Math.min(o || s, s), min: i }
              );
            }
            render(o, i) {
              var t = this.chart,
                e = t.renderer;
              const s = t.container;
              var a = t.options;
              const b = a.rangeSelector,
                r = j(a.chart.style && a.chart.style.zIndex, 0) + 1;
              if (((a = b.inputEnabled), b.enabled !== !1)) {
                if (
                  (this.rendered ||
                    ((this.group = e
                      .g("range-selector-group")
                      .attr({ zIndex: 7 })
                      .add()),
                    (this.div = D("div", void 0, {
                      position: "relative",
                      height: 0,
                      zIndex: r,
                    })),
                    this.buttonOptions.length && this.renderButtons(),
                    s.parentNode && s.parentNode.insertBefore(this.div, s),
                    a &&
                      ((this.inputGroup = e.g("input-group").add(this.group)),
                      (e = this.drawInput("min")),
                      (this.minDateBox = e.dateBox),
                      (this.minLabel = e.label),
                      (this.minInput = e.input),
                      (e = this.drawInput("max")),
                      (this.maxDateBox = e.dateBox),
                      (this.maxLabel = e.label),
                      (this.maxInput = e.input))),
                  a &&
                    (this.setInputValue("min", o),
                    this.setInputValue("max", i),
                    (o =
                      (t.scroller && t.scroller.getUnionExtremes()) ||
                      t.xAxis[0] ||
                      {}),
                    p(o.dataMin) &&
                      p(o.dataMax) &&
                      ((t = t.xAxis[0].minRange || 0),
                      this.setInputExtremes(
                        "min",
                        o.dataMin,
                        Math.min(o.dataMax, this.getInputValue("max")) - t
                      ),
                      this.setInputExtremes(
                        "max",
                        Math.max(o.dataMin, this.getInputValue("min")) + t,
                        o.dataMax
                      )),
                    this.inputGroup))
                ) {
                  let w = 0;
                  [
                    this.minLabel,
                    this.minDateBox,
                    this.maxLabel,
                    this.maxDateBox,
                  ].forEach((L) => {
                    if (L) {
                      const { width: I } = L.getBBox();
                      I && (L.attr({ x: w }), (w += I + b.inputSpacing));
                    }
                  });
                }
                this.alignElements(), (this.rendered = !0);
              }
            }
            renderButtons() {
              const { buttons: o, chart: i, options: t } = this,
                e = S.lang,
                s = i.renderer,
                a = M(t.buttonTheme),
                b = a && a.states,
                r = a.width || 28;
              delete a.width,
                delete a.states,
                (this.buttonGroup = s
                  .g("range-selector-buttons")
                  .add(this.group));
              const w = (this.dropdown = D(
                "select",
                void 0,
                {
                  position: "absolute",
                  width: "1px",
                  height: "1px",
                  padding: 0,
                  border: 0,
                  top: "-9999em",
                  cursor: "pointer",
                  opacity: 1e-4,
                },
                this.div
              ));
              N(w, "touchstart", () => {
                w.style.fontSize = "16px";
              }),
                [
                  [F.isMS ? "mouseover" : "mouseenter"],
                  [F.isMS ? "mouseout" : "mouseleave"],
                  ["change", "click"],
                ].forEach(([L, I]) => {
                  N(w, L, () => {
                    const V = o[this.currentButtonIndex()];
                    V && d(V.element, I || L);
                  });
                }),
                (this.zoomText = s
                  .label((e && e.rangeSelectorZoom) || "", 0)
                  .attr({
                    padding: t.buttonTheme.padding,
                    height: t.buttonTheme.height,
                    paddingLeft: 0,
                    paddingRight: 0,
                  })
                  .add(this.buttonGroup)),
                this.chart.styledMode ||
                  (this.zoomText.css(t.labelStyle),
                  (a["stroke-width"] = j(a["stroke-width"], 0))),
                D(
                  "option",
                  { textContent: this.zoomText.textStr, disabled: !0 },
                  void 0,
                  w
                ),
                this.buttonOptions.forEach((L, I) => {
                  D("option", { textContent: L.title || L.text }, void 0, w),
                    (o[I] = s
                      .button(
                        L.text,
                        0,
                        0,
                        (V) => {
                          const B = L.events && L.events.click;
                          let x;
                          B && (x = B.call(L, V)),
                            x !== !1 && this.clickButton(I),
                            (this.isActive = !0);
                        },
                        a,
                        b && b.hover,
                        b && b.select,
                        b && b.disabled
                      )
                      .attr({ "text-align": "center", width: r })
                      .add(this.buttonGroup)),
                    L.title && o[I].attr("title", L.title);
                });
            }
            alignElements() {
              const {
                buttonGroup: o,
                buttons: i,
                chart: t,
                group: e,
                inputGroup: s,
                options: a,
                zoomText: b,
              } = this;
              var r = t.options;
              const w =
                  r.exporting &&
                  r.exporting.enabled !== !1 &&
                  r.navigation &&
                  r.navigation.buttonOptions,
                { buttonPosition: L, inputPosition: I, verticalAlign: V } = a;
              r = (W, X) =>
                w &&
                this.titleCollision(t) &&
                V === "top" &&
                X.align === "right" &&
                X.y - W.getBBox().height - 12 <
                  (w.y || 0) + (w.height || 0) + t.spacing[0]
                  ? -40
                  : 0;
              var B = t.plotLeft;
              if (e && L && I) {
                var x = L.x - t.spacing[3];
                if (o) {
                  if ((this.positionButtons(), !this.initialButtonGroupWidth)) {
                    let E = 0;
                    b && (E += b.getBBox().width + 5),
                      i.forEach((_, z) => {
                        (E += _.width),
                          z !== i.length - 1 && (E += a.buttonSpacing);
                      }),
                      (this.initialButtonGroupWidth = E);
                  }
                  (B -= t.spacing[3]), this.updateButtonStates();
                  var R = r(o, L);
                  this.alignButtonGroup(R), (e.placed = o.placed = t.hasLoaded);
                }
                (R = 0),
                  s &&
                    ((R = r(s, I)),
                    I.align === "left"
                      ? (x = B)
                      : I.align === "right" &&
                        (x = -Math.max(t.axisOffset[1], -R)),
                    s.align(
                      {
                        y: I.y,
                        width: s.getBBox().width,
                        align: I.align,
                        x: I.x + x - 2,
                      },
                      !0,
                      t.spacingBox
                    ),
                    (s.placed = t.hasLoaded)),
                  this.handleCollision(R),
                  e.align({ verticalAlign: V }, !0, t.spacingBox),
                  (r = e.alignAttr.translateY),
                  (B = e.getBBox().height + 20),
                  (x = 0),
                  V === "bottom" &&
                    ((x =
                      (x = t.legend && t.legend.options) &&
                      x.verticalAlign === "bottom" &&
                      x.enabled &&
                      !x.floating
                        ? t.legend.legendHeight + j(x.margin, 10)
                        : 0),
                    (B = B + x - 20),
                    (x =
                      r -
                      B -
                      (a.floating ? 0 : a.y) -
                      (t.titleOffset ? t.titleOffset[2] : 0) -
                      10)),
                  V === "top"
                    ? (a.floating && (x = 0),
                      t.titleOffset &&
                        t.titleOffset[0] &&
                        (x = t.titleOffset[0]),
                      (x += t.margin[0] - t.spacing[0] || 0))
                    : V === "middle" &&
                      (I.y === L.y
                        ? (x = r)
                        : (I.y || L.y) &&
                          (x =
                            0 > I.y || 0 > L.y
                              ? x - Math.min(I.y, L.y)
                              : r - B)),
                  e.translate(a.x, a.y + Math.floor(x));
                const { minInput: W, maxInput: X, dropdown: Z } = this;
                a.inputEnabled &&
                  W &&
                  X &&
                  ((W.style.marginTop = e.translateY + "px"),
                  (X.style.marginTop = e.translateY + "px")),
                  Z && (Z.style.marginTop = e.translateY + "px");
              }
            }
            alignButtonGroup(o, i) {
              const { chart: t, options: e, buttonGroup: s } = this,
                { buttonPosition: a } = e,
                b = t.plotLeft - t.spacing[3];
              let r = a.x - t.spacing[3];
              a.align === "right"
                ? (r += o - b)
                : a.align === "center" && (r -= b / 2),
                s &&
                  s.align(
                    {
                      y: a.y,
                      width: j(i, this.initialButtonGroupWidth),
                      align: a.align,
                      x: r,
                    },
                    !0,
                    t.spacingBox
                  );
            }
            positionButtons() {
              const { buttons: o, chart: i, options: t, zoomText: e } = this,
                s = i.hasLoaded ? "animate" : "attr",
                { buttonPosition: a } = t,
                b = i.plotLeft;
              let r = b;
              e &&
                e.visibility !== "hidden" &&
                (e[s]({ x: j(b + a.x, b) }),
                (r += a.x + e.getBBox().width + 5));
              for (let w = 0, L = this.buttonOptions.length; w < L; ++w)
                o[w].visibility !== "hidden"
                  ? (o[w][s]({ x: r }), (r += o[w].width + t.buttonSpacing))
                  : o[w][s]({ x: b });
            }
            handleCollision(o) {
              const { chart: i, buttonGroup: t, inputGroup: e } = this,
                {
                  buttonPosition: s,
                  dropdown: a,
                  inputPosition: b,
                } = this.options,
                r = () => {
                  let I = 0;
                  return (
                    this.buttons.forEach((V) => {
                      (V = V.getBBox()), V.width > I && (I = V.width);
                    }),
                    I
                  );
                },
                w = (I) => {
                  if (e && t) {
                    const V =
                        e.alignAttr.translateX +
                        e.alignOptions.x -
                        o +
                        e.getBBox().x +
                        2,
                      B = e.alignOptions.width,
                      x = t.alignAttr.translateX + t.getBBox().x;
                    return (
                      x + I > V && V + B > x && s.y < b.y + e.getBBox().height
                    );
                  }
                  return !1;
                },
                L = () => {
                  e &&
                    t &&
                    e.attr({
                      translateX:
                        e.alignAttr.translateX +
                        (i.axisOffset[1] >= -o ? 0 : -o),
                      translateY:
                        e.alignAttr.translateY + t.getBBox().height + 10,
                    });
                };
              if (t) {
                if (a === "always") {
                  this.collapseButtons(o), w(r()) && L();
                  return;
                }
                a === "never" && this.expandButtons();
              }
              e && t
                ? b.align === s.align || w(this.initialButtonGroupWidth + 20)
                  ? a === "responsive"
                    ? (this.collapseButtons(o), w(r()) && L())
                    : L()
                  : a === "responsive" && this.expandButtons()
                : t &&
                  a === "responsive" &&
                  (this.initialButtonGroupWidth > i.plotWidth
                    ? this.collapseButtons(o)
                    : this.expandButtons());
            }
            collapseButtons(o) {
              const {
                  buttons: i,
                  buttonOptions: t,
                  chart: e,
                  dropdown: s,
                  options: a,
                  zoomText: b,
                } = this,
                r =
                  (e.userOptions.rangeSelector &&
                    e.userOptions.rangeSelector.buttonTheme) ||
                  {},
                w = (V) => ({
                  text: V ? `${V} ▾` : "▾",
                  width: "auto",
                  paddingLeft: j(a.buttonTheme.paddingLeft, r.padding, 8),
                  paddingRight: j(a.buttonTheme.paddingRight, r.padding, 8),
                });
              b && b.hide();
              let L = !1;
              t.forEach((V, B) => {
                (B = i[B]),
                  B.state !== 2
                    ? B.hide()
                    : (B.show(), B.attr(w(V.text)), (L = !0));
              }),
                L ||
                  (s && (s.selectedIndex = 0),
                  i[0].show(),
                  i[0].attr(w(this.zoomText && this.zoomText.textStr)));
              const { align: I } = a.buttonPosition;
              this.positionButtons(),
                (I !== "right" && I !== "center") ||
                  this.alignButtonGroup(
                    o,
                    i[this.currentButtonIndex()].getBBox().width
                  ),
                this.showDropdown();
            }
            expandButtons() {
              const {
                buttons: o,
                buttonOptions: i,
                options: t,
                zoomText: e,
              } = this;
              this.hideDropdown(),
                e && e.show(),
                i.forEach((s, a) => {
                  (a = o[a]),
                    a.show(),
                    a.attr({
                      text: s.text,
                      width: t.buttonTheme.width || 28,
                      paddingLeft: j(t.buttonTheme.paddingLeft, "unset"),
                      paddingRight: j(t.buttonTheme.paddingRight, "unset"),
                    }),
                    2 > a.state && a.setState(0);
                }),
                this.positionButtons();
            }
            currentButtonIndex() {
              const { dropdown: o } = this;
              return o && 0 < o.selectedIndex ? o.selectedIndex - 1 : 0;
            }
            showDropdown() {
              const {
                buttonGroup: o,
                buttons: i,
                chart: t,
                dropdown: e,
              } = this;
              if (o && e) {
                const { translateX: s, translateY: a } = o,
                  b = i[this.currentButtonIndex()].getBBox();
                c(e, {
                  left: t.plotLeft + s + "px",
                  top: a + 0.5 + "px",
                  width: b.width + "px",
                  height: b.height + "px",
                }),
                  (this.hasVisibleDropdown = !0);
              }
            }
            hideDropdown() {
              const { dropdown: o } = this;
              o &&
                (c(o, { top: "-9999em", width: "1px", height: "1px" }),
                (this.hasVisibleDropdown = !1));
            }
            getHeight() {
              var o = this.options,
                i = this.group;
              const t = o.y,
                e = o.buttonPosition.y,
                s = o.inputPosition.y;
              return o.height
                ? o.height
                : (this.alignElements(),
                  (o = i ? i.getBBox(!0).height + 13 + t : 0),
                  (i = Math.min(s, e)),
                  ((0 > s && 0 > e) || (0 < s && 0 < e)) && (o += Math.abs(i)),
                  o);
            }
            titleCollision(o) {
              return !(o.options.title.text || o.options.subtitle.text);
            }
            update(o) {
              const i = this.chart;
              M(!0, i.options.rangeSelector, o),
                this.destroy(),
                this.init(i),
                this.render();
            }
            destroy() {
              const o = this,
                i = o.minInput,
                t = o.maxInput;
              o.eventsToUnbind &&
                (o.eventsToUnbind.forEach((e) => e()),
                (o.eventsToUnbind = void 0)),
                f(o.buttons),
                i && (i.onfocus = i.onblur = i.onchange = null),
                t && (t.onfocus = t.onblur = t.onchange = null),
                C(
                  o,
                  function (e, s) {
                    e &&
                      s !== "chart" &&
                      (e instanceof U
                        ? e.destroy()
                        : e instanceof k.HTMLElement && u(e)),
                      e !== v.prototype[s] && (o[s] = null);
                  },
                  this
                );
            }
          }
          return (
            n(v.prototype, {
              defaultButtons: [
                { type: "month", count: 1, text: "1m", title: "View 1 month" },
                { type: "month", count: 3, text: "3m", title: "View 3 months" },
                { type: "month", count: 6, text: "6m", title: "View 6 months" },
                { type: "ytd", text: "YTD", title: "View year to date" },
                { type: "year", count: 1, text: "1y", title: "View 1 year" },
                { type: "all", text: "All", title: "View all" },
              ],
              inputTypeFormats: {
                "datetime-local": "%Y-%m-%dT%H:%M:%S",
                date: "%Y-%m-%d",
                time: "%H:%M:%S",
              },
            }),
            v
          );
        }
      ),
      T(
        y,
        "Core/Axis/OrdinalAxis.js",
        [
          y["Core/Axis/Axis.js"],
          y["Core/Globals.js"],
          y["Core/Series/Series.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          const {
              addEvent: U,
              correctFloat: H,
              css: Y,
              defined: S,
              error: N,
              pick: D,
              timeUnits: c,
            } = G,
            p = [];
          var f;
          return (
            (function (u) {
              function n(i, t, e, s, a = [], b = 0, r) {
                const w = {},
                  L = this.options.tickPixelInterval;
                var I = this.chart.time,
                  V = [],
                  B;
                let x, R;
                var W = 0;
                let X = [],
                  Z = -Number.MAX_VALUE;
                if (
                  (!this.options.ordinal && !this.options.breaks) ||
                  !a ||
                  3 > a.length ||
                  typeof t > "u"
                )
                  return I.getTimeTicks.apply(I, arguments);
                const E = a.length;
                for (B = 0; B < E; B++) {
                  if (
                    ((R = B && a[B - 1] > e),
                    a[B] < t && (W = B),
                    B === E - 1 || a[B + 1] - a[B] > 5 * b || R)
                  ) {
                    if (a[B] > Z) {
                      for (
                        x = I.getTimeTicks(i, a[W], a[B], s);
                        x.length && x[0] <= Z;

                      )
                        x.shift();
                      x.length && (Z = x[x.length - 1]),
                        V.push(X.length),
                        (X = X.concat(x));
                    }
                    W = B + 1;
                  }
                  if (R) break;
                }
                if (x) {
                  if (((a = x.info), r && a.unitRange <= c.hour)) {
                    for (B = X.length - 1, W = 1; W < B; W++)
                      if (
                        I.dateFormat("%d", X[W]) !==
                        I.dateFormat("%d", X[W - 1])
                      ) {
                        w[X[W]] = "day";
                        var _ = !0;
                      }
                    _ && (w[X[0]] = "day"), (a.higherRanks = w);
                  }
                  (a.segmentStarts = V), (X.info = a);
                } else N(12, !1, this.chart);
                if (r && S(L)) {
                  (W = X.length), (I = []), (_ = []);
                  let z;
                  for (B = W; B--; )
                    (V = this.translate(X[B])),
                      z && (_[B] = z - V),
                      (I[B] = z = V);
                  for (
                    _.sort(),
                      _ = _[Math.floor(_.length / 2)],
                      _ < 0.6 * L && (_ = null),
                      B = X[W - 1] > e ? W - 1 : W,
                      z = void 0;
                    B--;

                  )
                    (V = I[B]),
                      (W = Math.abs(z - V)),
                      z && W < 0.8 * L && (_ === null || W < 0.8 * _)
                        ? (w[X[B]] && !w[X[B + 1]]
                            ? ((W = B + 1), (z = V))
                            : (W = B),
                          X.splice(W, 1))
                        : (z = V);
                }
                return X;
              }
              function d(i) {
                const t = this.ordinal.positions;
                if (!t) return i;
                let e = t.length - 1,
                  s;
                return (
                  0 > i
                    ? (i = t[0])
                    : i > e
                    ? (i = t[e])
                    : ((e = Math.floor(i)), (s = i - e)),
                  typeof s < "u" && typeof t[e] < "u"
                    ? t[e] + (s ? s * (t[e + 1] - t[e]) : 0)
                    : i
                );
              }
              function g(i) {
                var t = this.ordinal,
                  e = t.positions;
                if (!e) return i;
                var s = H(
                  (i - (this.old ? this.old.min : this.min)) *
                    (this.old ? this.old.transA : this.transA) +
                    this.minPixelPadding
                );
                if (
                  ((i >= e[0] && i <= e[e.length - 1]) ||
                    (t.extendedOrdinalPositions ||
                      (t.extendedOrdinalPositions = t.getExtendedPositions()),
                    (e = t.extendedOrdinalPositions)),
                  e && e.length)
                ) {
                  if (
                    ((i = e.indexOf(i)),
                    (t = i !== -1 ? i : H(t.getIndexOfPoint(s, e))),
                    (s = H(t % 1)),
                    0 <= t && t <= e.length - 1)
                  )
                    return (
                      e[Math.floor(t)] +
                      s * (e[Math.ceil(t)] - e[Math.floor(t)])
                    );
                  (s = e.length), (i = e[0]), (e = e[s - 1]);
                  const a = (e - i) / (s - 1);
                  return 0 > t ? i + a * t : e + a * (t - s);
                }
                return i;
              }
              function M(i, t) {
                const e = u.Additions.findIndexOf(i, t, !0);
                return i[e] === t ? e : e + (t - i[e]) / (i[e + 1] - i[e]);
              }
              function C() {
                this.ordinal || (this.ordinal = new u.Additions(this));
              }
              function P() {
                this.isXAxis &&
                  S(this.options.overscroll) &&
                  this.max === this.dataMax &&
                  (!this.chart.mouseIsDown || this.isInternal) &&
                  (!this.eventArgs ||
                    (this.eventArgs &&
                      this.eventArgs.trigger !== "navigator")) &&
                  ((this.max += this.options.overscroll),
                  !this.isInternal &&
                    S(this.userMin) &&
                    (this.min += this.options.overscroll));
              }
              function j() {
                this.horiz &&
                  !this.isDirty &&
                  (this.isDirty =
                    this.isOrdinal &&
                    this.chart.navigator &&
                    !this.chart.navigator.adaptToUpdatedData);
              }
              function m() {
                this.ordinal &&
                  (this.ordinal.beforeSetTickPositions(),
                  (this.tickInterval = this.ordinal.postProcessTickInterval(
                    this.tickInterval
                  )));
              }
              function h(i) {
                const t = this.xAxis[0],
                  e = t.options.overscroll,
                  s = i.originalEvent.chartX,
                  a = this.options.chart.panning;
                let b = !1;
                if (
                  a &&
                  a.type !== "y" &&
                  t.options.ordinal &&
                  t.series.length
                ) {
                  var r = this.mouseDownX;
                  const V = t.getExtremes(),
                    B = V.dataMax,
                    x = V.min,
                    R = V.max;
                  var w = this.hoverPoints,
                    L =
                      t.closestPointRange ||
                      (t.ordinal && t.ordinal.overscrollPointsRange);
                  (r = Math.round(
                    (r - s) / (t.translationSlope * (t.ordinal.slope || L))
                  )),
                    (L = t.ordinal.getExtendedPositions());
                  var I = {
                    ordinal: { positions: L, extendedOrdinalPositions: L },
                  };
                  L = t.index2val;
                  const W = t.val2lin;
                  let X;
                  I.ordinal.positions
                    ? 1 < Math.abs(r) &&
                      (w &&
                        w.forEach(function (Z) {
                          Z.setState();
                        }),
                      0 > r
                        ? ((w = I), (X = t.ordinal.positions ? t : I))
                        : ((w = t.ordinal.positions ? t : I), (X = I)),
                      (I = X.ordinal.positions),
                      B > I[I.length - 1] && I.push(B),
                      (this.fixedRange = R - x),
                      (r = t.navigatorAxis.toFixedRange(
                        void 0,
                        void 0,
                        L.apply(w, [W.apply(w, [x, !0]) + r]),
                        L.apply(X, [W.apply(X, [R, !0]) + r])
                      )),
                      r.min >= Math.min(V.dataMin, x) &&
                        r.max <= Math.max(B, R) + e &&
                        t.setExtremes(r.min, r.max, !0, !1, { trigger: "pan" }),
                      (this.mouseDownX = s),
                      Y(this.container, { cursor: "move" }))
                    : (b = !0);
                } else b = !0;
                b || (a && /y/.test(a.type))
                  ? e && (t.max = t.dataMax + e)
                  : i.preventDefault();
              }
              function v() {
                const i = this.xAxis;
                i &&
                  i.options.ordinal &&
                  (delete i.ordinal.index,
                  delete i.ordinal.extendedOrdinalPositions);
              }
              function l(i, t) {
                const e = this.ordinal;
                var s = e.positions;
                let a = e.slope,
                  b = e.extendedOrdinalPositions;
                if (!s) return i;
                var r = s.length;
                if (s[0] <= i && s[r - 1] >= i) i = M(s, i);
                else {
                  if (
                    (b ||
                      ((b = e.getExtendedPositions && e.getExtendedPositions()),
                      (e.extendedOrdinalPositions = b)),
                    !b || !b.length)
                  )
                    return i;
                  (r = b.length),
                    a || (a = (b[r - 1] - b[0]) / r),
                    (s = M(b, s[0])),
                    (i =
                      i >= b[0] && i <= b[r - 1]
                        ? M(b, i) - s
                        : i < b[0]
                        ? -s - (b[0] - i) / a
                        : (i - b[r - 1]) / a + r - s);
                }
                return t ? i : a * (i || 0) + e.offset;
              }
              u.compose = function (i, t, e) {
                if (G.pushUnique(p, i)) {
                  const s = i.prototype;
                  (s.getTimeTicks = n),
                    (s.index2val = d),
                    (s.lin2val = g),
                    (s.val2lin = l),
                    (s.ordinal2lin = s.val2lin),
                    U(i, "afterInit", C),
                    U(i, "foundExtremes", P),
                    U(i, "afterSetScale", j),
                    U(i, "initialAxisTranslation", m);
                }
                return (
                  G.pushUnique(p, e) && U(e, "pan", h),
                  G.pushUnique(p, t) && U(t, "updatedData", v),
                  i
                );
              };
              class o {
                constructor(t) {
                  (this.index = {}), (this.axis = t);
                }
                beforeSetTickPositions() {
                  const t = this.axis,
                    e = t.ordinal;
                  var s = t.getExtremes();
                  const a = s.min;
                  var b = s.max;
                  const r = t.isXAxis && !!t.options.breaks;
                  s = t.options.ordinal;
                  const w = t.chart.options.chart.ignoreHiddenSeries;
                  let L, I;
                  var V;
                  let B = [],
                    x = Number.MAX_VALUE,
                    R = !1,
                    W = !1,
                    X = !1;
                  if (s || r) {
                    let E = 0;
                    if (
                      (t.series.forEach(function (_, z) {
                        if (
                          ((I = []),
                          0 < z &&
                            _.options.id !== "highcharts-navigator-series" &&
                            1 < _.processedXData.length &&
                            (W =
                              E !== _.processedXData[1] - _.processedXData[0]),
                          (E = _.processedXData[1] - _.processedXData[0]),
                          _.boosted && (X = _.boosted),
                          !(
                            (w && _.visible === !1) ||
                            (_.takeOrdinalPosition === !1 && !r)
                          ) &&
                            ((B = B.concat(_.processedXData)),
                            (L = B.length),
                            B.sort(function (J, tt) {
                              return J - tt;
                            }),
                            (x = Math.min(x, D(_.closestPointRange, x))),
                            L))
                        ) {
                          for (z = 0; z < L - 1; )
                            B[z] !== B[z + 1] && I.push(B[z + 1]), z++;
                          I[0] !== B[0] && I.unshift(B[0]), (B = I);
                        }
                      }),
                      W && X && (B.pop(), B.shift()),
                      (L = B.length),
                      2 < L)
                    ) {
                      var Z = B[1] - B[0];
                      for (V = L - 1; V-- && !R; )
                        B[V + 1] - B[V] !== Z && (R = !0);
                      !t.options.keepOrdinalPadding &&
                        (B[0] - a > Z || b - B[B.length - 1] > Z) &&
                        (R = !0);
                    } else
                      t.options.overscroll &&
                        (L === 2
                          ? (x = B[1] - B[0])
                          : L === 1
                          ? ((x = t.options.overscroll), (B = [B[0], B[0] + x]))
                          : (x = e.overscrollPointsRange));
                    R || t.forceOrdinal
                      ? (t.options.overscroll &&
                          ((e.overscrollPointsRange = x),
                          (B = B.concat(e.getOverscrollPositions()))),
                        (e.positions = B),
                        (Z = t.ordinal2lin(Math.max(a, B[0]), !0)),
                        (V = Math.max(
                          t.ordinal2lin(Math.min(b, B[B.length - 1]), !0),
                          1
                        )),
                        (e.slope = b = (b - a) / (V - Z)),
                        (e.offset = a - Z * b))
                      : ((e.overscrollPointsRange = D(
                          t.closestPointRange,
                          e.overscrollPointsRange
                        )),
                        (e.positions = t.ordinal.slope = e.offset = void 0));
                  }
                  (t.isOrdinal = s && R), (e.groupIntervalFactor = null);
                }
                static findIndexOf(t, e, s) {
                  let a = 0,
                    b = t.length - 1,
                    r;
                  for (; a < b; )
                    (r = Math.ceil((a + b) / 2)),
                      t[r] <= e ? (a = r) : (b = r - 1);
                  return t[a] === e || s ? a : -1;
                }
                getExtendedPositions() {
                  const t = this,
                    e = t.axis,
                    s = e.constructor.prototype,
                    a = e.chart,
                    b = e.series[0].currentDataGrouping,
                    r = b ? b.count + b.unitName : "raw",
                    w = e.options.overscroll,
                    L = e.getExtremes();
                  let I,
                    V,
                    B = t.index;
                  return (
                    B || (B = t.index = {}),
                    B[r] ||
                      ((I = {
                        series: [],
                        chart: a,
                        forceOrdinal: !1,
                        getExtremes: function () {
                          return { min: L.dataMin, max: L.dataMax + w };
                        },
                        getGroupPixelWidth: s.getGroupPixelWidth,
                        getTimeTicks: s.getTimeTicks,
                        options: { ordinal: !0 },
                        ordinal: {
                          getGroupIntervalFactor: this.getGroupIntervalFactor,
                        },
                        ordinal2lin: s.ordinal2lin,
                        getIndexOfPoint: s.getIndexOfPoint,
                        val2lin: s.val2lin,
                      }),
                      (I.ordinal.axis = I),
                      e.series.forEach(function (x) {
                        (V = {
                          xAxis: I,
                          xData: x.xData.slice(),
                          chart: a,
                          destroyGroupedData: O.noop,
                          getProcessedData: F.prototype.getProcessedData,
                          applyGrouping: F.prototype.applyGrouping,
                        }),
                          (V.xData = V.xData.concat(
                            t.getOverscrollPositions()
                          )),
                          (V.options = {
                            dataGrouping: b
                              ? {
                                  firstAnchor: "firstPoint",
                                  anchor: "middle",
                                  lastAnchor: "lastPoint",
                                  enabled: !0,
                                  forced: !0,
                                  approximation: "open",
                                  units: [[b.unitName, [b.count]]],
                                }
                              : { enabled: !1 },
                          }),
                          I.series.push(V),
                          x.processData.apply(V);
                      }),
                      V.closestPointRange !== V.basePointRange &&
                        V.currentDataGrouping &&
                        (I.forceOrdinal = !0),
                      e.ordinal.beforeSetTickPositions.apply({ axis: I }),
                      (B[r] = I.ordinal.positions)),
                    B[r]
                  );
                }
                getGroupIntervalFactor(t, e, s) {
                  s = s.processedXData;
                  const a = s.length;
                  var b = [],
                    r = this.groupIntervalFactor;
                  if (!r) {
                    for (r = 0; r < a - 1; r++) b[r] = s[r + 1] - s[r];
                    b.sort(function (w, L) {
                      return w - L;
                    }),
                      (b = b[Math.floor(a / 2)]),
                      (t = Math.max(t, s[0])),
                      (e = Math.min(e, s[a - 1])),
                      (this.groupIntervalFactor = r = (a * b) / (e - t));
                  }
                  return r;
                }
                getIndexOfPoint(t, e) {
                  const s = this.axis,
                    a = this.positions ? this.positions[0] : 0,
                    b = function (w) {
                      return w.points.some((L) => !!L.isInside);
                    };
                  let r;
                  return (
                    s.series.forEach((w) => {
                      var L;
                      const I =
                        (L = w.points) === null || L === void 0 ? void 0 : L[0];
                      S(I == null ? void 0 : I.plotX) &&
                        (I.plotX < r || !S(r)) &&
                        b(w) &&
                        (r = I.plotX);
                    }),
                    r ?? (r = s.minPixelPadding),
                    (t = H(
                      (t - r) /
                        (s.translationSlope *
                          (this.slope ||
                            s.closestPointRange ||
                            this.overscrollPointsRange))
                    )),
                    o.findIndexOf(e, a, !0) + t
                  );
                }
                getOverscrollPositions() {
                  const t = this.axis,
                    e = t.options.overscroll,
                    s = this.overscrollPointsRange,
                    a = [];
                  let b = t.dataMax;
                  if (S(s)) for (; b <= t.dataMax + e; ) (b += s), a.push(b);
                  return a;
                }
                postProcessTickInterval(t) {
                  const e = this.axis,
                    s = this.slope;
                  return s
                    ? e.options.breaks
                      ? e.closestPointRange || t
                      : t / (s / e.closestPointRange)
                    : t;
                }
              }
              u.Additions = o;
            })(f || (f = {})),
            f
          );
        }
      ),
      T(
        y,
        "Series/HLC/HLCPoint.js",
        [y["Core/Series/SeriesRegistry.js"]],
        function (A) {
          ({
            column: {
              prototype: { pointClass: A },
            },
          } = A.seriesTypes);
          class O extends A {
            constructor() {
              super(...arguments),
                (this.series =
                  this.plotClose =
                  this.options =
                  this.low =
                  this.high =
                  this.close =
                    void 0);
            }
          }
          return O;
        }
      ),
      T(y, "Series/HLC/HLCSeriesDefaults.js", [], function () {
        return {
          lineWidth: 1,
          tooltip: {
            pointFormat:
              '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>',
          },
          threshold: null,
          states: { hover: { lineWidth: 3 } },
          stickyTracking: !0,
        };
      }),
      T(
        y,
        "Series/HLC/HLCSeries.js",
        [
          y["Series/HLC/HLCPoint.js"],
          y["Series/HLC/HLCSeriesDefaults.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          const { column: U } = F.seriesTypes,
            { extend: H, merge: Y } = G;
          class S extends U {
            constructor() {
              super(...arguments),
                (this.yData = this.points = this.options = this.data = void 0);
            }
            extendStem(D, c, p) {
              const f = D[0];
              (D = D[1]),
                typeof f[2] == "number" && (f[2] = Math.max(p + c, f[2])),
                typeof D[2] == "number" && (D[2] = Math.min(p - c, D[2]));
            }
            getPointPath(D, c) {
              c = c.strokeWidth();
              const p = D.series,
                f = (c % 2) / 2,
                u = Math.round(D.plotX) - f,
                n = Math.round(D.shapeArgs.width / 2),
                d = [
                  ["M", u, Math.round(D.yBottom)],
                  ["L", u, Math.round(D.plotHigh)],
                ];
              return (
                D.close !== null &&
                  ((D = Math.round(D.plotClose) + f),
                  d.push(["M", u, D], ["L", u + n, D]),
                  p.extendStem(d, c / 2, D)),
                d
              );
            }
            drawSinglePoint(D) {
              var c = D.series;
              const p = c.chart;
              let f = D.graphic;
              typeof D.plotY < "u" &&
                (f || (D.graphic = f = p.renderer.path().add(c.group)),
                p.styledMode ||
                  f.attr(c.pointAttribs(D, D.selected && "select")),
                (c = c.getPointPath(D, f)),
                f[f ? "animate" : "attr"]({ d: c }).addClass(
                  D.getClassName(),
                  !0
                ));
            }
            drawPoints() {
              this.points.forEach(this.drawSinglePoint);
            }
            init() {
              super.init.apply(this, arguments),
                (this.options.stacking = void 0);
            }
            pointAttribs(D, c) {
              return (
                (D = super.pointAttribs.call(this, D, c)), delete D.fill, D
              );
            }
            toYData(D) {
              return [D.high, D.low, D.close];
            }
            translate() {
              const D = this,
                c = D.yAxis,
                p = (this.pointArrayMap && this.pointArrayMap.slice()) || [],
                f = p.map(
                  (u) => `plot${u.charAt(0).toUpperCase() + u.slice(1)}`
                );
              f.push("yBottom"),
                p.push("low"),
                super.translate.apply(D),
                D.points.forEach(function (u) {
                  p.forEach(function (n, d) {
                    (n = u[n]),
                      n !== null &&
                        (D.dataModify && (n = D.dataModify.modifyValue(n)),
                        (u[f[d]] = c.toPixels(n, !0)));
                  }),
                    (u.tooltipPos[1] = u.plotHigh + c.pos - D.chart.plotTop);
                });
            }
          }
          return (
            (S.defaultOptions = Y(U.defaultOptions, O)),
            H(S.prototype, {
              pointClass: A,
              animate: null,
              directTouch: !1,
              pointArrayMap: ["high", "low", "close"],
              pointAttrToOptions: {
                stroke: "color",
                "stroke-width": "lineWidth",
              },
              pointValKey: "close",
            }),
            F.registerSeriesType("hlc", S),
            S
          );
        }
      ),
      T(
        y,
        "Series/OHLC/OHLCPoint.js",
        [y["Core/Series/SeriesRegistry.js"]],
        function (A) {
          ({
            seriesTypes: { hlc: A },
          } = A);
          class O extends A.prototype.pointClass {
            constructor() {
              super(...arguments),
                (this.series =
                  this.plotOpen =
                  this.options =
                  this.open =
                    void 0);
            }
            getClassName() {
              return (
                super.getClassName.call(this) +
                (this.open < this.close
                  ? " highcharts-point-up"
                  : " highcharts-point-down")
              );
            }
            resolveUpColor() {
              this.open < this.close &&
                !this.options.color &&
                this.series.options.upColor &&
                (this.color = this.series.options.upColor);
            }
            resolveColor() {
              super.resolveColor(), this.resolveUpColor();
            }
            getZone() {
              const G = super.getZone();
              return this.resolveUpColor(), G;
            }
            applyOptions() {
              return (
                super.applyOptions.apply(this, arguments),
                this.resolveColor && this.resolveColor(),
                this
              );
            }
          }
          return O;
        }
      ),
      T(y, "Series/OHLC/OHLCSeriesDefaults.js", [], function () {
        return {
          tooltip: {
            pointFormat:
              '<span style="color:{point.color}">●</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>',
          },
        };
      }),
      T(
        y,
        "Series/OHLC/OHLCSeries.js",
        [
          y["Series/OHLC/OHLCPoint.js"],
          y["Series/OHLC/OHLCSeriesDefaults.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          function U(f) {
            f = f.options;
            const u = f.dataGrouping;
            u &&
              f.useOhlcData &&
              f.id !== "highcharts-navigator-series" &&
              (u.approximation = "ohlc");
          }
          function H(f) {
            (f = f.options),
              f.useOhlcData &&
                f.id !== "highcharts-navigator-series" &&
                N(this, {
                  pointValKey: p.prototype.pointValKey,
                  pointArrayMap: p.prototype.pointArrayMap,
                  toYData: p.prototype.toYData,
                });
          }
          const {
              seriesTypes: { hlc: Y },
            } = F,
            { addEvent: S, extend: N, merge: D } = G,
            c = [];
          class p extends Y {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            static compose(u, ...n) {
              G.pushUnique(c, u) &&
                (S(u, "afterSetOptions", U), S(u, "init", H));
            }
            getPointPath(u, n) {
              const d = super.getPointPath(u, n);
              n = n.strokeWidth();
              const g = (n % 2) / 2,
                M = Math.round(u.plotX) - g,
                C = Math.round(u.shapeArgs.width / 2);
              return (
                u.open !== null &&
                  ((u = Math.round(u.plotOpen) + g),
                  d.push(["M", M, u], ["L", M - C, u]),
                  super.extendStem(d, n / 2, u)),
                d
              );
            }
            pointAttribs(u, n) {
              n = super.pointAttribs.call(this, u, n);
              const d = this.options;
              return (
                delete n.fill,
                !u.options.color &&
                  d.upColor &&
                  u.open < u.close &&
                  (n.stroke = d.upColor),
                n
              );
            }
            toYData(u) {
              return [u.open, u.high, u.low, u.close];
            }
          }
          return (
            (p.defaultOptions = D(Y.defaultOptions, O)),
            N(p.prototype, {
              pointClass: A,
              pointArrayMap: ["open", "high", "low", "close"],
            }),
            F.registerSeriesType("ohlc", p),
            p
          );
        }
      ),
      T(
        y,
        "Series/Candlestick/CandlestickSeriesDefaults.js",
        [y["Core/Defaults.js"], y["Core/Utilities.js"]],
        function (A, O) {
          return {
            states: { hover: { lineWidth: 2 } },
            threshold: null,
            lineColor: "#000000",
            lineWidth: 1,
            upColor: "#ffffff",
            stickyTracking: !0,
          };
        }
      ),
      T(
        y,
        "Series/Candlestick/CandlestickSeries.js",
        [
          y["Series/Candlestick/CandlestickSeriesDefaults.js"],
          y["Core/Defaults.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G) {
          ({ defaultOptions: O } = O);
          const { column: U, ohlc: H } = F.seriesTypes;
          ({ merge: G } = G);
          class Y extends H {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            pointAttribs(N, D) {
              const c = U.prototype.pointAttribs.call(this, N, D),
                p = this.options,
                f = N.open < N.close,
                u = p.lineColor || this.color,
                n = N.color || this.color;
              return (
                (c["stroke-width"] = p.lineWidth),
                (c.fill = N.options.color || (f && p.upColor) || n),
                (c.stroke = N.options.lineColor || (f && p.upLineColor) || u),
                D &&
                  ((N = p.states[D]),
                  (c.fill = N.color || c.fill),
                  (c.stroke = N.lineColor || c.stroke),
                  (c["stroke-width"] = N.lineWidth || c["stroke-width"])),
                c
              );
            }
            drawPoints() {
              var N = this.points;
              const D = this.chart,
                c = this.yAxis.reversed;
              for (const n of N) {
                N = n.graphic;
                var p = void 0,
                  f = void 0;
                let d, g;
                var u = void 0;
                let M, C;
                const P = !N;
                typeof n.plotY < "u" &&
                  (N || (n.graphic = N = D.renderer.path().add(this.group)),
                  this.chart.styledMode ||
                    N.attr(this.pointAttribs(n, n.selected && "select")).shadow(
                      this.options.shadow
                    ),
                  (u = (N.strokeWidth() % 2) / 2),
                  (M = Math.round(n.plotX) - u),
                  (p = n.plotOpen),
                  (f = n.plotClose),
                  (d = Math.min(p, f)),
                  (p = Math.max(p, f)),
                  (C = Math.round(n.shapeArgs.width / 2)),
                  (f = c
                    ? p !== n.yBottom
                    : Math.round(d) !== Math.round(n.plotHigh)),
                  (g = c
                    ? Math.round(d) !== Math.round(n.plotHigh)
                    : p !== n.yBottom),
                  (d = Math.round(d) + u),
                  (p = Math.round(p) + u),
                  (u = []),
                  u.push(
                    ["M", M - C, p],
                    ["L", M - C, d],
                    ["L", M + C, d],
                    ["L", M + C, p],
                    ["Z"],
                    ["M", M, d],
                    ["L", M, f ? Math.round(c ? n.yBottom : n.plotHigh) : d],
                    ["M", M, p],
                    ["L", M, g ? Math.round(c ? n.plotHigh : n.yBottom) : p]
                  ),
                  N[P ? "attr" : "animate"]({ d: u }).addClass(
                    n.getClassName(),
                    !0
                  ));
              }
            }
          }
          return (
            (Y.defaultOptions = G(
              H.defaultOptions,
              O.plotOptions,
              { tooltip: H.defaultOptions.tooltip },
              A
            )),
            F.registerSeriesType("candlestick", Y),
            Y
          );
        }
      ),
      T(
        y,
        "Series/Flags/FlagsPoint.js",
        [y["Core/Series/SeriesRegistry.js"], y["Core/Utilities.js"]],
        function (A, O) {
          ({
            column: {
              prototype: { pointClass: A },
            },
          } = A.seriesTypes);
          const { isNumber: F } = O;
          class G extends A {
            constructor() {
              super(...arguments),
                (this.series = this.options = void 0),
                (this.ttBelow = !1);
            }
            isValid() {
              return F(this.y) || typeof this.y > "u";
            }
            hasNewShapeType() {
              const H = this.options.shape || this.series.options.shape;
              return this.graphic && H && H !== this.graphic.symbolKey;
            }
          }
          return G;
        }
      ),
      T(y, "Series/Flags/FlagsSeriesDefaults.js", [], function () {
        return {
          pointRange: 0,
          allowOverlapX: !1,
          shape: "flag",
          stackDistance: 12,
          textAlign: "center",
          tooltip: { pointFormat: "{point.text}" },
          threshold: null,
          y: -30,
          fillColor: "#ffffff",
          lineWidth: 1,
          states: { hover: { lineColor: "#000000", fillColor: "#ccd3ff" } },
          style: { fontSize: "0.7em", fontWeight: "bold" },
        };
      }),
      T(
        y,
        "Series/Flags/FlagsSymbols.js",
        [y["Core/Renderer/RendererRegistry.js"]],
        function (A) {
          var O;
          return (
            (function (F) {
              function G(Y, S, N, D, c) {
                const p = (c && c.anchorX) || Y;
                c = (c && c.anchorY) || S;
                const f = this.circle(p - 1, c - 1, 2, 2);
                return (
                  f.push(
                    ["M", p, c],
                    ["L", Y, S + D],
                    ["L", Y, S],
                    ["L", Y + N, S],
                    ["L", Y + N, S + D],
                    ["L", Y, S + D],
                    ["Z"]
                  ),
                  f
                );
              }
              function U(Y, S) {
                Y[S + "pin"] = function (N, D, c, p, f) {
                  const u = f && f.anchorX;
                  f = f && f.anchorY;
                  let n;
                  if (
                    (S === "circle" &&
                      p > c &&
                      ((N -= Math.round((p - c) / 2)), (c = p)),
                    (n = Y[S](N, D, c, p)),
                    u && f)
                  ) {
                    let d = u;
                    S === "circle"
                      ? (d = N + c / 2)
                      : ((N = n[0]),
                        (c = n[1]),
                        N[0] === "M" &&
                          c[0] === "L" &&
                          (d = (N[1] + c[1]) / 2)),
                      n.push(["M", d, D > f ? D : D + p], ["L", u, f]),
                      (n = n.concat(Y.circle(u - 1, f - 1, 2, 2)));
                  }
                  return n;
                };
              }
              const H = [];
              F.compose = function (Y) {
                H.indexOf(Y) === -1 &&
                  (H.push(Y),
                  (Y = Y.prototype.symbols),
                  (Y.flag = G),
                  U(Y, "circle"),
                  U(Y, "square")),
                  (Y = A.getRendererType()),
                  H.indexOf(Y) && H.push(Y);
              };
            })(O || (O = {})),
            O
          );
        }
      ),
      T(
        y,
        "Series/OnSeriesComposition.js",
        [
          y["Series/Column/ColumnSeries.js"],
          y["Core/Series/Series.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F) {
          const { prototype: G } = A,
            { prototype: U } = O,
            { defined: H, stableSort: Y } = F;
          var S;
          return (
            (function (N) {
              function D(f) {
                return U.getPlotBox.call(
                  (this.options.onSeries &&
                    this.chart.get(this.options.onSeries)) ||
                    this,
                  f
                );
              }
              function c() {
                G.translate.apply(this);
                const f = this;
                var u = f.options,
                  n = f.chart;
                const d = f.points;
                var g = u.onSeries;
                const M = (g = g && n.get(g)) && g.options.step,
                  C = g && g.points,
                  P = n.inverted,
                  j = f.xAxis,
                  m = f.yAxis;
                n = d.length - 1;
                let h;
                u = u.onKey || "y";
                let v = C && C.length,
                  l = 0,
                  o,
                  i,
                  t,
                  e;
                if (g && g.visible && v) {
                  l = (g.pointXOffset || 0) + (g.barW || 0) / 2;
                  var s = g.currentDataGrouping;
                  for (
                    i = C[v - 1].x + (s ? s.totalRange : 0),
                      Y(d, (a, b) => a.x - b.x),
                      u = "plot" + u[0].toUpperCase() + u.substr(1);
                    v-- &&
                    d[n] &&
                    ((o = C[v]),
                    (s = d[n]),
                    (s.y = o.y),
                    !(
                      o.x <= s.x &&
                      typeof o[u] < "u" &&
                      (s.x <= i &&
                        ((s.plotY = o[u]),
                        o.x < s.x &&
                          !M &&
                          (t = C[v + 1]) &&
                          typeof t[u] < "u" &&
                          ((e = (s.x - o.x) / (t.x - o.x)),
                          (s.plotY += e * (t[u] - o[u])),
                          (s.y += e * (t.y - o.y)))),
                      n--,
                      v++,
                      0 > n)
                    ));

                  );
                }
                d.forEach((a, b) => {
                  let r;
                  (a.plotX += l),
                    (typeof a.plotY > "u" || P) &&
                      (0 <= a.plotX && a.plotX <= j.len
                        ? P
                          ? ((a.plotY = j.translate(a.x, 0, 1, 0, 1)),
                            (a.plotX = H(a.y)
                              ? m.translate(a.y, 0, 0, 0, 1)
                              : 0))
                          : (a.plotY =
                              (j.opposite ? 0 : f.yAxis.len) + j.offset)
                        : (a.shapeArgs = {})),
                    (h = d[b - 1]) &&
                      h.plotX === a.plotX &&
                      (typeof h.stackIndex > "u" && (h.stackIndex = 0),
                      (r = h.stackIndex + 1)),
                    (a.stackIndex = r);
                }),
                  (this.onSeries = g);
              }
              const p = [];
              (N.compose = function (f) {
                if (F.pushUnique(p, f)) {
                  const u = f.prototype;
                  (u.getPlotBox = D), (u.translate = c);
                }
                return f;
              }),
                (N.getPlotBox = D),
                (N.translate = c);
            })(S || (S = {})),
            S
          );
        }
      ),
      T(
        y,
        "Series/Flags/FlagsSeries.js",
        [
          y["Series/Flags/FlagsPoint.js"],
          y["Series/Flags/FlagsSeriesDefaults.js"],
          y["Series/Flags/FlagsSymbols.js"],
          y["Core/Globals.js"],
          y["Series/OnSeriesComposition.js"],
          y["Core/Renderer/RendererUtilities.js"],
          y["Core/Series/SeriesRegistry.js"],
          y["Core/Renderer/SVG/SVGElement.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y, S, N) {
          ({ noop: G } = G);
          const { distribute: D } = H,
            {
              series: c,
              seriesTypes: { column: p },
            } = Y,
            {
              addEvent: f,
              defined: u,
              extend: n,
              merge: d,
              objectEach: g,
              wrap: M,
            } = N;
          class C extends p {
            constructor() {
              super(...arguments),
                (this.points = this.options = this.data = void 0);
            }
            animate(j) {
              j && this.setClip();
            }
            drawPoints() {
              var j = this.points,
                m = this.chart;
              const h = m.renderer,
                v = m.inverted,
                l = this.options,
                o = l.y,
                i = this.yAxis,
                t = {},
                e = [];
              let s, a, b, r, w, L, I;
              for (b = j.length; b--; ) {
                (r = j[b]),
                  (L = (v ? r.plotY : r.plotX) > this.xAxis.len),
                  (s = r.plotX);
                var V = r.stackIndex,
                  B = r.options.shape || l.shape;
                (a = r.plotY),
                  typeof a < "u" &&
                    (a = r.plotY + o - (typeof V < "u" && V * l.stackDistance)),
                  (r.anchorX = V ? void 0 : r.plotX),
                  (w = V ? void 0 : r.plotY),
                  (I = B !== "flag"),
                  (V = r.graphic),
                  typeof a < "u" && 0 <= s && !L
                    ? (V && r.hasNewShapeType() && (V = V.destroy()),
                      V ||
                        ((V = r.graphic =
                          h
                            .label("", null, null, B, null, null, l.useHTML)
                            .addClass("highcharts-point")
                            .add(this.markerGroup)),
                        r.graphic.div && (r.graphic.div.point = r),
                        (V.isNew = !0)),
                      V.attr({
                        align: I ? "center" : "left",
                        width: l.width,
                        height: l.height,
                        "text-align": l.textAlign,
                      }),
                      m.styledMode ||
                        V.attr(this.pointAttribs(r))
                          .css(d(l.style, r.style))
                          .shadow(l.shadow),
                      0 < s && (s -= V.strokeWidth() % 2),
                      (B = { y: a, anchorY: w }),
                      l.allowOverlapX && ((B.x = s), (B.anchorX = r.anchorX)),
                      V.attr({ text: r.options.title || l.title || "A" })[
                        V.isNew ? "attr" : "animate"
                      ](B),
                      l.allowOverlapX ||
                        (t[r.plotX]
                          ? (t[r.plotX].size = Math.max(
                              t[r.plotX].size,
                              V.width
                            ))
                          : (t[r.plotX] = {
                              align: I ? 0.5 : 0,
                              size: V.width,
                              target: s,
                              anchorX: s,
                            })),
                      (r.tooltipPos = [s, a + i.pos - m.plotTop]))
                    : V && (r.graphic = V.destroy());
              }
              if (!l.allowOverlapX) {
                let x = 100;
                g(t, function (R) {
                  (R.plotX = R.anchorX), e.push(R), (x = Math.max(R.size, x));
                }),
                  D(e, v ? i.len : this.xAxis.len, x);
                for (const R of j)
                  (m = R.plotX),
                    (m = (j = R.graphic) && t[m]) &&
                      j &&
                      (u(m.pos)
                        ? (j[j.isNew ? "attr" : "animate"]({
                            x: m.pos + (m.align || 0) * m.size,
                            anchorX: R.anchorX,
                          }).show().isNew = !1)
                        : (j.hide().isNew = !0));
              }
              l.useHTML &&
                this.markerGroup &&
                M(this.markerGroup, "on", function (x) {
                  return S.prototype.on.apply(
                    x.apply(this, [].slice.call(arguments, 1)),
                    [].slice.call(arguments, 1)
                  );
                });
            }
            drawTracker() {
              const j = this.points;
              super.drawTracker();
              for (const m of j) {
                const h = m.graphic;
                h &&
                  (m.unbindMouseOver && m.unbindMouseOver(),
                  (m.unbindMouseOver = f(h.element, "mouseover", function () {
                    0 < m.stackIndex &&
                      !m.raised &&
                      ((m._y = h.y), h.attr({ y: m._y - 8 }), (m.raised = !0));
                    for (const v of j)
                      v !== m &&
                        v.raised &&
                        v.graphic &&
                        (v.graphic.attr({ y: v._y }), (v.raised = !1));
                  })));
              }
            }
            pointAttribs(j, m) {
              const h = this.options,
                v = (j && j.color) || this.color;
              let l = h.lineColor,
                o = j && j.lineWidth;
              return (
                (j = (j && j.fillColor) || h.fillColor),
                m &&
                  ((j = h.states[m].fillColor),
                  (l = h.states[m].lineColor),
                  (o = h.states[m].lineWidth)),
                {
                  fill: j || v,
                  stroke: l || v,
                  "stroke-width": o || h.lineWidth || 0,
                }
              );
            }
            setClip() {
              c.prototype.setClip.apply(this, arguments),
                this.options.clip !== !1 &&
                  this.sharedClipKey &&
                  this.markerGroup &&
                  this.markerGroup.clip(
                    this.chart.sharedClips[this.sharedClipKey]
                  );
            }
          }
          return (
            (C.compose = F.compose),
            (C.defaultOptions = d(p.defaultOptions, O)),
            U.compose(C),
            n(C.prototype, {
              allowDG: !1,
              forceCrop: !0,
              invertible: !1,
              noSharedTooltip: !0,
              pointClass: A,
              sorted: !1,
              takeOrdinalPosition: !1,
              trackerGroups: ["markerGroup"],
              buildKDTree: G,
              init: c.prototype.init,
            }),
            Y.registerSeriesType("flags", C),
            C
          );
        }
      ),
      T(
        y,
        "Core/Chart/StockChart.js",
        [
          y["Core/Axis/Axis.js"],
          y["Core/Chart/Chart.js"],
          y["Core/Templating.js"],
          y["Core/Defaults.js"],
          y["Stock/Navigator/NavigatorDefaults.js"],
          y["Stock/RangeSelector/RangeSelectorDefaults.js"],
          y["Stock/Scrollbar/ScrollbarDefaults.js"],
          y["Core/Series/Series.js"],
          y["Core/Renderer/SVG/SVGRenderer.js"],
          y["Core/Utilities.js"],
        ],
        function (A, O, F, G, U, H, Y, S, N, D) {
          function c(o, i) {
            return o === "xAxis"
              ? {
                  minPadding: 0,
                  maxPadding: 0,
                  overscroll: 0,
                  ordinal: !0,
                  title: { text: null },
                  labels: { overflow: "justify" },
                  showLastLabel: !0,
                }
              : o === "yAxis"
              ? {
                  labels: { y: -2 },
                  opposite: h(i.opposite, !0),
                  showLastLabel: !(!i.categories && i.type !== "category"),
                  title: { text: null },
                }
              : {};
          }
          function p(o, i) {
            return o === "xAxis"
              ? ((o = { type: "datetime", categories: void 0 }),
                h(i.navigator && i.navigator.enabled, U.enabled, !0) &&
                  ((o.startOnTick = !1), (o.endOnTick = !1)),
                o)
              : {};
          }
          const { format: f } = F,
            { getOptions: u } = G,
            {
              addEvent: n,
              clamp: d,
              defined: g,
              extend: M,
              find: C,
              isNumber: P,
              isString: j,
              merge: m,
              pick: h,
              splat: v,
            } = D;
          class l extends O {
            init(i, t) {
              const e = u(),
                s = i.xAxis,
                a = i.yAxis;
              var b = h(i.navigator && i.navigator.enabled, U.enabled, !0);
              (i.xAxis = i.yAxis = void 0),
                (b = m(
                  {
                    chart: {
                      panning: { enabled: !0, type: "x" },
                      zooming: { pinchType: "x" },
                    },
                    navigator: { enabled: b },
                    scrollbar: { enabled: h(Y.enabled, !0) },
                    rangeSelector: { enabled: h(H.rangeSelector.enabled, !0) },
                    title: { text: null },
                    tooltip: { split: h(e.tooltip.split, !0), crosshairs: !0 },
                    legend: { enabled: !1 },
                  },
                  i,
                  { isStock: !0 }
                )),
                (i.xAxis = s),
                (i.yAxis = a),
                (b.xAxis = v(i.xAxis || {}).map(function (r, w) {
                  return m(
                    c("xAxis", r),
                    e.xAxis,
                    e.xAxis && e.xAxis[w],
                    r,
                    p("xAxis", i)
                  );
                })),
                (b.yAxis = v(i.yAxis || {}).map(function (r, w) {
                  return m(c("yAxis", r), e.yAxis, e.yAxis && e.yAxis[w], r);
                })),
                super.init(b, t);
            }
            createAxis(i, t) {
              return (
                (t.axis = m(c(i, t.axis), t.axis, p(i, this.userOptions))),
                super.createAxis(i, t)
              );
            }
          }
          return (
            (function (o) {
              o.stockChart = function (i, t, e) {
                return new o(i, t, e);
              };
            })(l || (l = {})),
            n(S, "setOptions", function (o) {
              let i;
              this.chart.options.isStock &&
                (this.is("column") || this.is("columnrange")
                  ? (i = { borderWidth: 0, shadow: !1 })
                  : this.is("scatter") ||
                    this.is("sma") ||
                    (i = { marker: { enabled: !1, radius: 2 } }),
                i &&
                  (o.plotOptions[this.type] = m(o.plotOptions[this.type], i)));
            }),
            n(A, "autoLabelAlign", function (o) {
              const { chart: i, options: t } = this,
                e = (i._labelPanes = i._labelPanes || {}),
                s = t.labels;
              if (i.options.isStock && this.coll === "yAxis") {
                const a = t.top + "," + t.height;
                !e[a] &&
                  s.enabled &&
                  (s.distance === 15 && this.side === 1 && (s.distance = 0),
                  typeof s.align > "u" && (s.align = "right"),
                  (e[a] = this),
                  (o.align = "right"),
                  o.preventDefault());
              }
            }),
            n(A, "destroy", function () {
              const o = this.chart,
                i =
                  this.options && this.options.top + "," + this.options.height;
              i &&
                o._labelPanes &&
                o._labelPanes[i] === this &&
                delete o._labelPanes[i];
            }),
            n(A, "getPlotLinePath", function (o) {
              function i(z) {
                const J = z === "xAxis" ? "yAxis" : "xAxis";
                return (
                  (z = t.options[J]),
                  P(z)
                    ? [s[J][z]]
                    : j(z)
                    ? [s.get(z)]
                    : e.map(function (tt) {
                        return tt[J];
                      })
                );
              }
              let t = this,
                e =
                  this.isLinked && !this.series
                    ? this.linkedParent.series
                    : this.series,
                s = t.chart,
                a = s.renderer,
                b = t.left,
                r = t.top,
                w,
                L,
                I,
                V,
                B = [],
                x = [],
                R,
                W,
                X = o.translatedValue,
                Z = o.value,
                E = o.force,
                _;
              ((s.options.isStock &&
                o.acrossPanes !== !1 &&
                t.coll === "xAxis") ||
                t.coll === "yAxis") &&
                (o.preventDefault(),
                (x = i(t.coll)),
                (R = t.isXAxis ? s.yAxis : s.xAxis),
                R.forEach(function (z) {
                  if (
                    !g(z.options.id) ||
                    z.options.id.indexOf("navigator") === -1
                  ) {
                    var J = z.isXAxis ? "yAxis" : "xAxis";
                    (J = g(z.options[J]) ? s[J][z.options[J]] : s[J][0]),
                      t === J && x.push(z);
                  }
                }),
                (W = x.length ? [] : [t.isXAxis ? s.yAxis[0] : s.xAxis[0]]),
                x.forEach(function (z) {
                  W.indexOf(z) !== -1 ||
                    C(W, function (J) {
                      return J.pos === z.pos && J.len === z.len;
                    }) ||
                    W.push(z);
                }),
                (_ = h(X, t.translate(Z, void 0, void 0, o.old))),
                P(_) &&
                  (t.horiz
                    ? W.forEach(function (z) {
                        let J;
                        (L = z.pos),
                          (V = L + z.len),
                          (w = I = Math.round(_ + t.transB)),
                          E !== "pass" &&
                            (w < b || w > b + t.width) &&
                            (E ? (w = I = d(w, b, b + t.width)) : (J = !0)),
                          J || B.push(["M", w, L], ["L", I, V]);
                      })
                    : W.forEach(function (z) {
                        let J;
                        (w = z.pos),
                          (I = w + z.len),
                          (L = V = Math.round(r + t.height - _)),
                          E !== "pass" &&
                            (L < r || L > r + t.height) &&
                            (E ? (L = V = d(L, r, r + t.height)) : (J = !0)),
                          J || B.push(["M", w, L], ["L", I, V]);
                      })),
                (o.path =
                  0 < B.length ? a.crispPolyLine(B, o.lineWidth || 1) : null));
            }),
            (N.prototype.crispPolyLine = function (o, i) {
              for (let t = 0; t < o.length; t += 2) {
                const e = o[t],
                  s = o[t + 1];
                e[1] === s[1] && (e[1] = s[1] = Math.round(e[1]) - (i % 2) / 2),
                  e[2] === s[2] &&
                    (e[2] = s[2] = Math.round(e[2]) + (i % 2) / 2);
              }
              return o;
            }),
            n(A, "afterHideCrosshair", function () {
              this.crossLabel && (this.crossLabel = this.crossLabel.hide());
            }),
            n(A, "afterDrawCrosshair", function (o) {
              var i, t;
              if (
                this.crosshair &&
                this.crosshair.label &&
                this.crosshair.label.enabled &&
                this.cross &&
                P(this.min) &&
                P(this.max)
              ) {
                var e = this.chart,
                  s = this.logarithmic,
                  a = this.crosshair.label,
                  b = this.horiz,
                  r = this.opposite,
                  w = this.left,
                  L = this.top,
                  I = this.width,
                  V = this.crossLabel,
                  B = a.format,
                  x = "",
                  R = this.options.tickPosition === "inside",
                  W = this.crosshair.snap !== !1,
                  X = 0,
                  Z = o.e || (this.cross && this.cross.e);
                o = o.point;
                var E = this.min,
                  _ = this.max;
                s && ((E = s.lin2log(E)), (_ = s.lin2log(_))),
                  (s = b
                    ? "center"
                    : r
                    ? this.labelAlign === "right"
                      ? "right"
                      : "left"
                    : this.labelAlign === "left"
                    ? "left"
                    : "center"),
                  V ||
                    ((V = this.crossLabel =
                      e.renderer
                        .label("", 0, void 0, a.shape || "callout")
                        .addClass(
                          "highcharts-crosshair-label highcharts-color-" +
                            (o && o.series
                              ? o.series.colorIndex
                              : this.series[0] && this.series[0].colorIndex)
                        )
                        .attr({
                          align: a.align || s,
                          padding: h(a.padding, 8),
                          r: h(a.borderRadius, 3),
                          zIndex: 2,
                        })
                        .add(this.labelGroup)),
                    e.styledMode ||
                      V.attr({
                        fill:
                          a.backgroundColor ||
                          (o && o.series && o.series.color) ||
                          "#666666",
                        stroke: a.borderColor || "",
                        "stroke-width": a.borderWidth || 0,
                      }).css(
                        M(
                          {
                            color: "#ffffff",
                            fontWeight: "normal",
                            fontSize: "0.7em",
                            textAlign: "center",
                          },
                          a.style || {}
                        )
                      )),
                  b
                    ? ((I = W ? (o.plotX || 0) + w : Z.chartX),
                      (L += r ? 0 : this.height))
                    : ((I = w + this.offset + (r ? I : 0)),
                      (L = W ? (o.plotY || 0) + L : Z.chartY)),
                  B ||
                    a.formatter ||
                    (this.dateTime && (x = "%b %d, %Y"),
                    (B = "{value" + (x ? ":" + x : "") + "}")),
                  (x = W
                    ? this.isXAxis
                      ? o.x
                      : o.y
                    : this.toValue(b ? Z.chartX : Z.chartY)),
                  (W =
                    o && o.series
                      ? o.series.isPointInside(o)
                      : P(x) && x > E && x < _),
                  (Z = ""),
                  B
                    ? (Z = f(B, { value: x }, e))
                    : a.formatter && P(x) && (Z = a.formatter.call(this, x)),
                  V.attr({
                    text: Z,
                    x: I,
                    y: L,
                    visibility: W ? "inherit" : "hidden",
                  }),
                  (a = V.getBBox()),
                  !P(V.x) || b || r || (I = V.x - a.width / 2),
                  P(V.y) &&
                    (b
                      ? ((R && !r) || (!R && r)) && (L = V.y - a.height)
                      : (L = V.y - a.height / 2)),
                  b
                    ? ((i = w - a.x), (t = w + this.width - a.x))
                    : ((i = this.labelAlign === "left" ? w : 0),
                      (t =
                        this.labelAlign === "right"
                          ? w + this.width
                          : e.chartWidth)),
                  V.translateX < i && (X = i - V.translateX),
                  V.translateX + a.width >= t &&
                    (X = -(V.translateX + a.width - t)),
                  V.attr({
                    x: I + X,
                    y: L,
                    anchorX: b ? I : this.opposite ? 0 : e.chartWidth,
                    anchorY: b
                      ? this.opposite
                        ? e.chartHeight
                        : 0
                      : L + a.height / 2,
                  });
              }
            }),
            (S.prototype.forceCropping = function () {
              const o = this.chart,
                i = this.options.dataGrouping;
              return (
                this.allowDG !== !1 && i && h(i.enabled, o.options.isStock)
              );
            }),
            n(O, "update", function (o) {
              (o = o.options),
                "scrollbar" in o &&
                  this.navigator &&
                  (m(!0, this.options.scrollbar, o.scrollbar),
                  this.navigator.update({}),
                  delete o.scrollbar);
            }),
            l
          );
        }
      ),
      T(
        y,
        "masters/modules/stock.src.js",
        [
          y["Core/Globals.js"],
          y["Series/DataModifyComposition.js"],
          y["Stock/Navigator/Navigator.js"],
          y["Stock/RangeSelector/RangeSelector.js"],
          y["Stock/Scrollbar/Scrollbar.js"],
          y["Core/Axis/OrdinalAxis.js"],
          y["Series/OHLC/OHLCSeries.js"],
          y["Series/Flags/FlagsSeries.js"],
          y["Core/Chart/StockChart.js"],
        ],
        function (A, O, F, G, U, H, Y, S, N) {
          (A.Navigator = F),
            (A.RangeSelector = G),
            (A.Scrollbar = U),
            (A.StockChart = A.stockChart = N.stockChart),
            O.compose(A.Series, A.Axis, A.Point),
            S.compose(A.Renderer),
            F.compose(A.Axis, A.Chart, A.Series),
            Y.compose(A.Series),
            H.compose(A.Axis, A.Series, A.Chart),
            G.compose(A.Axis, A.Chart),
            U.compose(A.Axis);
        }
      ),
      T(
        y,
        "masters/highstock.src.js",
        [y["masters/highcharts.src.js"]],
        function (A) {
          return (A.product = "Highstock"), A;
        }
      ),
      (y["masters/highstock.src.js"]._modules = y),
      y["masters/highstock.src.js"]
    );
  });
})(Ti);
var De = Ti.exports;
const Wi = Ci(De);
var Ei = { exports: {} };
(function (q) {
  (function (k) {
    q.exports
      ? ((k.default = k), (q.exports = k))
      : k(typeof Highcharts < "u" ? Highcharts : void 0);
  })(function (k) {
    function T(y, A, O, F) {
      y.hasOwnProperty(A) ||
        ((y[A] = F.apply(null, O)),
        typeof CustomEvent == "function" &&
          window.dispatchEvent(
            new CustomEvent("HighchartsModuleLoaded", {
              detail: { path: A, module: y[A] },
            })
          ));
    }
    (k = k ? k._modules : {}),
      T(
        k,
        "Accessibility/Utils/HTMLUtilities.js",
        [k["Core/Globals.js"], k["Core/Utilities.js"]],
        function (y, A) {
          function O(S) {
            if (typeof U.MouseEvent == "function")
              return new U.MouseEvent(S.type, S);
            if (G.createEvent) {
              const N = G.createEvent("MouseEvent");
              if (N.initMouseEvent)
                return (
                  N.initMouseEvent(
                    S.type,
                    S.bubbles,
                    S.cancelable,
                    S.view || U,
                    S.detail,
                    S.screenX,
                    S.screenY,
                    S.clientX,
                    S.clientY,
                    S.ctrlKey,
                    S.altKey,
                    S.shiftKey,
                    S.metaKey,
                    S.button,
                    S.relatedTarget
                  ),
                  N
                );
            }
            return F(S.type);
          }
          function F(S, N, D) {
            return (
              (N = N || { x: 0, y: 0 }),
              typeof U.MouseEvent == "function"
                ? new U.MouseEvent(S, {
                    bubbles: !0,
                    cancelable: !0,
                    composed: !0,
                    button: 0,
                    buttons: 1,
                    relatedTarget: D || Y,
                    view: U,
                    detail: S === "click" ? 1 : 0,
                    screenX: N.x,
                    screenY: N.y,
                    clientX: N.x,
                    clientY: N.y,
                  })
                : G.createEvent &&
                  ((D = G.createEvent("MouseEvent")), D.initMouseEvent)
                ? (D.initMouseEvent(
                    S,
                    !0,
                    !0,
                    U,
                    S === "click" ? 1 : 0,
                    N.x,
                    N.y,
                    N.x,
                    N.y,
                    !1,
                    !1,
                    !1,
                    !1,
                    0,
                    null
                  ),
                  D)
                : { type: S }
            );
          }
          const { doc: G, win: U } = y,
            { css: H } = A,
            Y = (U.EventTarget && new U.EventTarget()) || "none";
          return {
            addClass: function (S, N) {
              S.classList
                ? S.classList.add(N)
                : 0 > S.className.indexOf(N) && (S.className += " " + N);
            },
            cloneMouseEvent: O,
            cloneTouchEvent: function (S) {
              var N = (D) => {
                const c = [];
                for (let p = 0; p < D.length; ++p) {
                  const f = D.item(p);
                  f && c.push(f);
                }
                return c;
              };
              return typeof U.TouchEvent == "function"
                ? ((N = new U.TouchEvent(S.type, {
                    touches: N(S.touches),
                    targetTouches: N(S.targetTouches),
                    changedTouches: N(S.changedTouches),
                    ctrlKey: S.ctrlKey,
                    shiftKey: S.shiftKey,
                    altKey: S.altKey,
                    metaKey: S.metaKey,
                    bubbles: S.bubbles,
                    cancelable: S.cancelable,
                    composed: S.composed,
                    detail: S.detail,
                    view: S.view,
                  })),
                  S.defaultPrevented && N.preventDefault(),
                  N)
                : ((N = O(S)),
                  (N.touches = S.touches),
                  (N.changedTouches = S.changedTouches),
                  (N.targetTouches = S.targetTouches),
                  N);
            },
            escapeStringForHTML: function (S) {
              return S.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#x27;")
                .replace(/\//g, "&#x2F;");
            },
            getElement: function (S) {
              return G.getElementById(S);
            },
            getFakeMouseEvent: F,
            getHeadingTagNameForElement: function (S) {
              const N = (c) => (
                  (c = parseInt(c.slice(1), 10)), "h" + Math.min(6, c + 1)
                ),
                D = (c) => {
                  var p;
                  t: {
                    for (p = c; (p = p.previousSibling); ) {
                      const f = p.tagName || "";
                      if (/H[1-6]/.test(f)) {
                        p = f;
                        break t;
                      }
                    }
                    p = "";
                  }
                  return p
                    ? N(p)
                    : ((c = c.parentElement),
                      c
                        ? ((p = c.tagName), /H[1-6]/.test(p) ? N(p) : D(c))
                        : "p");
                };
              return D(S);
            },
            removeChildNodes: function (S) {
              for (; S.lastChild; ) S.removeChild(S.lastChild);
            },
            removeClass: function (S, N) {
              S.classList
                ? S.classList.remove(N)
                : (S.className = S.className.replace(new RegExp(N, "g"), ""));
            },
            removeElement: function (S) {
              S && S.parentNode && S.parentNode.removeChild(S);
            },
            reverseChildNodes: function (S) {
              let N = S.childNodes.length;
              for (; N--; ) S.appendChild(S.childNodes[N]);
            },
            simulatedEventTarget: Y,
            stripHTMLTagsFromString: function (S) {
              return typeof S == "string"
                ? S.replace(/<\/?[^>]+(>|$)/g, "")
                : S;
            },
            visuallyHideElement: function (S) {
              H(S, {
                position: "absolute",
                width: "1px",
                height: "1px",
                overflow: "hidden",
                whiteSpace: "nowrap",
                clip: "rect(1px, 1px, 1px, 1px)",
                marginTop: "-3px",
                "-ms-filter":
                  "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
                filter: "alpha(opacity=1)",
                opacity: 0.01,
              });
            },
          };
        }
      ),
      T(
        k,
        "Accessibility/A11yI18n.js",
        [k["Core/Templating.js"], k["Core/Utilities.js"]],
        function (y, A) {
          const { format: O } = y,
            { getNestedProperty: F, pick: G } = A;
          var U;
          return (
            (function (H) {
              function Y(c, p) {
                var f = c.indexOf("#each("),
                  u = c.indexOf("#plural("),
                  n = c.indexOf("[");
                const d = c.indexOf("]");
                if (-1 < f) {
                  n = c.slice(f).indexOf(")") + f;
                  var g = c.substring(0, f);
                  if (
                    ((u = c.substring(n + 1)),
                    (n = c.substring(f + 6, n).split(",")),
                    (f = Number(n[1])),
                    (c = ""),
                    (p = F(n[0], p)))
                  )
                    for (
                      f = isNaN(f) ? p.length : f,
                        f = 0 > f ? p.length + f : Math.min(f, p.length),
                        n = 0;
                      n < f;
                      ++n
                    )
                      c += g + p[n] + u;
                  return c.length ? c : "";
                }
                if (-1 < u) {
                  switch (
                    ((g = c.slice(u).indexOf(")") + u),
                    (c = c.substring(u + 8, g).split(",")),
                    Number(F(c[0], p)))
                  ) {
                    case 0:
                      c = G(c[4], c[1]);
                      break;
                    case 1:
                      c = G(c[2], c[1]);
                      break;
                    case 2:
                      c = G(c[3], c[1]);
                      break;
                    default:
                      c = c[1];
                  }
                  return (
                    c
                      ? ((p = c),
                        (p =
                          (p.trim && p.trim()) || p.replace(/^\s+|\s+$/g, "")))
                      : (p = ""),
                    p
                  );
                }
                return -1 < n
                  ? ((u = c.substring(0, n)),
                    (c = Number(c.substring(n + 1, d))),
                    (p = F(u, p)),
                    !isNaN(c) &&
                      p &&
                      (0 > c
                        ? ((g = p[p.length + c]), typeof g > "u" && (g = p[0]))
                        : ((g = p[c]),
                          typeof g > "u" && (g = p[p.length - 1]))),
                    typeof g < "u" ? g : "")
                  : "{" + c + "}";
              }
              function S(c, p, f) {
                const u = (C, P) => {
                    C = C.slice(P || 0);
                    const j = C.indexOf("{"),
                      m = C.indexOf("}");
                    if (-1 < j && m > j)
                      return {
                        statement: C.substring(j + 1, m),
                        begin: P + j + 1,
                        end: P + m,
                      };
                  },
                  n = [];
                let d,
                  g,
                  M = 0;
                do
                  (d = u(c, M)),
                    (g = c.substring(M, d && d.begin - 1)),
                    g.length && n.push({ value: g, type: "constant" }),
                    d && n.push({ value: d.statement, type: "statement" }),
                    (M = d ? d.end + 1 : M + 1);
                while (d);
                return (
                  n.forEach((C) => {
                    C.type === "statement" && (C.value = Y(C.value, p));
                  }),
                  O(
                    n.reduce((C, P) => C + P.value, ""),
                    p,
                    f
                  )
                );
              }
              function N(c, p) {
                c = c.split(".");
                let f = this.options.lang,
                  u = 0;
                for (; u < c.length; ++u) f = f && f[c[u]];
                return typeof f == "string" ? S(f, p, this) : "";
              }
              const D = [];
              (H.compose = function (c) {
                return A.pushUnique(D, c) && (c.prototype.langFormat = N), c;
              }),
                (H.i18nFormat = S);
            })(U || (U = {})),
            U
          );
        }
      ),
      T(
        k,
        "Accessibility/Utils/ChartUtilities.js",
        [
          k["Core/Globals.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O) {
          function F(u, n) {
            const d = n.type,
              g = u.hcEvents;
            N.createEvent && (u.dispatchEvent || u.fireEvent)
              ? u.dispatchEvent
                ? u.dispatchEvent(n)
                : u.fireEvent(d, n)
              : g && g[d]
              ? f(u, d, n)
              : u.element && F(u.element, n);
          }
          function G(u) {
            const n = u.chart,
              d = {};
            let g = "Seconds";
            (d.Seconds =
              ((u.dataMax || u.max || 0) - (u.dataMin || u.min || 0)) / 1e3),
              (d.Minutes = d.Seconds / 60),
              (d.Hours = d.Minutes / 60),
              (d.Days = d.Hours / 24),
              ["Minutes", "Hours", "Days"].forEach(function (C) {
                2 < d[C] && (g = C);
              });
            const M = d[g].toFixed(g !== "Seconds" && g !== "Minutes" ? 1 : 0);
            return n.langFormat("accessibility.axis.timeRange" + g, {
              chart: n,
              axis: u,
              range: M.replace(".0", ""),
            });
          }
          function U(u) {
            const n = u.chart;
            var d = n.options;
            const g =
                (d &&
                  d.accessibility &&
                  d.accessibility.screenReaderSection.axisRangeDateFormat) ||
                "",
              M = {
                min: u.dataMin || u.min || 0,
                max: u.dataMax || u.max || 0,
              };
            return (
              (d = function (C) {
                return u.dateTime
                  ? n.time.dateFormat(g, M[C])
                  : M[C].toString();
              }),
              n.langFormat("accessibility.axis.rangeFromTo", {
                chart: n,
                axis: u,
                rangeFrom: d("min"),
                rangeTo: d("max"),
              })
            );
          }
          function H(u) {
            if (u.points && u.points.length)
              return (
                (u = p(u.points, (n) => !!n.graphic)) &&
                u.graphic &&
                u.graphic.element
              );
          }
          function Y(u) {
            const n = H(u);
            return (
              (n && n.parentNode) ||
              (u.graph && u.graph.element) ||
              (u.group && u.group.element)
            );
          }
          function S(u, n) {
            n.setAttribute("aria-hidden", !1),
              n !== u.renderTo &&
                n.parentNode &&
                n.parentNode !== N.body &&
                (Array.prototype.forEach.call(
                  n.parentNode.childNodes,
                  function (d) {
                    d.hasAttribute("aria-hidden") ||
                      d.setAttribute("aria-hidden", !0);
                  }
                ),
                S(u, n.parentNode));
          }
          const { doc: N } = y,
            { stripHTMLTagsFromString: D } = A,
            { defined: c, find: p, fireEvent: f } = O;
          return {
            fireEventOnWrappedOrUnwrappedElement: F,
            getChartTitle: function (u) {
              return D(
                u.options.title.text ||
                  u.langFormat("accessibility.defaultChartTitle", { chart: u })
              );
            },
            getAxisDescription: function (u) {
              var n, d;
              return (
                u &&
                (((n = u.options.accessibility) === null || n === void 0
                  ? void 0
                  : n.description) ||
                  ((d = u.axisTitle) === null || d === void 0
                    ? void 0
                    : d.textStr) ||
                  u.options.id ||
                  (u.categories && "categories") ||
                  (u.dateTime && "Time") ||
                  "values")
              );
            },
            getAxisRangeDescription: function (u) {
              var n = u.options || {};
              return n.accessibility &&
                typeof n.accessibility.rangeDescription < "u"
                ? n.accessibility.rangeDescription
                : u.categories
                ? ((n = u.chart),
                  (u =
                    u.dataMax && u.dataMin
                      ? n.langFormat("accessibility.axis.rangeCategories", {
                          chart: n,
                          axis: u,
                          numCategories: u.dataMax - u.dataMin + 1,
                        })
                      : ""),
                  u)
                : !u.dateTime || (u.min !== 0 && u.dataMin !== 0)
                ? U(u)
                : G(u);
            },
            getPointFromXY: function (u, n, d) {
              let g = u.length,
                M;
              for (; g--; )
                if (
                  (M = p(u[g].points || [], function (C) {
                    return C.x === n && C.y === d;
                  }))
                )
                  return M;
            },
            getSeriesFirstPointElement: H,
            getSeriesFromName: function (u, n) {
              return n
                ? (u.series || []).filter(function (d) {
                    return d.name === n;
                  })
                : u.series;
            },
            getSeriesA11yElement: Y,
            unhideChartElementFromAT: S,
            hideSeriesFromAT: function (u) {
              (u = Y(u)) && u.setAttribute("aria-hidden", !0);
            },
            scrollToPoint: function (u) {
              var n = u.series.xAxis,
                d = u.series.yAxis;
              const g = n && n.scrollbar ? n : d;
              if ((n = g && g.scrollbar) && c(n.to) && c(n.from)) {
                if (((d = n.to - n.from), c(g.dataMin) && c(g.dataMax))) {
                  var M = g.toPixels(g.dataMin),
                    C = g.toPixels(g.dataMax);
                  u =
                    (g.toPixels(u[g.coll === "xAxis" ? "x" : "y"] || 0) - M) /
                    (C - M);
                } else u = 0;
                n.updatePosition(u - d / 2, u + d / 2),
                  f(n, "changed", {
                    from: n.from,
                    to: n.to,
                    trigger: "scrollbar",
                    DOMEvent: null,
                  });
              }
            },
          };
        }
      ),
      T(
        k,
        "Accessibility/Utils/DOMElementProvider.js",
        [k["Core/Globals.js"], k["Accessibility/Utils/HTMLUtilities.js"]],
        function (y, A) {
          const { doc: O } = y,
            { removeElement: F } = A;
          class G {
            constructor() {
              this.elements = [];
            }
            createElement() {
              const H = O.createElement.apply(O, arguments);
              return this.elements.push(H), H;
            }
            destroyCreatedElements() {
              this.elements.forEach(function (H) {
                F(H);
              }),
                (this.elements = []);
            }
          }
          return G;
        }
      ),
      T(
        k,
        "Accessibility/Utils/EventProvider.js",
        [k["Core/Globals.js"], k["Core/Utilities.js"]],
        function (y, A) {
          const { addEvent: O } = A;
          class F {
            constructor() {
              this.eventRemovers = [];
            }
            addEvent() {
              const U = O.apply(y, arguments);
              return this.eventRemovers.push(U), U;
            }
            removeAddedEvents() {
              this.eventRemovers.forEach((U) => U()), (this.eventRemovers = []);
            }
          }
          return F;
        }
      ),
      T(
        k,
        "Accessibility/AccessibilityComponent.js",
        [
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/DOMElementProvider.js"],
          k["Accessibility/Utils/EventProvider.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O, F, G) {
          const { fireEventOnWrappedOrUnwrappedElement: U } = y,
            { getFakeMouseEvent: H } = F;
          ({ extend: y } = G);
          class Y {
            constructor() {
              this.proxyProvider =
                this.keyCodes =
                this.eventProvider =
                this.domElementProvider =
                this.chart =
                  void 0;
            }
            initBase(N, D) {
              (this.chart = N),
                (this.eventProvider = new O()),
                (this.domElementProvider = new A()),
                (this.proxyProvider = D),
                (this.keyCodes = {
                  left: 37,
                  right: 39,
                  up: 38,
                  down: 40,
                  enter: 13,
                  space: 32,
                  esc: 27,
                  tab: 9,
                  pageUp: 33,
                  pageDown: 34,
                  end: 35,
                  home: 36,
                });
            }
            addEvent(N, D, c, p) {
              return this.eventProvider.addEvent(N, D, c, p);
            }
            createElement(N, D) {
              return this.domElementProvider.createElement(N, D);
            }
            fakeClickEvent(N) {
              const D = H("click");
              U(N, D);
            }
            destroyBase() {
              this.domElementProvider.destroyCreatedElements(),
                this.eventProvider.removeAddedEvents();
            }
          }
          return (
            y(Y.prototype, {
              init() {},
              getKeyboardNavigation: function () {},
              onChartUpdate() {},
              onChartRender() {},
              destroy() {},
            }),
            Y
          );
        }
      ),
      T(
        k,
        "Accessibility/KeyboardNavigationHandler.js",
        [k["Core/Utilities.js"]],
        function (y) {
          const { find: A } = y;
          class O {
            constructor(G, U) {
              (this.chart = G),
                (this.keyCodeMap = U.keyCodeMap || []),
                (this.validate = U.validate),
                (this.init = U.init),
                (this.terminate = U.terminate),
                (this.response = {
                  success: 1,
                  prev: 2,
                  next: 3,
                  noHandler: 4,
                  fail: 5,
                });
            }
            run(G) {
              const U = G.which || G.keyCode;
              let H = this.response.noHandler;
              const Y = A(this.keyCodeMap, function (S) {
                return -1 < S[0].indexOf(U);
              });
              return (
                Y
                  ? (H = Y[1].call(this, U, G))
                  : U === 9 &&
                    (H = this.response[G.shiftKey ? "prev" : "next"]),
                H
              );
            }
          }
          return O;
        }
      ),
      T(
        k,
        "Accessibility/Components/ContainerComponent.js",
        [
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/KeyboardNavigationHandler.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Core/Globals.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (y, A, O, F, G) {
          const { unhideChartElementFromAT: U, getChartTitle: H } = O,
            { doc: Y } = F,
            { stripHTMLTagsFromString: S } = G;
          class N extends y {
            onChartUpdate() {
              this.handleSVGTitleElement(),
                this.setSVGContainerLabel(),
                this.setGraphicContainerAttrs(),
                this.setRenderToAttrs(),
                this.makeCreditsAccessible();
            }
            handleSVGTitleElement() {
              const c = this.chart,
                p = "highcharts-title-" + c.index,
                f = S(
                  c.langFormat("accessibility.svgContainerTitle", {
                    chartTitle: H(c),
                  })
                );
              if (f.length) {
                const u = (this.svgTitleElement =
                  this.svgTitleElement ||
                  Y.createElementNS("http://www.w3.org/2000/svg", "title"));
                (u.textContent = f),
                  (u.id = p),
                  c.renderTo.insertBefore(u, c.renderTo.firstChild);
              }
            }
            setSVGContainerLabel() {
              const c = this.chart,
                p = c.langFormat("accessibility.svgContainerLabel", {
                  chartTitle: H(c),
                });
              c.renderer.box &&
                p.length &&
                c.renderer.box.setAttribute("aria-label", p);
            }
            setGraphicContainerAttrs() {
              const c = this.chart,
                p = c.langFormat("accessibility.graphicContainerLabel", {
                  chartTitle: H(c),
                });
              p.length && c.container.setAttribute("aria-label", p);
            }
            setRenderToAttrs() {
              const c = this.chart,
                p = c.options.accessibility.landmarkVerbosity !== "disabled",
                f = c.langFormat("accessibility.chartContainerLabel", {
                  title: H(c),
                  chart: c,
                });
              f &&
                (c.renderTo.setAttribute("role", p ? "region" : "group"),
                c.renderTo.setAttribute("aria-label", f));
            }
            makeCreditsAccessible() {
              const c = this.chart,
                p = c.credits;
              p &&
                (p.textStr &&
                  p.element.setAttribute(
                    "aria-label",
                    c.langFormat("accessibility.credits", {
                      creditsStr: S(p.textStr),
                    })
                  ),
                U(c, p.element));
            }
            getKeyboardNavigation() {
              const c = this.chart;
              return new A(c, {
                keyCodeMap: [],
                validate: function () {
                  return !0;
                },
                init: function () {
                  const p = c.accessibility;
                  p && p.keyboardNavigation.tabindexContainer.focus();
                },
              });
            }
            destroy() {
              this.chart.renderTo.setAttribute("aria-hidden", !0);
            }
          }
          return N;
        }
      ),
      T(
        k,
        "Accessibility/FocusBorder.js",
        [k["Core/Renderer/SVG/SVGLabel.js"], k["Core/Utilities.js"]],
        function (y, A) {
          const { addEvent: O, pick: F } = A;
          var G;
          return (
            (function (U) {
              function H() {
                const n = this.focusElement,
                  d = this.options.accessibility.keyboardNavigation.focusBorder;
                n &&
                  (n.removeFocusBorder(),
                  d.enabled &&
                    n.addFocusBorder(d.margin, {
                      stroke: d.style.color,
                      strokeWidth: d.style.lineWidth,
                      r: d.style.borderRadius,
                    }));
              }
              function Y(n, d) {
                const g =
                  this.options.accessibility.keyboardNavigation.focusBorder;
                (d = d || n.element) &&
                  d.focus &&
                  ((d.hcEvents && d.hcEvents.focusin) ||
                    O(d, "focusin", function () {}),
                  d.focus(),
                  g.hideBrowserFocusOutline && (d.style.outline = "none")),
                  this.focusElement && this.focusElement.removeFocusBorder(),
                  (this.focusElement = n),
                  this.renderFocusBorder();
              }
              function S(n) {
                if (!n.focusBorderDestroyHook) {
                  var d = n.destroy;
                  (n.destroy = function () {
                    return (
                      n.focusBorder &&
                        n.focusBorder.destroy &&
                        n.focusBorder.destroy(),
                      d.apply(n, arguments)
                    );
                  }),
                    (n.focusBorderDestroyHook = d);
                }
              }
              function N(n, d) {
                this.focusBorder && this.removeFocusBorder();
                const g = this.getBBox(),
                  M = F(n, 3),
                  C = this.parentGroup;
                var P = this.scaleX || (C && C.scaleX),
                  j = this.scaleY || (C && C.scaleY);
                (P = (P ? !j : j)
                  ? Math.abs(P || j || 1)
                  : (Math.abs(P || 1) + Math.abs(j || 1)) / 2),
                  (g.x += this.translateX ? this.translateX : 0),
                  (g.y += this.translateY ? this.translateY : 0),
                  (j = g.x - M);
                let m = g.y - M,
                  h = g.width + 2 * M,
                  v = g.height + 2 * M;
                var l = this instanceof y;
                if (this.element.nodeName === "text" || l) {
                  const t = !!this.rotation;
                  if (l) var o = { x: t ? 1 : 0, y: 0 };
                  else {
                    var i = (o = 0);
                    this.attr("text-anchor") === "middle"
                      ? (o = i = 0.5)
                      : this.rotation
                      ? (o = 0.25)
                      : (i = 0.75),
                      (o = { x: o, y: i });
                  }
                  i = +this.attr("x");
                  const e = +this.attr("y");
                  isNaN(i) || (j = i - g.width * o.x - M),
                    isNaN(e) || (m = e - g.height * o.y - M),
                    l &&
                      t &&
                      ((l = h),
                      (h = v),
                      (v = l),
                      isNaN(i) || (j = i - g.height * o.x - M),
                      isNaN(e) || (m = e - g.width * o.y - M));
                }
                (this.focusBorder = this.renderer
                  .rect(
                    j,
                    m,
                    h,
                    v,
                    parseInt(((d && d.r) || 0).toString(), 10) / P
                  )
                  .addClass("highcharts-focus-border")
                  .attr({ zIndex: 99 })
                  .add(C)),
                  this.renderer.styledMode ||
                    this.focusBorder.attr({
                      stroke: d && d.stroke,
                      "stroke-width": ((d && d.strokeWidth) || 0) / P,
                    }),
                  D(this, n, d),
                  S(this);
              }
              function D(n, ...d) {
                n.focusBorderUpdateHooks ||
                  ((n.focusBorderUpdateHooks = {}),
                  u.forEach((g) => {
                    g += "Setter";
                    const M = n[g] || n._defaultSetter;
                    (n.focusBorderUpdateHooks[g] = M),
                      (n[g] = function () {
                        const C = M.apply(n, arguments);
                        return n.addFocusBorder.apply(n, d), C;
                      });
                  }));
              }
              function c() {
                p(this),
                  this.focusBorderDestroyHook &&
                    ((this.destroy = this.focusBorderDestroyHook),
                    delete this.focusBorderDestroyHook),
                  this.focusBorder &&
                    (this.focusBorder.destroy(), delete this.focusBorder);
              }
              function p(n) {
                n.focusBorderUpdateHooks &&
                  (Object.keys(n.focusBorderUpdateHooks).forEach((d) => {
                    const g = n.focusBorderUpdateHooks[d];
                    g === n._defaultSetter ? delete n[d] : (n[d] = g);
                  }),
                  delete n.focusBorderUpdateHooks);
              }
              const f = [],
                u = "x y transform width height r d stroke-width".split(" ");
              U.compose = function (n, d) {
                A.pushUnique(f, n) &&
                  ((n = n.prototype),
                  (n.renderFocusBorder = H),
                  (n.setFocusToElement = Y)),
                  A.pushUnique(f, d) &&
                    ((d = d.prototype),
                    (d.addFocusBorder = N),
                    (d.removeFocusBorder = c));
              };
            })(G || (G = {})),
            G
          );
        }
      ),
      T(
        k,
        "Accessibility/Utils/Announcer.js",
        [
          k["Core/Renderer/HTML/AST.js"],
          k["Accessibility/Utils/DOMElementProvider.js"],
          k["Core/Globals.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O, F, G) {
          const { doc: U } = O,
            { addClass: H, visuallyHideElement: Y } = F,
            { attr: S } = G;
          class N {
            constructor(c, p) {
              (this.chart = c),
                (this.domElementProvider = new A()),
                (this.announceRegion = this.addAnnounceRegion(p));
            }
            destroy() {
              this.domElementProvider.destroyCreatedElements();
            }
            announce(c) {
              y.setElementHTML(this.announceRegion, c),
                this.clearAnnouncementRegionTimer &&
                  clearTimeout(this.clearAnnouncementRegionTimer),
                (this.clearAnnouncementRegionTimer = setTimeout(() => {
                  (this.announceRegion.innerHTML = y.emptyHTML),
                    delete this.clearAnnouncementRegionTimer;
                }, 1e3));
            }
            addAnnounceRegion(c) {
              const p =
                  this.chart.announcerContainer ||
                  this.createAnnouncerContainer(),
                f = this.domElementProvider.createElement("div");
              return (
                S(f, { "aria-hidden": !1, "aria-live": c }),
                this.chart.styledMode
                  ? H(f, "highcharts-visually-hidden")
                  : Y(f),
                p.appendChild(f),
                f
              );
            }
            createAnnouncerContainer() {
              const c = this.chart,
                p = U.createElement("div");
              return (
                S(p, {
                  "aria-hidden": !1,
                  class: "highcharts-announcer-container",
                }),
                (p.style.position = "relative"),
                c.renderTo.insertBefore(p, c.renderTo.firstChild),
                (c.announcerContainer = p)
              );
            }
          }
          return N;
        }
      ),
      T(
        k,
        "Accessibility/Components/AnnotationsA11y.js",
        [k["Accessibility/Utils/HTMLUtilities.js"]],
        function (y) {
          function A(Y) {
            return (Y.annotations || []).reduce(
              (S, N) => (
                N.options &&
                  N.options.visible !== !1 &&
                  (S = S.concat(N.labels)),
                S
              ),
              []
            );
          }
          function O(Y) {
            return (
              (Y.options &&
                Y.options.accessibility &&
                Y.options.accessibility.description) ||
              (Y.graphic && Y.graphic.text && Y.graphic.text.textStr) ||
              ""
            );
          }
          function F(Y) {
            var S =
              Y.options &&
              Y.options.accessibility &&
              Y.options.accessibility.description;
            if (S) return S;
            S = Y.chart;
            const N = O(Y),
              D = Y.points
                .filter((f) => !!f.graphic)
                .map((f) => {
                  const u =
                    (f.accessibility && f.accessibility.valueDescription) ||
                    (f.graphic &&
                      f.graphic.element &&
                      f.graphic.element.getAttribute("aria-label")) ||
                    "";
                  return (
                    (f = (f && f.series.name) || ""),
                    (f ? f + ", " : "") + "data point " + u
                  );
                })
                .filter((f) => !!f),
              c = D.length,
              p =
                "accessibility.screenReaderSection.annotations.description" +
                (1 < c ? "MultiplePoints" : c ? "SinglePoint" : "NoPoints");
            return (
              (Y = {
                annotationText: N,
                annotation: Y,
                numPoints: c,
                annotationPoint: D[0],
                additionalAnnotationPoints: D.slice(1),
              }),
              S.langFormat(p, Y)
            );
          }
          function G(Y) {
            return A(Y).map((S) => ((S = U(H(F(S)))) ? `<li>${S}</li>` : ""));
          }
          const { escapeStringForHTML: U, stripHTMLTagsFromString: H } = y;
          return {
            getAnnotationsInfoHTML: function (Y) {
              const S = Y.annotations;
              return S && S.length
                ? `<ul style="list-style-type: none">${G(Y).join(" ")}</ul>`
                : "";
            },
            getAnnotationLabelDescription: F,
            getAnnotationListItems: G,
            getPointAnnotationTexts: function (Y) {
              const S = A(Y.series.chart).filter(
                (N) => -1 < N.points.indexOf(Y)
              );
              return S.length ? S.map((N) => `${O(N)}`) : [];
            },
          };
        }
      ),
      T(
        k,
        "Accessibility/Components/InfoRegionsComponent.js",
        [
          k["Accessibility/A11yI18n.js"],
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/Utils/Announcer.js"],
          k["Accessibility/Components/AnnotationsA11y.js"],
          k["Core/Renderer/HTML/AST.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Core/Templating.js"],
          k["Core/Globals.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O, F, G, U, H, Y, S, N) {
          function D(o, i) {
            var t = i[0],
              e = (o.series && o.series[0]) || {};
            if (
              ((e = {
                numSeries: o.series.length,
                numPoints: e.points && e.points.length,
                chart: o,
                mapTitle:
                  o.mapView && o.mapView.geoMap && o.mapView.geoMap.title,
              }),
              !t)
            )
              return o.langFormat("accessibility.chartTypes.emptyChart", e);
            if (t === "map" || t === "tiledwebmap")
              return e.mapTitle
                ? o.langFormat("accessibility.chartTypes.mapTypeDescription", e)
                : o.langFormat("accessibility.chartTypes.unknownMap", e);
            if (1 < o.types.length)
              return o.langFormat(
                "accessibility.chartTypes.combinationChart",
                e
              );
            {
              (i = i[0]),
                (t = o.langFormat(
                  "accessibility.seriesTypeDescriptions." + i,
                  e
                ));
              const s = o.series && 2 > o.series.length ? "Single" : "Multiple";
              o =
                (o.langFormat("accessibility.chartTypes." + i + s, e) ||
                  o.langFormat("accessibility.chartTypes.default" + s, e)) +
                (t ? " " + t : "");
            }
            return o;
          }
          const { getAnnotationsInfoHTML: c } = F,
            {
              getAxisDescription: p,
              getAxisRangeDescription: f,
              getChartTitle: u,
              unhideChartElementFromAT: n,
            } = U,
            { format: d } = H,
            { doc: g } = Y,
            {
              addClass: M,
              getElement: C,
              getHeadingTagNameForElement: P,
              stripHTMLTagsFromString: j,
              visuallyHideElement: m,
            } = S,
            { attr: h, pick: v } = N;
          class l extends A {
            constructor() {
              super(...arguments),
                (this.announcer = void 0),
                (this.screenReaderSections = {});
            }
            init() {
              const i = this.chart,
                t = this;
              this.initRegionsDefinitions(),
                this.addEvent(i, "aftergetTableAST", function (e) {
                  t.onDataTableCreated(e);
                }),
                this.addEvent(i, "afterViewData", function (e) {
                  e.wasHidden &&
                    ((t.dataTableDiv = e.element),
                    setTimeout(function () {
                      t.focusDataTable();
                    }, 300));
                }),
                (this.announcer = new O(i, "assertive"));
            }
            initRegionsDefinitions() {
              const i = this;
              this.screenReaderSections = {
                before: {
                  element: null,
                  buildContent: function (t) {
                    const e =
                      t.options.accessibility.screenReaderSection
                        .beforeChartFormatter;
                    return e ? e(t) : i.defaultBeforeChartFormatter(t);
                  },
                  insertIntoDOM: function (t, e) {
                    e.renderTo.insertBefore(t, e.renderTo.firstChild);
                  },
                  afterInserted: function () {
                    typeof i.sonifyButtonId < "u" &&
                      i.initSonifyButton(i.sonifyButtonId),
                      typeof i.dataTableButtonId < "u" &&
                        i.initDataTableButton(i.dataTableButtonId);
                  },
                },
                after: {
                  element: null,
                  buildContent: function (t) {
                    const e =
                      t.options.accessibility.screenReaderSection
                        .afterChartFormatter;
                    return e ? e(t) : i.defaultAfterChartFormatter();
                  },
                  insertIntoDOM: function (t, e) {
                    e.renderTo.insertBefore(t, e.container.nextSibling);
                  },
                  afterInserted: function () {
                    i.chart.accessibility &&
                      i.chart.accessibility.keyboardNavigation.updateExitAnchor();
                  },
                },
              };
            }
            onChartRender() {
              const i = this;
              (this.linkedDescriptionElement =
                this.getLinkedDescriptionElement()),
                this.setLinkedDescriptionAttrs(),
                Object.keys(this.screenReaderSections).forEach(function (t) {
                  i.updateScreenReaderSection(t);
                });
            }
            getLinkedDescriptionElement() {
              var i = this.chart.options.accessibility.linkedDescription;
              if (i) {
                if (typeof i != "string") return i;
                if (
                  ((i = d(i, this.chart)),
                  (i = g.querySelectorAll(i)),
                  i.length === 1)
                )
                  return i[0];
              }
            }
            setLinkedDescriptionAttrs() {
              const i = this.linkedDescriptionElement;
              i &&
                (i.setAttribute("aria-hidden", "true"),
                M(i, "highcharts-linked-description"));
            }
            updateScreenReaderSection(i) {
              const t = this.chart,
                e = this.screenReaderSections[i],
                s = e.buildContent(t),
                a = (e.element = e.element || this.createElement("div")),
                b = a.firstChild || this.createElement("div");
              s
                ? (this.setScreenReaderSectionAttribs(a, i),
                  G.setElementHTML(b, s),
                  a.appendChild(b),
                  e.insertIntoDOM(a, t),
                  t.styledMode ? M(b, "highcharts-visually-hidden") : m(b),
                  n(t, b),
                  e.afterInserted && e.afterInserted())
                : (a.parentNode && a.parentNode.removeChild(a),
                  (e.element = null));
            }
            setScreenReaderSectionAttribs(i, t) {
              const e = this.chart,
                s = e.langFormat(
                  "accessibility.screenReaderSection." + t + "RegionLabel",
                  { chart: e, chartTitle: u(e) }
                );
              h(i, {
                id: `highcharts-screen-reader-region-${t}-${e.index}`,
                "aria-label": s || void 0,
              }),
                (i.style.position = "relative"),
                s &&
                  i.setAttribute(
                    "role",
                    e.options.accessibility.landmarkVerbosity === "all"
                      ? "region"
                      : "group"
                  );
            }
            defaultBeforeChartFormatter() {
              var i = this.chart;
              const t =
                i.options.accessibility.screenReaderSection.beforeChartFormat;
              if (!t) return "";
              var e = this.getAxesDescription();
              const s =
                  i.sonify &&
                  i.options.sonification &&
                  i.options.sonification.enabled,
                a = "highcharts-a11y-sonify-data-btn-" + i.index,
                b = "hc-linkto-highcharts-data-table-" + i.index,
                r = c(i),
                w = i.langFormat(
                  "accessibility.screenReaderSection.annotations.heading",
                  { chart: i }
                );
              return (
                (e = {
                  headingTagName: P(i.renderTo),
                  chartTitle: u(i),
                  typeDescription: this.getTypeDescriptionText(),
                  chartSubtitle: this.getSubtitleText(),
                  chartLongdesc: this.getLongdescText(),
                  xAxisDescription: e.xAxis,
                  yAxisDescription: e.yAxis,
                  playAsSoundButton: s ? this.getSonifyButtonText(a) : "",
                  viewTableButton: i.getCSV
                    ? this.getDataTableButtonText(b)
                    : "",
                  annotationsTitle: r ? w : "",
                  annotationsList: r,
                }),
                (i = y.i18nFormat(t, e, i)),
                (this.dataTableButtonId = b),
                (this.sonifyButtonId = a),
                i.replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "")
              );
            }
            defaultAfterChartFormatter() {
              const i = this.chart,
                t =
                  i.options.accessibility.screenReaderSection.afterChartFormat;
              if (!t) return "";
              const e = { endOfChartMarker: this.getEndOfChartMarkerText() };
              return y
                .i18nFormat(t, e, i)
                .replace(/<(\w+)[^>]*?>\s*<\/\1>/g, "");
            }
            getLinkedDescription() {
              const i = this.linkedDescriptionElement;
              return j((i && i.innerHTML) || "");
            }
            getLongdescText() {
              const i = this.chart.options;
              var t = i.caption;
              t = t && t.text;
              const e = this.getLinkedDescription();
              return i.accessibility.description || e || t || "";
            }
            getTypeDescriptionText() {
              const i = this.chart;
              return i.types
                ? i.options.accessibility.typeDescription || D(i, i.types)
                : "";
            }
            getDataTableButtonText(i) {
              var t = this.chart;
              return (
                (t = t.langFormat(
                  "accessibility.table.viewAsDataTableButtonText",
                  { chart: t, chartTitle: u(t) }
                )),
                '<button id="' + i + '">' + t + "</button>"
              );
            }
            getSonifyButtonText(i) {
              var t = this.chart;
              return t.options.sonification &&
                t.options.sonification.enabled === !1
                ? ""
                : ((t = t.langFormat(
                    "accessibility.sonification.playAsSoundButtonText",
                    { chart: t, chartTitle: u(t) }
                  )),
                  '<button id="' + i + '">' + t + "</button>");
            }
            getSubtitleText() {
              const i = this.chart.options.subtitle;
              return j((i && i.text) || "");
            }
            getEndOfChartMarkerText() {
              const i = this.chart,
                t = i.langFormat(
                  "accessibility.screenReaderSection.endOfChartMarker",
                  { chart: i }
                );
              return (
                '<div id="highcharts-end-of-chart-marker-' +
                i.index +
                '">' +
                t +
                "</div>"
              );
            }
            onDataTableCreated(i) {
              const t = this.chart;
              if (t.options.accessibility.enabled) {
                this.viewDataTableButton &&
                  this.viewDataTableButton.setAttribute(
                    "aria-expanded",
                    "true"
                  );
                const e = i.tree.attributes || {};
                (e.tabindex = -1),
                  (e.summary = t.langFormat(
                    "accessibility.table.tableSummary",
                    { chart: t }
                  )),
                  (i.tree.attributes = e);
              }
            }
            focusDataTable() {
              var i = this.dataTableDiv;
              (i = i && i.getElementsByTagName("table")[0]) &&
                i.focus &&
                i.focus();
            }
            initSonifyButton(i) {
              const t = (this.sonifyButton = C(i)),
                e = this.chart,
                s = (a) => {
                  t &&
                    (t.setAttribute("aria-hidden", "true"),
                    t.setAttribute("aria-label", "")),
                    a.preventDefault(),
                    a.stopPropagation(),
                    (a = e.langFormat(
                      "accessibility.sonification.playAsSoundClickAnnouncement",
                      { chart: e }
                    )),
                    this.announcer.announce(a),
                    setTimeout(() => {
                      t &&
                        (t.removeAttribute("aria-hidden"),
                        t.removeAttribute("aria-label")),
                        e.sonify && e.sonify();
                    }, 1e3);
                };
              t &&
                e &&
                (t.setAttribute("tabindex", -1),
                (t.onclick = function (a) {
                  (
                    (e.options.accessibility &&
                      e.options.accessibility.screenReaderSection
                        .onPlayAsSoundClick) ||
                    s
                  ).call(this, a, e);
                }));
            }
            initDataTableButton(i) {
              const t = (this.viewDataTableButton = C(i)),
                e = this.chart;
              (i = i.replace("hc-linkto-", "")),
                t &&
                  (h(t, { tabindex: -1, "aria-expanded": !!C(i) }),
                  (t.onclick =
                    e.options.accessibility.screenReaderSection
                      .onViewDataTableClick ||
                    function () {
                      e.viewData();
                    }));
            }
            getAxesDescription() {
              const i = this.chart;
              var t = function (b, r) {
                  return (
                    (b = i[b]),
                    1 < b.length ||
                      (b[0] &&
                        v(
                          b[0].options.accessibility &&
                            b[0].options.accessibility.enabled,
                          r
                        ))
                  );
                },
                e =
                  !!i.types &&
                  0 > i.types.indexOf("map") &&
                  0 > i.types.indexOf("treemap") &&
                  0 > i.types.indexOf("tilemap");
              const s = !!i.hasCartesianSeries,
                a = t("xAxis", !i.angular && s && e);
              return (
                (t = t("yAxis", s && e)),
                (e = {}),
                a && (e.xAxis = this.getAxisDescriptionText("xAxis")),
                t && (e.yAxis = this.getAxisDescriptionText("yAxis")),
                e
              );
            }
            getAxisDescriptionText(i) {
              const t = this.chart,
                e = t[i];
              return t.langFormat(
                "accessibility.axis." +
                  i +
                  "Description" +
                  (1 < e.length ? "Plural" : "Singular"),
                {
                  chart: t,
                  names: e.map(function (s) {
                    return p(s);
                  }),
                  ranges: e.map(function (s) {
                    return f(s);
                  }),
                  numAxes: e.length,
                }
              );
            }
            destroy() {
              this.announcer && this.announcer.destroy();
            }
          }
          return l;
        }
      ),
      T(
        k,
        "Accessibility/Components/MenuComponent.js",
        [
          k["Core/Chart/Chart.js"],
          k["Core/Utilities.js"],
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/KeyboardNavigationHandler.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (y, A, O, F, G, U) {
          const { attr: H } = A,
            { getChartTitle: Y, unhideChartElementFromAT: S } = G,
            { getFakeMouseEvent: N } = U;
          class D extends O {
            init() {
              const p = this.chart,
                f = this;
              this.addEvent(p, "exportMenuShown", function () {
                f.onMenuShown();
              }),
                this.addEvent(p, "exportMenuHidden", function () {
                  f.onMenuHidden();
                }),
                this.createProxyGroup();
            }
            onMenuHidden() {
              const p = this.chart.exportContextMenu;
              p && p.setAttribute("aria-hidden", "true"),
                this.setExportButtonExpandedState("false");
            }
            onMenuShown() {
              const p = this.chart,
                f = p.exportContextMenu;
              f && (this.addAccessibleContextMenuAttribs(), S(p, f)),
                this.setExportButtonExpandedState("true");
            }
            setExportButtonExpandedState(p) {
              this.exportButtonProxy &&
                this.exportButtonProxy.buttonElement.setAttribute(
                  "aria-expanded",
                  p
                );
            }
            onChartRender() {
              const p = this.chart,
                f = p.focusElement,
                u = p.accessibility;
              this.proxyProvider.clearGroup("chartMenu"),
                this.proxyMenuButton(),
                this.exportButtonProxy &&
                  f &&
                  f === p.exportingGroup &&
                  (f.focusBorder
                    ? p.setFocusToElement(
                        f,
                        this.exportButtonProxy.buttonElement
                      )
                    : u && u.keyboardNavigation.tabindexContainer.focus());
            }
            proxyMenuButton() {
              const p = this.chart,
                f = this.proxyProvider,
                u = p.exportSVGElements && p.exportSVGElements[0];
              {
                var n = p.options.exporting;
                const d = p.exportSVGElements && p.exportSVGElements[0];
                n = !!(
                  n &&
                  n.enabled !== !1 &&
                  n.accessibility &&
                  n.accessibility.enabled &&
                  d &&
                  d.element
                );
              }
              n &&
                u &&
                (this.exportButtonProxy = f.addProxyElement(
                  "chartMenu",
                  { click: u },
                  {
                    "aria-label": p.langFormat(
                      "accessibility.exporting.menuButtonLabel",
                      { chart: p, chartTitle: Y(p) }
                    ),
                    "aria-expanded": !1,
                    title: p.options.lang.contextButtonTitle || null,
                  }
                ));
            }
            createProxyGroup() {
              this.chart &&
                this.proxyProvider &&
                this.proxyProvider.addGroup("chartMenu", "div");
            }
            addAccessibleContextMenuAttribs() {
              const p = this.chart;
              var f = p.exportDivElements;
              f &&
                f.length &&
                (f.forEach((u) => {
                  u &&
                    (u.tagName !== "LI" || (u.children && u.children.length)
                      ? u.setAttribute("aria-hidden", "true")
                      : u.setAttribute("tabindex", -1));
                }),
                (f = f[0] && f[0].parentNode) &&
                  H(f, {
                    "aria-hidden": void 0,
                    "aria-label": p.langFormat(
                      "accessibility.exporting.chartMenuLabel",
                      { chart: p }
                    ),
                    role: "list",
                  }));
            }
            getKeyboardNavigation() {
              const p = this.keyCodes,
                f = this.chart,
                u = this;
              return new F(f, {
                keyCodeMap: [
                  [
                    [p.left, p.up],
                    function () {
                      return u.onKbdPrevious(this);
                    },
                  ],
                  [
                    [p.right, p.down],
                    function () {
                      return u.onKbdNext(this);
                    },
                  ],
                  [
                    [p.enter, p.space],
                    function () {
                      return u.onKbdClick(this);
                    },
                  ],
                ],
                validate: function () {
                  return (
                    !!f.exporting &&
                    f.options.exporting.enabled !== !1 &&
                    f.options.exporting.accessibility.enabled !== !1
                  );
                },
                init: function () {
                  const n = u.exportButtonProxy,
                    d = u.chart.exportingGroup;
                  n && d && f.setFocusToElement(d, n.buttonElement);
                },
                terminate: function () {
                  f.hideExportMenu();
                },
              });
            }
            onKbdPrevious(p) {
              const f = this.chart,
                u = f.options.accessibility;
              p = p.response;
              let n = f.highlightedExportItemIx || 0;
              for (; n--; ) if (f.highlightExportItem(n)) return p.success;
              return u.keyboardNavigation.wrapAround
                ? (f.highlightLastExportItem(), p.success)
                : p.prev;
            }
            onKbdNext(p) {
              const f = this.chart,
                u = f.options.accessibility;
              p = p.response;
              for (
                let n = (f.highlightedExportItemIx || 0) + 1;
                n < f.exportDivElements.length;
                ++n
              )
                if (f.highlightExportItem(n)) return p.success;
              return u.keyboardNavigation.wrapAround
                ? (f.highlightExportItem(0), p.success)
                : p.next;
            }
            onKbdClick(p) {
              const f = this.chart,
                u = f.exportDivElements[f.highlightedExportItemIx],
                n = (f.exportSVGElements && f.exportSVGElements[0]).element;
              return (
                f.openMenu
                  ? this.fakeClickEvent(u)
                  : (this.fakeClickEvent(n), f.highlightExportItem(0)),
                p.response.success
              );
            }
          }
          return (
            (function (c) {
              function p() {
                var g = this.exportSVGElements && this.exportSVGElements[0];
                g && ((g = g.element), g.onclick) && g.onclick(N("click"));
              }
              function f() {
                const g = this.exportDivElements;
                g &&
                  this.exportContextMenu &&
                  this.openMenu &&
                  (g.forEach((M) => {
                    M &&
                      M.className === "highcharts-menu-item" &&
                      M.onmouseout &&
                      M.onmouseout(N("mouseout"));
                  }),
                  (this.highlightedExportItemIx = 0),
                  this.exportContextMenu.hideMenu(),
                  this.container.focus());
              }
              function u(g) {
                const M = this.exportDivElements && this.exportDivElements[g],
                  C =
                    this.exportDivElements &&
                    this.exportDivElements[this.highlightedExportItemIx];
                if (
                  M &&
                  M.tagName === "LI" &&
                  (!M.children || !M.children.length)
                ) {
                  const P = !!(this.renderTo.getElementsByTagName("g")[0] || {})
                    .focus;
                  return (
                    M.focus && P && M.focus(),
                    C && C.onmouseout && C.onmouseout(N("mouseout")),
                    M.onmouseover && M.onmouseover(N("mouseover")),
                    (this.highlightedExportItemIx = g),
                    !0
                  );
                }
                return !1;
              }
              function n() {
                if (this.exportDivElements) {
                  let g = this.exportDivElements.length;
                  for (; g--; ) if (this.highlightExportItem(g)) return !0;
                }
                return !1;
              }
              const d = [];
              c.compose = function (g) {
                A.pushUnique(d, g) &&
                  ((g = y.prototype),
                  (g.hideExportMenu = f),
                  (g.highlightExportItem = u),
                  (g.highlightLastExportItem = n),
                  (g.showExportMenu = p));
              };
            })(D || (D = {})),
            D
          );
        }
      ),
      T(
        k,
        "Accessibility/KeyboardNavigation.js",
        [
          k["Core/Globals.js"],
          k["Accessibility/Components/MenuComponent.js"],
          k["Core/Utilities.js"],
          k["Accessibility/Utils/EventProvider.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (y, A, O, F, G) {
          const { doc: U, win: H } = y,
            { addEvent: Y, fireEvent: S } = O,
            { getElement: N, simulatedEventTarget: D } = G;
          class c {
            constructor(f, u) {
              (this.components = this.chart = void 0),
                (this.currentModuleIx = NaN),
                (this.exitAnchor = this.eventProvider = void 0),
                (this.modules = []),
                (this.tabindexContainer = void 0),
                this.init(f, u);
            }
            init(f, u) {
              const n = (this.eventProvider = new F());
              (this.chart = f),
                (this.components = u),
                (this.modules = []),
                (this.currentModuleIx = 0),
                this.update(),
                n.addEvent(this.tabindexContainer, "keydown", (d) =>
                  this.onKeydown(d)
                ),
                n.addEvent(this.tabindexContainer, "focus", (d) =>
                  this.onFocus(d)
                ),
                ["mouseup", "touchend"].forEach((d) =>
                  n.addEvent(U, d, (g) => this.onMouseUp(g))
                ),
                ["mousedown", "touchstart"].forEach((d) =>
                  n.addEvent(f.renderTo, d, () => {
                    this.isClickingChart = !0;
                  })
                );
            }
            update(f) {
              var u = this.chart.options.accessibility;
              u = u && u.keyboardNavigation;
              const n = this.components;
              this.updateContainerTabindex(),
                u && u.enabled && f && f.length
                  ? ((this.modules = f.reduce(function (d, g) {
                      return (g = n[g].getKeyboardNavigation()), d.concat(g);
                    }, [])),
                    this.updateExitAnchor())
                  : ((this.modules = []),
                    (this.currentModuleIx = 0),
                    this.removeExitAnchor());
            }
            updateExitAnchor() {
              const f = N(`highcharts-end-of-chart-marker-${this.chart.index}`);
              this.removeExitAnchor(),
                f
                  ? (this.makeElementAnExitAnchor(f), (this.exitAnchor = f))
                  : this.createExitAnchor();
            }
            move(f) {
              var u = this.modules && this.modules[this.currentModuleIx];
              if (
                (u && u.terminate && u.terminate(f),
                this.chart.focusElement &&
                  this.chart.focusElement.removeFocusBorder(),
                (this.currentModuleIx += f),
                (u = this.modules && this.modules[this.currentModuleIx]))
              ) {
                if (u.validate && !u.validate()) return this.move(f);
                if (u.init) return u.init(f), !0;
              }
              return (
                (this.currentModuleIx = 0),
                (this.exiting = !0),
                0 < f
                  ? this.exitAnchor && this.exitAnchor.focus()
                  : this.tabindexContainer.focus(),
                !1
              );
            }
            onFocus(f) {
              var u = this.chart;
              (f = f.relatedTarget && u.container.contains(f.relatedTarget)),
                !(u = (u = u.options.accessibility) && u.keyboardNavigation) ||
                  !u.enabled ||
                  this.exiting ||
                  this.tabbingInBackwards ||
                  this.isClickingChart ||
                  f ||
                  ((f = this.getFirstValidModuleIx()),
                  f !== null &&
                    ((this.currentModuleIx = f), this.modules[f].init(1))),
                (this.exiting = !1);
            }
            onMouseUp(f) {
              if (
                (delete this.isClickingChart,
                !this.keyboardReset && f.relatedTarget !== D)
              ) {
                const u = this.chart;
                (f.target && u.container.contains(f.target)) ||
                  ((f =
                    this.modules && this.modules[this.currentModuleIx || 0]) &&
                    f.terminate &&
                    f.terminate(),
                  (this.currentModuleIx = 0)),
                  u.focusElement &&
                    (u.focusElement.removeFocusBorder(), delete u.focusElement),
                  (this.keyboardReset = !0);
              }
            }
            onKeydown(f) {
              f = f || H.event;
              const u =
                this.modules &&
                this.modules.length &&
                this.modules[this.currentModuleIx];
              let n;
              if (((this.exiting = this.keyboardReset = !1), u)) {
                const d = u.run(f);
                d === u.response.success
                  ? (n = !0)
                  : d === u.response.prev
                  ? (n = this.move(-1))
                  : d === u.response.next && (n = this.move(1)),
                  n && (f.preventDefault(), f.stopPropagation());
              }
            }
            updateContainerTabindex() {
              var f = this.chart.options.accessibility;
              (f = f && f.keyboardNavigation), (f = !(f && f.enabled === !1));
              const u = this.chart;
              var n = u.container;
              u.renderTo.hasAttribute("tabindex") &&
                (n.removeAttribute("tabindex"), (n = u.renderTo)),
                (this.tabindexContainer = n);
              const d = n.getAttribute("tabindex");
              f && !d
                ? n.setAttribute("tabindex", "0")
                : f || u.container.removeAttribute("tabindex");
            }
            createExitAnchor() {
              const f = this.chart,
                u = (this.exitAnchor = U.createElement("div"));
              f.renderTo.appendChild(u), this.makeElementAnExitAnchor(u);
            }
            makeElementAnExitAnchor(f) {
              const u = this.tabindexContainer.getAttribute("tabindex") || 0;
              f.setAttribute("class", "highcharts-exit-anchor"),
                f.setAttribute("tabindex", u),
                f.setAttribute("aria-hidden", !1),
                this.addExitAnchorEventsToEl(f);
            }
            removeExitAnchor() {
              this.exitAnchor &&
                this.exitAnchor.parentNode &&
                (this.exitAnchor.parentNode.removeChild(this.exitAnchor),
                delete this.exitAnchor);
            }
            addExitAnchorEventsToEl(f) {
              const u = this.chart,
                n = this;
              this.eventProvider.addEvent(f, "focus", function (d) {
                d = d || H.event;
                const g = !(
                  (d.relatedTarget && u.container.contains(d.relatedTarget)) ||
                  n.exiting
                );
                u.focusElement && delete u.focusElement,
                  g
                    ? ((n.tabbingInBackwards = !0),
                      n.tabindexContainer.focus(),
                      delete n.tabbingInBackwards,
                      d.preventDefault(),
                      n.modules &&
                        n.modules.length &&
                        ((n.currentModuleIx = n.modules.length - 1),
                        (d = n.modules[n.currentModuleIx]) &&
                        d.validate &&
                        !d.validate()
                          ? n.move(-1)
                          : d && d.init(-1)))
                    : (n.exiting = !1);
              });
            }
            getFirstValidModuleIx() {
              const f = this.modules.length;
              for (let u = 0; u < f; ++u) {
                const n = this.modules[u];
                if (!n.validate || n.validate()) return u;
              }
              return null;
            }
            destroy() {
              this.removeExitAnchor(),
                this.eventProvider.removeAddedEvents(),
                this.chart.container.removeAttribute("tabindex");
            }
          }
          return (
            (function (p) {
              function f() {
                const d = this;
                S(this, "dismissPopupContent", {}, function () {
                  d.tooltip && d.tooltip.hide(0), d.hideExportMenu();
                });
              }
              function u(d) {
                (d.which || d.keyCode) === 27 &&
                  y.charts &&
                  y.charts.forEach((g) => {
                    g && g.dismissPopupContent && g.dismissPopupContent();
                  });
              }
              const n = [];
              p.compose = function (d) {
                return (
                  A.compose(d),
                  O.pushUnique(n, d) && (d.prototype.dismissPopupContent = f),
                  O.pushUnique(n, U) && Y(U, "keydown", u),
                  d
                );
              };
            })(c || (c = {})),
            c
          );
        }
      ),
      T(
        k,
        "Accessibility/Components/LegendComponent.js",
        [
          k["Core/Animation/AnimationUtilities.js"],
          k["Core/Globals.js"],
          k["Core/Legend/Legend.js"],
          k["Core/Utilities.js"],
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/KeyboardNavigationHandler.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (y, A, O, F, G, U, H, Y) {
          function S(m) {
            const h = m.legend && m.legend.allItems,
              v = m.options.legend.accessibility || {};
            return (
              (m =
                m.colorAxis &&
                m.colorAxis.some(
                  (l) => !l.dataClasses || !l.dataClasses.length
                )),
              !(!h || !h.length || m || v.enabled === !1)
            );
          }
          function N(m, h) {
            const v = h.legendItem || {};
            h.setState(m ? "hover" : "", !0);
            for (const l of ["group", "label", "symbol"])
              (h = ((h = v[l]) && h.element) || h) &&
                f(h, m ? "mouseover" : "mouseout");
          }
          const { animObject: D } = y,
            { doc: c } = A,
            {
              addEvent: p,
              fireEvent: f,
              isNumber: u,
              pick: n,
              syncTimeout: d,
            } = F,
            { getChartTitle: g } = H,
            { stripHTMLTagsFromString: M, addClass: C, removeClass: P } = Y;
          class j extends G {
            constructor() {
              super(...arguments),
                (this.highlightedLegendItemIx = NaN),
                (this.proxyGroup = null);
            }
            init() {
              const h = this;
              this.recreateProxies(),
                this.addEvent(O, "afterScroll", function () {
                  this.chart === h.chart &&
                    (h.proxyProvider.updateGroupProxyElementPositions("legend"),
                    h.updateLegendItemProxyVisibility(),
                    -1 < h.highlightedLegendItemIx &&
                      this.chart.highlightLegendItem(
                        h.highlightedLegendItemIx
                      ));
                }),
                this.addEvent(O, "afterPositionItem", function (v) {
                  this.chart === h.chart &&
                    this.chart.renderer &&
                    h.updateProxyPositionForItem(v.item);
                }),
                this.addEvent(O, "afterRender", function () {
                  this.chart === h.chart &&
                    this.chart.renderer &&
                    h.recreateProxies() &&
                    d(
                      () =>
                        h.proxyProvider.updateGroupProxyElementPositions(
                          "legend"
                        ),
                      D(n(this.chart.renderer.globalAnimation, !0)).duration
                    );
                });
            }
            updateLegendItemProxyVisibility() {
              const h = this.chart,
                v = h.legend,
                l = v.currentPage || 1,
                o = v.clipHeight || 0;
              let i;
              (v.allItems || []).forEach((t) => {
                if (t.a11yProxyElement) {
                  var e = v.pages && v.pages.length;
                  const a = t.a11yProxyElement.element;
                  var s = !1;
                  (i = t.legendItem || {}),
                    e &&
                      ((t = i.pageIx || 0),
                      (e = i.y || 0),
                      (s = i.label ? Math.round(i.label.getBBox().height) : 0),
                      (s = e + s - v.pages[t] > o || t !== l - 1)),
                    s
                      ? h.styledMode
                        ? C(a, "highcharts-a11y-invisible")
                        : (a.style.visibility = "hidden")
                      : (P(a, "highcharts-a11y-invisible"),
                        (a.style.visibility = ""));
                }
              });
            }
            onChartRender() {
              S(this.chart) || this.removeProxies();
            }
            highlightAdjacentLegendPage(h) {
              const v = this.chart;
              var l = v.legend;
              h = (l.currentPage || 1) + h;
              var o = l.pages || [];
              if (0 < h && h <= o.length) {
                o = 0;
                for (const i of l.allItems)
                  ((i.legendItem || {}).pageIx || 0) + 1 === h &&
                    (l = v.highlightLegendItem(o)) &&
                    (this.highlightedLegendItemIx = o),
                    ++o;
              }
            }
            updateProxyPositionForItem(h) {
              h.a11yProxyElement && h.a11yProxyElement.refreshPosition();
            }
            recreateProxies() {
              var h = c.activeElement;
              const v = this.proxyGroup;
              return (
                (h = h && v && v.contains(h)),
                this.removeProxies(),
                S(this.chart)
                  ? (this.addLegendProxyGroup(),
                    this.proxyLegendItems(),
                    this.updateLegendItemProxyVisibility(),
                    this.updateLegendTitle(),
                    h &&
                      this.chart.highlightLegendItem(
                        this.highlightedLegendItemIx
                      ),
                    !0)
                  : !1
              );
            }
            removeProxies() {
              this.proxyProvider.removeGroup("legend");
            }
            updateLegendTitle() {
              var h = this.chart;
              const v = M(
                (
                  (h.legend &&
                    h.legend.options.title &&
                    h.legend.options.title.text) ||
                  ""
                ).replace(/<br ?\/?>/g, " ")
              );
              (h = h.langFormat(
                "accessibility.legend.legendLabel" + (v ? "" : "NoTitle"),
                { chart: h, legendTitle: v, chartTitle: g(h) }
              )),
                this.proxyProvider.updateGroupAttrs("legend", {
                  "aria-label": h,
                });
            }
            addLegendProxyGroup() {
              this.proxyGroup = this.proxyProvider.addGroup("legend", "ul", {
                "aria-label": "_placeholder_",
                role:
                  this.chart.options.accessibility.landmarkVerbosity === "all"
                    ? "region"
                    : null,
              });
            }
            proxyLegendItems() {
              const h = this;
              let v;
              ((this.chart.legend || {}).allItems || []).forEach((l) => {
                (v = l.legendItem || {}),
                  v.label && v.label.element && h.proxyLegendItem(l);
              });
            }
            proxyLegendItem(h) {
              const v = h.legendItem || {};
              if (v.label && v.group) {
                var l = this.chart.langFormat(
                  "accessibility.legend.legendItem",
                  { chart: this.chart, itemName: M(h.name), item: h }
                );
                h.a11yProxyElement = this.proxyProvider.addProxyElement(
                  "legend",
                  {
                    click: v.label,
                    visual: (v.group.div ? v.label : v.group).element,
                  },
                  { tabindex: -1, "aria-pressed": h.visible, "aria-label": l }
                );
              }
            }
            getKeyboardNavigation() {
              const h = this.keyCodes,
                v = this,
                l = this.chart;
              return new U(l, {
                keyCodeMap: [
                  [
                    [h.left, h.right, h.up, h.down],
                    function (o) {
                      return v.onKbdArrowKey(this, o);
                    },
                  ],
                  [
                    [h.enter, h.space],
                    function () {
                      return v.onKbdClick(this);
                    },
                  ],
                  [
                    [h.pageDown, h.pageUp],
                    function (o) {
                      return (
                        v.highlightAdjacentLegendPage(
                          o === h.pageDown ? 1 : -1
                        ),
                        this.response.success
                      );
                    },
                  ],
                ],
                validate: function () {
                  return v.shouldHaveLegendNavigation();
                },
                init: function () {
                  l.highlightLegendItem(0), (v.highlightedLegendItemIx = 0);
                },
                terminate: function () {
                  (v.highlightedLegendItemIx = -1),
                    l.legend.allItems.forEach((o) => N(!1, o));
                },
              });
            }
            onKbdArrowKey(h, v) {
              const l = this.keyCodes,
                o = h.response,
                i = this.chart,
                t = i.options.accessibility,
                e = i.legend.allItems.length;
              return (
                (v = v === l.left || v === l.up ? -1 : 1),
                i.highlightLegendItem(this.highlightedLegendItemIx + v)
                  ? ((this.highlightedLegendItemIx += v), o.success)
                  : (1 < e && t.keyboardNavigation.wrapAround && h.init(v),
                    o.success)
              );
            }
            onKbdClick(h) {
              const v =
                this.chart.legend.allItems[this.highlightedLegendItemIx];
              return (
                v && v.a11yProxyElement && v.a11yProxyElement.click(),
                h.response.success
              );
            }
            shouldHaveLegendNavigation() {
              if (!S(this.chart)) return !1;
              const h = this.chart,
                v = (h.options.legend || {}).accessibility || {};
              return !!(
                h.legend.display &&
                v.keyboardNavigation &&
                v.keyboardNavigation.enabled
              );
            }
          }
          return (
            (function (m) {
              function h(o) {
                var i = this.legend.allItems,
                  t =
                    this.accessibility &&
                    this.accessibility.components.legend
                      .highlightedLegendItemIx;
                const e = i[o];
                var s = e.legendItem || {};
                return e
                  ? (u(t) && i[t] && N(!1, i[t]),
                    (i = this.legend),
                    (o = (i.allItems[o].legendItem || {}).pageIx),
                    (t = i.currentPage),
                    typeof o < "u" && o + 1 !== t && i.scroll(1 + o - t),
                    (s = s.label),
                    (o =
                      e.a11yProxyElement && e.a11yProxyElement.buttonElement),
                    s && s.element && o && this.setFocusToElement(s, o),
                    N(!0, e),
                    !0)
                  : !1;
              }
              function v(o) {
                const i = o.item;
                this.chart.options.accessibility.enabled &&
                  i &&
                  i.a11yProxyElement &&
                  i.a11yProxyElement.buttonElement.setAttribute(
                    "aria-pressed",
                    o.visible ? "true" : "false"
                  );
              }
              const l = [];
              m.compose = function (o, i) {
                F.pushUnique(l, o) && (o.prototype.highlightLegendItem = h),
                  F.pushUnique(l, i) && p(i, "afterColorizeItem", v);
              };
            })(j || (j = {})),
            j
          );
        }
      ),
      T(
        k,
        "Accessibility/Components/SeriesComponent/SeriesDescriber.js",
        [
          k["Accessibility/Components/AnnotationsA11y.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Core/Templating.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O, F, G) {
          function U(s) {
            const a = s.index;
            return (
              (s.series &&
                s.series.data &&
                e(a) &&
                l(s.series.data, function (b) {
                  return !!(
                    b &&
                    typeof b.index < "u" &&
                    b.index > a &&
                    b.graphic &&
                    b.graphic.element
                  );
                })) ||
              null
            );
          }
          function H(s) {
            const a =
              s.chart.options.accessibility.series
                .pointDescriptionEnabledThreshold;
            return !!(a !== !1 && s.points && s.points.length >= a);
          }
          function Y(s) {
            const a = s.options.accessibility || {};
            return !H(s) && !a.exposeAsGroupOnly;
          }
          function S(s) {
            const a =
              s.chart.options.accessibility.keyboardNavigation.seriesNavigation;
            return !(
              !s.points ||
              !(
                s.points.length < a.pointNavigationEnabledThreshold ||
                a.pointNavigationEnabledThreshold === !1
              )
            );
          }
          function N(s, a) {
            var b = s.series,
              r = b.chart;
            s = r.options.accessibility.point || {};
            const w =
              (b.options.accessibility && b.options.accessibility.point) || {};
            return (
              (b = b.tooltipOptions || {}),
              (r = r.options.lang),
              o(a)
                ? m(
                    a,
                    w.valueDecimals || s.valueDecimals || b.valueDecimals || -1,
                    r.decimalPoint,
                    r.accessibility.thousandsSep || r.thousandsSep
                  )
                : a
            );
          }
          function D(s) {
            const a = (s.options.accessibility || {}).description;
            return (
              (a &&
                s.chart.langFormat("accessibility.series.description", {
                  description: a,
                  series: s,
                })) ||
              ""
            );
          }
          function c(s, a) {
            return s.chart.langFormat(
              "accessibility.series." + a + "Description",
              { name: g(s[a]), series: s }
            );
          }
          function p(s, a, b) {
            const r = a || "",
              w = b || "";
            return s.series.pointArrayMap.reduce(function (L, I) {
              {
                const V = N(s, t(s[I], s.options[I]));
                I = V !== void 0 ? I + ": " + r + V + w : V;
              }
              return I ? L + (L.length ? ", " : "") + I : L;
            }, "");
          }
          function f(s) {
            var a = s.series,
              b = 1 < a.chart.series.length || a.options.name,
              r = s.series,
              w = r.chart,
              L = r.options.accessibility;
            if (
              ((L =
                (L && L.point && L.point.valueDescriptionFormat) ||
                w.options.accessibility.point.valueDescriptionFormat),
              (r = t(
                r.xAxis &&
                  r.xAxis.options.accessibility &&
                  r.xAxis.options.accessibility.enabled,
                !w.angular && r.type !== "flowmap"
              )),
              r)
            ) {
              var I = s.series,
                V = I.chart,
                B =
                  (I.options.accessibility && I.options.accessibility.point) ||
                  {},
                x = V.options.accessibility.point || {};
              (I = I.xAxis && I.xAxis.dateTime)
                ? ((I = I.getXDateFormat(
                    s.x || 0,
                    V.options.tooltip.dateTimeLabelFormats
                  )),
                  (B =
                    (B.dateFormatter && B.dateFormatter(s)) ||
                    (x.dateFormatter && x.dateFormatter(s)) ||
                    B.dateFormat ||
                    x.dateFormat ||
                    I),
                  (V = V.time.dateFormat(B, s.x || 0, void 0)))
                : (V = void 0),
                (B =
                  (s.series.xAxis || {}).categories &&
                  e(s.category) &&
                  ("" + s.category).replace("<br/>", " ")),
                (x = e(s.id) && 0 > ("" + s.id).indexOf("highcharts-")),
                (I = "x, " + s.x),
                (V = s.name || V || B || (x ? s.id : I));
            } else V = "";
            (B = V), (V = e(s.index) ? s.index + 1 : "");
            {
              x = s.series;
              var R = x.chart.options.accessibility.point || {},
                W =
                  (x.chart.options.accessibility &&
                    x.chart.options.accessibility.point) ||
                  {};
              const X = x.tooltipOptions || {};
              (I = W.valuePrefix || R.valuePrefix || X.valuePrefix || ""),
                (R = W.valueSuffix || R.valueSuffix || X.valueSuffix || ""),
                (W = N(s, s[typeof s.value < "u" ? "value" : "y"])),
                (x = s.isNull
                  ? x.chart.langFormat("accessibility.series.nullPointValue", {
                      point: s,
                    })
                  : x.pointArrayMap
                  ? p(s, I, R)
                  : I + W + R);
            }
            return (
              (w = j(
                L,
                {
                  point: s,
                  index: V,
                  xDescription: B,
                  value: x,
                  separator: r ? ", " : "",
                },
                w
              )),
              (L = (L =
                s.options &&
                s.options.accessibility &&
                s.options.accessibility.description)
                ? " " + L
                : ""),
              (a = b ? " " + a.name + "." : ""),
              (b = s.series.chart),
              (r = d(s)),
              (V = { point: s, annotations: r }),
              (b = r.length
                ? b.langFormat(
                    "accessibility.series.pointAnnotationsDescription",
                    V
                  )
                : ""),
              (s.accessibility = s.accessibility || {}),
              (s.accessibility.valueDescription = w),
              w + L + a + (b ? " " + b : "")
            );
          }
          function u(s) {
            const a = Y(s),
              b = S(s),
              r = s.chart.options.accessibility.point.describeNull;
            (a || b) &&
              s.points.forEach((w) => {
                var L;
                if (!(L = w.graphic && w.graphic.element)) {
                  var I = w.series;
                  if (
                    ((L = I && I.chart),
                    (I = I && I.is("sunburst")),
                    (L = L && L.options.accessibility.point.describeNull),
                    (L = w.isNull && !I && L))
                  ) {
                    I = w.series;
                    var V = U(w);
                    (I = (L = V && V.graphic)
                      ? L.parentGroup
                      : I.graph || I.group),
                      (V = V
                        ? {
                            x: t(w.plotX, V.plotX, 0),
                            y: t(w.plotY, V.plotY, 0),
                          }
                        : { x: t(w.plotX, 0), y: t(w.plotY, 0) }),
                      (V = w.series.chart.renderer.rect(V.x, V.y, 1, 1)),
                      V.attr({
                        class: "highcharts-a11y-mock-point",
                        fill: "none",
                        opacity: 0,
                        "fill-opacity": 0,
                        "stroke-opacity": 0,
                      }),
                      I && I.element
                        ? ((w.graphic = V),
                          (w.hasMockGraphic = !0),
                          V.add(I),
                          I.element.insertBefore(
                            V.element,
                            L ? L.element : null
                          ),
                          (L = V.element))
                        : (L = void 0);
                  }
                }
                if (
                  ((I =
                    w.options &&
                    w.options.accessibility &&
                    w.options.accessibility.enabled === !1),
                  L)
                )
                  if (w.isNull && !r) L.setAttribute("aria-hidden", !0);
                  else if (
                    (L.setAttribute("tabindex", "-1"),
                    s.chart.styledMode || (L.style.outline = "none"),
                    a && !I)
                  ) {
                    var B, x, R;
                    (I = w.series),
                      (V =
                        ((B = I.options.accessibility) === null || B === void 0
                          ? void 0
                          : B.point) || {}),
                      (B = I.chart.options.accessibility.point || {}),
                      (w = v(
                        (i(V.descriptionFormat) &&
                          j(V.descriptionFormat, w, I.chart)) ||
                          ((x = V.descriptionFormatter) === null || x === void 0
                            ? void 0
                            : x.call(V, w)) ||
                          (i(B.descriptionFormat) &&
                            j(B.descriptionFormat, w, I.chart)) ||
                          ((R = B.descriptionFormatter) === null || R === void 0
                            ? void 0
                            : R.call(B, w)) ||
                          f(w)
                      )),
                      L.setAttribute("role", "img"),
                      L.setAttribute("aria-label", w);
                  } else L.setAttribute("aria-hidden", !0);
              });
          }
          function n(s) {
            const a = s.chart;
            var b = a.types || [];
            const r = D(s);
            var w = function (x) {
              return a[x] && 1 < a[x].length && s[x];
            };
            const L = s.index + 1;
            var I = c(s, "xAxis");
            const V = c(s, "yAxis");
            var B = { seriesNumber: L, series: s, chart: a };
            return (
              (b = 1 < b.length ? "Combination" : ""),
              (B =
                a.langFormat("accessibility.series.summary." + s.type + b, B) ||
                a.langFormat("accessibility.series.summary.default" + b, B)),
              (w =
                (w("yAxis") ? " " + V + "." : "") +
                (w("xAxis") ? " " + I + "." : "")),
              (I = t(
                s.options.accessibility &&
                  s.options.accessibility.descriptionFormat,
                a.options.accessibility.series.descriptionFormat,
                ""
              )),
              j(
                I,
                {
                  seriesDescription: B,
                  authorDescription: r ? " " + r : "",
                  axisDescription: w,
                  series: s,
                  chart: a,
                  seriesNumber: L,
                },
                void 0
              )
            );
          }
          const { getPointAnnotationTexts: d } = y,
            {
              getAxisDescription: g,
              getSeriesFirstPointElement: M,
              getSeriesA11yElement: C,
              unhideChartElementFromAT: P,
            } = A,
            { format: j, numberFormat: m } = O,
            { reverseChildNodes: h, stripHTMLTagsFromString: v } = F,
            { find: l, isNumber: o, isString: i, pick: t, defined: e } = G;
          return {
            defaultPointDescriptionFormatter: f,
            defaultSeriesDescriptionFormatter: n,
            describeSeries: function (s) {
              var a = s.chart,
                b = M(s);
              const r = C(s);
              var w = a.is3d && a.is3d();
              if (r) {
                r.lastChild !== b || w || h(r), u(s), P(a, r);
                {
                  (w = s.chart),
                    (a = w.options.chart),
                    (b = 1 < w.series.length),
                    (w = w.options.accessibility.series.describeSingleSeries);
                  const L = (s.options.accessibility || {}).exposeAsGroupOnly;
                  a =
                    !(a.options3d && a.options3d.enabled && b) &&
                    (b || w || L || H(s));
                }
                a
                  ? ((a = s.chart.options.accessibility),
                    (b = a.landmarkVerbosity),
                    (s.options.accessibility || {}).exposeAsGroupOnly
                      ? r.setAttribute("role", "img")
                      : b === "all"
                      ? r.setAttribute("role", "region")
                      : r.setAttribute("role", "group"),
                    r.setAttribute("tabindex", "-1"),
                    s.chart.styledMode || (r.style.outline = "none"),
                    r.setAttribute(
                      "aria-label",
                      v(
                        (a.series.descriptionFormatter &&
                          a.series.descriptionFormatter(s)) ||
                          n(s)
                      )
                    ))
                  : r.removeAttribute("aria-label");
              }
            },
          };
        }
      ),
      T(
        k,
        "Accessibility/Components/SeriesComponent/NewDataAnnouncer.js",
        [
          k["Core/Globals.js"],
          k["Core/Utilities.js"],
          k["Accessibility/Utils/Announcer.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/EventProvider.js"],
          k["Accessibility/Components/SeriesComponent/SeriesDescriber.js"],
        ],
        function (y, A, O, F, G, U) {
          function H(u) {
            const n = u.series.data.filter((d) => u.x === d.x && u.y === d.y);
            return n.length === 1 ? n[0] : u;
          }
          function Y(u, n) {
            const d = (u || [])
              .concat(n || [])
              .reduce((g, M) => ((g[M.name + M.index] = M), g), {});
            return Object.keys(d).map((g) => d[g]);
          }
          const { addEvent: S, defined: N } = A,
            { getChartTitle: D } = F,
            {
              defaultPointDescriptionFormatter: c,
              defaultSeriesDescriptionFormatter: p,
            } = U;
          class f {
            constructor(n) {
              (this.announcer = void 0),
                (this.dirty = { allSeries: {} }),
                (this.eventProvider = void 0),
                (this.lastAnnouncementTime = 0),
                (this.chart = n);
            }
            init() {
              const n = this.chart,
                d = n.options.accessibility.announceNewData.interruptUser
                  ? "assertive"
                  : "polite";
              (this.lastAnnouncementTime = 0),
                (this.dirty = { allSeries: {} }),
                (this.eventProvider = new G()),
                (this.announcer = new O(n, d)),
                this.addEventListeners();
            }
            destroy() {
              this.eventProvider.removeAddedEvents(), this.announcer.destroy();
            }
            addEventListeners() {
              const n = this,
                d = this.chart,
                g = this.eventProvider;
              g.addEvent(d, "afterApplyDrilldown", function () {
                n.lastAnnouncementTime = 0;
              }),
                g.addEvent(d, "afterAddSeries", function (M) {
                  n.onSeriesAdded(M.series);
                }),
                g.addEvent(d, "redraw", function () {
                  n.announceDirtyData();
                });
            }
            onSeriesAdded(n) {
              this.chart.options.accessibility.announceNewData.enabled &&
                ((this.dirty.hasDirty = !0),
                (this.dirty.allSeries[n.name + n.index] = n),
                (this.dirty.newSeries = N(this.dirty.newSeries) ? void 0 : n));
            }
            announceDirtyData() {
              const n = this;
              if (
                this.chart.options.accessibility.announceNewData &&
                this.dirty.hasDirty
              ) {
                let d = this.dirty.newPoint;
                d && (d = H(d)),
                  this.queueAnnouncement(
                    Object.keys(this.dirty.allSeries).map(
                      (g) => n.dirty.allSeries[g]
                    ),
                    this.dirty.newSeries,
                    d
                  ),
                  (this.dirty = { allSeries: {} });
              }
            }
            queueAnnouncement(n, d, g) {
              var M = this.chart.options.accessibility.announceNewData;
              if (M.enabled) {
                const C = +new Date();
                (M = Math.max(
                  0,
                  M.minAnnounceInterval - (C - this.lastAnnouncementTime)
                )),
                  (n = Y(
                    this.queuedAnnouncement && this.queuedAnnouncement.series,
                    n
                  )),
                  (d = this.buildAnnouncementMessage(n, d, g)) &&
                    (this.queuedAnnouncement &&
                      clearTimeout(this.queuedAnnouncementTimer),
                    (this.queuedAnnouncement = {
                      time: C,
                      message: d,
                      series: n,
                    }),
                    (this.queuedAnnouncementTimer = setTimeout(() => {
                      this &&
                        this.announcer &&
                        ((this.lastAnnouncementTime = +new Date()),
                        this.announcer.announce(
                          this.queuedAnnouncement.message
                        ),
                        delete this.queuedAnnouncement,
                        delete this.queuedAnnouncementTimer);
                    }, M)));
              }
            }
            buildAnnouncementMessage(n, d, g) {
              const M = this.chart;
              var C = M.options.accessibility.announceNewData;
              return C.announcementFormatter &&
                ((n = C.announcementFormatter(n, d, g)), n !== !1)
                ? n.length
                  ? n
                  : null
                : ((n =
                    y.charts && 1 < y.charts.length ? "Multiple" : "Single"),
                  (n = d
                    ? "newSeriesAnnounce" + n
                    : g
                    ? "newPointAnnounce" + n
                    : "newDataAnnounce"),
                  (C = D(M)),
                  M.langFormat("accessibility.announceNewData." + n, {
                    chartTitle: C,
                    seriesDesc: d ? p(d) : null,
                    pointDesc: g ? c(g) : null,
                    point: g,
                    series: d,
                  }));
            }
          }
          return (
            (function (u) {
              function n(g) {
                const M = this.chart,
                  C = this.newDataAnnouncer;
                C &&
                  C.chart === M &&
                  M.options.accessibility.announceNewData.enabled &&
                  (C.dirty.newPoint = N(C.dirty.newPoint) ? void 0 : g.point);
              }
              function d() {
                const g = this.chart,
                  M = this.newDataAnnouncer;
                M &&
                  M.chart === g &&
                  g.options.accessibility.announceNewData.enabled &&
                  ((M.dirty.hasDirty = !0),
                  (M.dirty.allSeries[this.name + this.index] = this));
              }
              (u.composedMembers = []),
                (u.compose = function (g) {
                  A.pushUnique(u.composedMembers, g) &&
                    (S(g, "addPoint", n), S(g, "updatedData", d));
                });
            })(f || (f = {})),
            f
          );
        }
      ),
      T(
        k,
        "Accessibility/ProxyElement.js",
        [
          k["Core/Globals.js"],
          k["Core/Utilities.js"],
          k["Accessibility/Utils/EventProvider.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
        ],
        function (y, A, O, F, G) {
          const { doc: U } = y,
            { attr: H, css: Y, merge: S } = A,
            { fireEventOnWrappedOrUnwrappedElement: N } = F,
            {
              cloneMouseEvent: D,
              cloneTouchEvent: c,
              getFakeMouseEvent: p,
              removeElement: f,
            } = G;
          class u {
            constructor(d, g, M, C) {
              (this.chart = d),
                (this.target = g),
                (this.groupType = M),
                (M = M === "ul"),
                (this.eventProvider = new O());
              const P = M ? U.createElement("li") : null,
                j = (this.buttonElement = U.createElement("button"));
              d.styledMode || this.hideButtonVisually(j),
                P
                  ? (M && !d.styledMode && (P.style.listStyle = "none"),
                    P.appendChild(j),
                    (this.element = P))
                  : (this.element = j),
                this.updateTarget(g, C);
            }
            click() {
              var d = this.getTargetPosition();
              (d.x += d.width / 2),
                (d.y += d.height / 2),
                (d = p("click", d)),
                N(this.target.click, d);
            }
            updateTarget(d, g) {
              (this.target = d), this.updateCSSClassName();
              const M = g || {};
              Object.keys(M).forEach((C) => {
                M[C] === null && delete M[C];
              }),
                H(
                  this.buttonElement,
                  S(
                    { "aria-label": this.getTargetAttr(d.click, "aria-label") },
                    M
                  )
                ),
                this.eventProvider.removeAddedEvents(),
                this.addProxyEventsToButton(this.buttonElement, d.click),
                this.refreshPosition();
            }
            refreshPosition() {
              const d = this.getTargetPosition();
              Y(this.buttonElement, {
                width: (d.width || 1) + "px",
                height: (d.height || 1) + "px",
                left: (Math.round(d.x) || 0) + "px",
                top: (Math.round(d.y) || 0) + "px",
              });
            }
            remove() {
              this.eventProvider.removeAddedEvents(), f(this.element);
            }
            updateCSSClassName() {
              var d = this.chart.legend;
              (d = d.group && d.group.div),
                (d =
                  -1 <
                  ((d && d.className) || "").indexOf("highcharts-no-tooltip"));
              const g =
                -1 <
                (this.getTargetAttr(this.target.click, "class") || "").indexOf(
                  "highcharts-no-tooltip"
                );
              this.buttonElement.className =
                d || g
                  ? "highcharts-a11y-proxy-button highcharts-no-tooltip"
                  : "highcharts-a11y-proxy-button";
            }
            addProxyEventsToButton(d, g) {
              "click touchstart touchend touchcancel touchmove mouseover mouseenter mouseleave mouseout"
                .split(" ")
                .forEach((M) => {
                  const C = M.indexOf("touch") === 0;
                  this.eventProvider.addEvent(
                    d,
                    M,
                    (P) => {
                      const j = C ? c(P) : D(P);
                      g && N(g, j),
                        P.stopPropagation(),
                        C || P.preventDefault();
                    },
                    { passive: !1 }
                  );
                });
            }
            hideButtonVisually(d) {
              Y(d, {
                borderWidth: 0,
                backgroundColor: "transparent",
                cursor: "pointer",
                outline: "none",
                opacity: 0.001,
                filter: "alpha(opacity=1)",
                zIndex: 999,
                overflow: "hidden",
                padding: 0,
                margin: 0,
                display: "block",
                position: "absolute",
                "-ms-filter":
                  "progid:DXImageTransform.Microsoft.Alpha(Opacity=1)",
              });
            }
            getTargetPosition() {
              var d = this.target.click;
              if (
                ((d = d.element ? d.element : d),
                (d = this.target.visual || d),
                this.chart.renderTo && d && d.getBoundingClientRect)
              ) {
                d = d.getBoundingClientRect();
                const g = this.chart.pointer.getChartPosition();
                return {
                  x: (d.left - g.left) / g.scaleX,
                  y: (d.top - g.top) / g.scaleY,
                  width: d.right / g.scaleX - d.left / g.scaleX,
                  height: d.bottom / g.scaleY - d.top / g.scaleY,
                };
              }
              return { x: 0, y: 0, width: 1, height: 1 };
            }
            getTargetAttr(d, g) {
              return d.element ? d.element.getAttribute(g) : d.getAttribute(g);
            }
          }
          return u;
        }
      ),
      T(
        k,
        "Accessibility/ProxyProvider.js",
        [
          k["Core/Globals.js"],
          k["Core/Utilities.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/DOMElementProvider.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Accessibility/ProxyElement.js"],
        ],
        function (y, A, O, F, G, U) {
          const { doc: H } = y,
            { attr: Y, css: S } = A,
            { unhideChartElementFromAT: N } = O,
            { removeElement: D, removeChildNodes: c } = G;
          class p {
            constructor(u) {
              (this.chart = u),
                (this.domElementProvider = new F()),
                (this.groups = {}),
                (this.groupOrder = []),
                (this.beforeChartProxyPosContainer =
                  this.createProxyPosContainer("before")),
                (this.afterChartProxyPosContainer =
                  this.createProxyPosContainer("after")),
                this.update();
            }
            addProxyElement(u, n, d) {
              const g = this.groups[u];
              if (!g)
                throw Error(
                  "ProxyProvider.addProxyElement: Invalid group key " + u
                );
              return (
                (u = new U(this.chart, n, g.type, d)),
                g.proxyContainerElement.appendChild(u.element),
                g.proxyElements.push(u),
                u
              );
            }
            addGroup(u, n, d) {
              var g = this.groups[u];
              if (g) return g.groupElement;
              g = this.domElementProvider.createElement(n);
              let M;
              return (
                d && d.role && n !== "div"
                  ? ((M = this.domElementProvider.createElement("div")),
                    M.appendChild(g))
                  : (M = g),
                (M.className =
                  "highcharts-a11y-proxy-group highcharts-a11y-proxy-group-" +
                  u.replace(/\W/g, "-")),
                (this.groups[u] = {
                  proxyContainerElement: g,
                  groupElement: M,
                  type: n,
                  proxyElements: [],
                }),
                Y(M, d || {}),
                n === "ul" && g.setAttribute("role", "list"),
                this.afterChartProxyPosContainer.appendChild(M),
                this.updateGroupOrder(this.groupOrder),
                M
              );
            }
            updateGroupAttrs(u, n) {
              const d = this.groups[u];
              if (!d)
                throw Error(
                  "ProxyProvider.updateGroupAttrs: Invalid group key " + u
                );
              Y(d.groupElement, n);
            }
            updateGroupOrder(u) {
              if (
                ((this.groupOrder = u.slice()), !this.isDOMOrderGroupOrder())
              ) {
                var n = u.indexOf("series"),
                  d = -1 < n ? u.slice(0, n) : u,
                  g = -1 < n ? u.slice(n + 1) : [];
                (u = H.activeElement),
                  ["before", "after"].forEach((M) => {
                    const C =
                      this[
                        M === "before"
                          ? "beforeChartProxyPosContainer"
                          : "afterChartProxyPosContainer"
                      ];
                    (M = M === "before" ? d : g),
                      c(C),
                      M.forEach((P) => {
                        (P = this.groups[P]) && C.appendChild(P.groupElement);
                      });
                  }),
                  (this.beforeChartProxyPosContainer.contains(u) ||
                    this.afterChartProxyPosContainer.contains(u)) &&
                    u &&
                    u.focus &&
                    u.focus();
              }
            }
            clearGroup(u) {
              const n = this.groups[u];
              if (!n)
                throw Error("ProxyProvider.clearGroup: Invalid group key " + u);
              c(n.proxyContainerElement);
            }
            removeGroup(u) {
              const n = this.groups[u];
              n && (D(n.groupElement), delete this.groups[u]);
            }
            update() {
              this.updatePosContainerPositions(),
                this.updateGroupOrder(this.groupOrder),
                this.updateProxyElementPositions();
            }
            updateProxyElementPositions() {
              Object.keys(this.groups).forEach(
                this.updateGroupProxyElementPositions.bind(this)
              );
            }
            updateGroupProxyElementPositions(u) {
              (u = this.groups[u]) &&
                u.proxyElements.forEach((n) => n.refreshPosition());
            }
            destroy() {
              this.domElementProvider.destroyCreatedElements();
            }
            createProxyPosContainer(u) {
              const n = this.domElementProvider.createElement("div");
              return (
                n.setAttribute("aria-hidden", "false"),
                (n.className =
                  "highcharts-a11y-proxy-container" + (u ? "-" + u : "")),
                S(n, { top: "0", left: "0" }),
                this.chart.styledMode ||
                  ((n.style.whiteSpace = "nowrap"),
                  (n.style.position = "absolute")),
                n
              );
            }
            getCurrentGroupOrderInDOM() {
              const u = (g) => {
                const M = Object.keys(this.groups);
                let C = M.length;
                for (; C--; ) {
                  const P = M[C],
                    j = this.groups[P];
                  if (j && g === j.groupElement) return P;
                }
              };
              var n = (g) => {
                const M = [];
                g = g.children;
                for (let C = 0; C < g.length; ++C) {
                  const P = u(g[C]);
                  P && M.push(P);
                }
                return M;
              };
              const d = n(this.beforeChartProxyPosContainer);
              return (
                (n = n(this.afterChartProxyPosContainer)),
                d.push("series"),
                d.concat(n)
              );
            }
            isDOMOrderGroupOrder() {
              const u = this.getCurrentGroupOrderInDOM(),
                n = this.groupOrder.filter(
                  (g) => g === "series" || !!this.groups[g]
                );
              let d = u.length;
              if (d !== n.length) return !1;
              for (; d--; ) if (u[d] !== n[d]) return !1;
              return !0;
            }
            updatePosContainerPositions() {
              const u = this.chart;
              if (!u.renderer.forExport) {
                var n = u.renderer.box;
                u.container.insertBefore(
                  this.afterChartProxyPosContainer,
                  n.nextSibling
                ),
                  u.container.insertBefore(
                    this.beforeChartProxyPosContainer,
                    n
                  ),
                  N(this.chart, this.afterChartProxyPosContainer),
                  N(this.chart, this.beforeChartProxyPosContainer);
              }
            }
          }
          return p;
        }
      ),
      T(k, "Stock/RangeSelector/RangeSelectorDefaults.js", [], function () {
        return {
          lang: {
            rangeSelectorZoom: "Zoom",
            rangeSelectorFrom: "",
            rangeSelectorTo: "→",
          },
          rangeSelector: {
            allButtonsEnabled: !1,
            buttons: void 0,
            buttonSpacing: 5,
            dropdown: "responsive",
            enabled: void 0,
            verticalAlign: "top",
            buttonTheme: { width: 28, height: 18, padding: 2, zIndex: 7 },
            floating: !1,
            x: 0,
            y: 0,
            height: void 0,
            inputBoxBorderColor: "none",
            inputBoxHeight: 17,
            inputBoxWidth: void 0,
            inputDateFormat: "%e %b %Y",
            inputDateParser: void 0,
            inputEditDateFormat: "%Y-%m-%d",
            inputEnabled: !0,
            inputPosition: { align: "right", x: 0, y: 0 },
            inputSpacing: 5,
            selected: void 0,
            buttonPosition: { align: "left", x: 0, y: 0 },
            inputStyle: {
              color: "#334eff",
              cursor: "pointer",
              fontSize: "0.8em",
            },
            labelStyle: { color: "#666666", fontSize: "0.8em" },
          },
        };
      }),
      T(
        k,
        "Stock/RangeSelector/RangeSelectorComposition.js",
        [
          k["Core/Defaults.js"],
          k["Stock/RangeSelector/RangeSelectorDefaults.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O) {
          function F() {
            const h = this.range,
              v = h.type,
              l = this.max,
              o = this.chart.time,
              i = function (a, b) {
                const r = v === "year" ? "FullYear" : "Month",
                  w = new o.Date(a),
                  L = o.get(r, w);
                return (
                  o.set(r, w, L + b),
                  L === o.get(r, w) && o.set("Date", w, 0),
                  w.getTime() - a
                );
              };
            let t, e;
            g(h)
              ? ((t = l - h), (e = h))
              : h &&
                ((t = l + i(l, -(h.count || 1))),
                this.chart && (this.chart.fixedRange = l - t));
            const s = C(this.dataMin, Number.MIN_VALUE);
            return (
              g(t) || (t = s),
              t <= s &&
                ((t = s),
                typeof e > "u" && (e = i(t, h.count)),
                (this.newMax = Math.min(
                  t + e,
                  C(this.dataMax, Number.MAX_VALUE)
                ))),
              g(l)
                ? !g(h) && h && h._offsetMin && (t += h._offsetMin)
                : (t = void 0),
              t
            );
          }
          function G() {
            this.options.rangeSelector &&
              this.options.rangeSelector.enabled &&
              (this.rangeSelector = new m(this));
          }
          function U() {
            var h = this.axes;
            const v = this.rangeSelector;
            v &&
              (g(v.deferredYTDClick) &&
                (v.clickButton(v.deferredYTDClick), delete v.deferredYTDClick),
              h.forEach((l) => {
                l.updateNames(), l.setScale();
              }),
              this.getAxisMargins(),
              v.render(),
              (h = v.options.verticalAlign),
              v.options.floating ||
                (h === "bottom"
                  ? (this.extraBottomMargin = !0)
                  : h !== "middle" && (this.extraTopMargin = !0)));
          }
          function H(h) {
            let v, l, o, i;
            const t = h.rangeSelector,
              e = () => {
                t &&
                  ((v = h.xAxis[0].getExtremes()),
                  (l = h.legend),
                  (i = t && t.options.verticalAlign),
                  g(v.min) && t.render(v.min, v.max),
                  l.display &&
                    i === "top" &&
                    i === l.options.verticalAlign &&
                    ((o = M(h.spacingBox)),
                    (o.y =
                      l.options.layout === "vertical"
                        ? h.plotTop
                        : o.y + t.getHeight()),
                    (l.group.placed = !1),
                    l.align(o)));
              };
            t &&
              (d(P, (s) => s[0] === h) ||
                P.push([
                  h,
                  [
                    f(h.xAxis[0], "afterSetExtremes", function (s) {
                      t && t.render(s.min, s.max);
                    }),
                    f(h, "redraw", e),
                  ],
                ]),
              e());
          }
          function Y() {
            for (let h = 0, v = P.length; h < v; ++h) {
              const l = P[h];
              if (l[0] === this) {
                l[1].forEach((o) => o()), P.splice(h, 1);
                break;
              }
            }
          }
          function S() {
            var h = this.rangeSelector;
            h &&
              ((h = h.getHeight()),
              this.extraTopMargin && (this.plotTop += h),
              this.extraBottomMargin && (this.marginBottom += h));
          }
          function N() {
            var h = this.rangeSelector;
            h &&
              !h.options.floating &&
              (h.render(),
              (h = h.options.verticalAlign),
              h === "bottom"
                ? (this.extraBottomMargin = !0)
                : h !== "middle" && (this.extraTopMargin = !0));
          }
          function D(h) {
            var v = h.options.rangeSelector;
            h = this.extraBottomMargin;
            const l = this.extraTopMargin;
            let o = this.rangeSelector;
            v &&
              v.enabled &&
              !u(o) &&
              this.options.rangeSelector &&
              ((this.options.rangeSelector.enabled = !0),
              (this.rangeSelector = o = new m(this))),
              (this.extraTopMargin = this.extraBottomMargin = !1),
              o &&
                (H(this),
                (v =
                  (v && v.verticalAlign) ||
                  (o.options && o.options.verticalAlign)),
                o.options.floating ||
                  (v === "bottom"
                    ? (this.extraBottomMargin = !0)
                    : v !== "middle" && (this.extraTopMargin = !0)),
                this.extraBottomMargin !== h || this.extraTopMargin !== l) &&
                (this.isDirtyBox = !0);
          }
          const { defaultOptions: c, setOptions: p } = y,
            {
              addEvent: f,
              defined: u,
              extend: n,
              find: d,
              isNumber: g,
              merge: M,
              pick: C,
            } = O,
            P = [],
            j = [];
          let m;
          return {
            compose: function (h, v, l) {
              (m = l),
                O.pushUnique(j, h) && (h.prototype.minFromRange = F),
                O.pushUnique(j, v) &&
                  (f(v, "afterGetContainer", G),
                  f(v, "beforeRender", U),
                  f(v, "destroy", Y),
                  f(v, "getMargins", S),
                  f(v, "render", N),
                  f(v, "update", D),
                  v.prototype.callbacks.push(H)),
                O.pushUnique(j, p) &&
                  (n(c, { rangeSelector: A.rangeSelector }), n(c.lang, A.lang));
            },
          };
        }
      ),
      T(
        k,
        "Stock/RangeSelector/RangeSelector.js",
        [
          k["Core/Axis/Axis.js"],
          k["Core/Defaults.js"],
          k["Core/Globals.js"],
          k["Stock/RangeSelector/RangeSelectorComposition.js"],
          k["Core/Renderer/SVG/SVGElement.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O, F, G, U) {
          function H(v) {
            if (v.indexOf("%L") !== -1) return "text";
            const l = "aAdewbBmoyY"
                .split("")
                .some((i) => v.indexOf("%" + i) !== -1),
              o = "HkIlMS".split("").some((i) => v.indexOf("%" + i) !== -1);
            return l && o ? "datetime-local" : l ? "date" : o ? "time" : "text";
          }
          const { defaultOptions: Y } = A,
            {
              addEvent: S,
              createElement: N,
              css: D,
              defined: c,
              destroyObjectProperties: p,
              discardElement: f,
              extend: u,
              fireEvent: n,
              isNumber: d,
              merge: g,
              objectEach: M,
              pad: C,
              pick: P,
              pInt: j,
              splat: m,
            } = U;
          class h {
            static compose(l, o) {
              F.compose(l, o, h);
            }
            constructor(l) {
              (this.buttons = void 0),
                (this.buttonOptions = h.prototype.defaultButtons),
                (this.initialButtonGroupWidth = 0),
                (this.options = void 0),
                (this.chart = l),
                this.init(l);
            }
            clickButton(l, o) {
              const i = this.chart,
                t = this.buttonOptions[l],
                e = i.xAxis[0];
              var s = (i.scroller && i.scroller.getUnionExtremes()) || e || {},
                a = t.type;
              const b = t.dataGrouping;
              let r = s.dataMin,
                w = s.dataMax,
                L,
                I = e && Math.round(Math.min(e.max, P(w, e.max))),
                V;
              s = t._range;
              let B,
                x,
                R,
                W = !0;
              if (r !== null && w !== null) {
                if (
                  ((i.fixedRange = s),
                  this.setSelected(l),
                  b &&
                    ((this.forcedDataGrouping = !0),
                    y.prototype.setDataGrouping.call(
                      e || { chart: this.chart },
                      b,
                      !1
                    ),
                    (this.frozenStates = t.preserveDataGrouping)),
                  a === "month" || a === "year")
                )
                  e
                    ? ((a = {
                        range: t,
                        max: I,
                        chart: i,
                        dataMin: r,
                        dataMax: w,
                      }),
                      (L = e.minFromRange.call(a)),
                      d(a.newMax) && (I = a.newMax),
                      (W = !1))
                    : (s = t);
                else if (s)
                  (L = Math.max(I - s, r)), (I = Math.min(L + s, w)), (W = !1);
                else if (a === "ytd")
                  if (e)
                    (typeof w > "u" || typeof r > "u") &&
                      ((r = Number.MAX_VALUE),
                      (w = Number.MIN_VALUE),
                      i.series.forEach((X) => {
                        (X = X.xData) &&
                          ((r = Math.min(X[0], r)),
                          (w = Math.max(X[X.length - 1], w)));
                      }),
                      (o = !1)),
                      (a = this.getYTDExtremes(w, r, i.time.useUTC)),
                      (L = B = a.min),
                      (I = a.max);
                  else {
                    this.deferredYTDClick = l;
                    return;
                  }
                else
                  a === "all" &&
                    e &&
                    (i.navigator &&
                      i.navigator.baseSeries[0] &&
                      (i.navigator.baseSeries[0].xAxis.options.range = void 0),
                    (L = r),
                    (I = w));
                W && t._offsetMin && c(L) && (L += t._offsetMin),
                  t._offsetMax && c(I) && (I += t._offsetMax),
                  this.dropdown && (this.dropdown.selectedIndex = l + 1),
                  e
                    ? e.setExtremes(L, I, P(o, !0), void 0, {
                        trigger: "rangeSelectorButton",
                        rangeSelectorButton: t,
                      })
                    : ((V = m(i.options.xAxis)[0]),
                      (R = V.range),
                      (V.range = s),
                      (x = V.min),
                      (V.min = B),
                      S(i, "load", function () {
                        (V.range = R), (V.min = x);
                      })),
                  n(this, "afterBtnClick");
              }
            }
            setSelected(l) {
              this.selected = this.options.selected = l;
            }
            init(l) {
              const o = this,
                i = l.options.rangeSelector,
                t = i.buttons || o.defaultButtons.slice(),
                e = i.selected,
                s = function () {
                  const a = o.minInput,
                    b = o.maxInput;
                  a && a.blur && n(a, "blur"), b && b.blur && n(b, "blur");
                };
              (o.chart = l),
                (o.options = i),
                (o.buttons = []),
                (o.buttonOptions = t),
                (this.eventsToUnbind = []),
                this.eventsToUnbind.push(S(l.container, "mousedown", s)),
                this.eventsToUnbind.push(S(l, "resize", s)),
                t.forEach(o.computeButtonRange),
                typeof e < "u" && t[e] && this.clickButton(e, !1),
                this.eventsToUnbind.push(
                  S(l, "load", function () {
                    l.xAxis &&
                      l.xAxis[0] &&
                      S(l.xAxis[0], "setExtremes", function (a) {
                        this.max - this.min !== l.fixedRange &&
                          a.trigger !== "rangeSelectorButton" &&
                          a.trigger !== "updatedData" &&
                          o.forcedDataGrouping &&
                          !o.frozenStates &&
                          this.setDataGrouping(!1, !1);
                      });
                  })
                );
            }
            updateButtonStates() {
              const l = this;
              var o = this.chart;
              const i = this.dropdown,
                t = o.xAxis[0],
                e = Math.round(t.max - t.min),
                s = !t.hasVisibleSeries,
                a = (o.scroller && o.scroller.getUnionExtremes()) || t,
                b = a.dataMin,
                r = a.dataMax;
              o = l.getYTDExtremes(r, b, o.time.useUTC);
              const w = o.min,
                L = o.max,
                I = l.selected,
                V = l.options.allButtonsEnabled,
                B = l.buttons;
              let x = d(I);
              l.buttonOptions.forEach((R, W) => {
                var X = R._range,
                  Z = R.type,
                  E = R.count || 1;
                const _ = B[W],
                  z = R._offsetMax - R._offsetMin,
                  J = W === I,
                  tt = X > r - b,
                  $ = X < t.minRange;
                R = 0;
                let it = !1,
                  nt = !1;
                (X = X === e),
                  (Z === "month" || Z === "year") &&
                  e + 36e5 >= 864e5 * { month: 28, year: 365 }[Z] * E - z &&
                  e - 36e5 <= 864e5 * { month: 31, year: 366 }[Z] * E + z
                    ? (X = !0)
                    : Z === "ytd"
                    ? ((X = L - w + z === e), (it = !J))
                    : Z === "all" &&
                      ((X = t.max - t.min >= r - b), (nt = !J && x && X)),
                  (Z = !V && (tt || $ || nt || s)),
                  (E = (J && X) || (X && !x && !it) || (J && l.frozenStates)),
                  Z ? (R = 3) : E && ((x = !0), (R = 2)),
                  _.state !== R &&
                    (_.setState(R),
                    i &&
                      ((i.options[W + 1].disabled = Z),
                      R === 2 && (i.selectedIndex = W + 1)),
                    R === 0 && I === W && l.setSelected());
              });
            }
            computeButtonRange(l) {
              const o = l.type,
                i = l.count || 1,
                t = {
                  millisecond: 1,
                  second: 1e3,
                  minute: 6e4,
                  hour: 36e5,
                  day: 864e5,
                  week: 6048e5,
                };
              t[o]
                ? (l._range = t[o] * i)
                : (o === "month" || o === "year") &&
                  (l._range = 864e5 * { month: 30, year: 365 }[o] * i),
                (l._offsetMin = P(l.offsetMin, 0)),
                (l._offsetMax = P(l.offsetMax, 0)),
                (l._range += l._offsetMax - l._offsetMin);
            }
            getInputValue(l) {
              l = l === "min" ? this.minInput : this.maxInput;
              const o = this.chart.options.rangeSelector,
                i = this.chart.time;
              return l
                ? (
                    (l.type === "text" && o.inputDateParser) ||
                    this.defaultInputDateParser
                  )(l.value, i.useUTC, i)
                : 0;
            }
            setInputValue(l, o) {
              const i = this.options,
                t = this.chart.time,
                e = l === "min" ? this.minInput : this.maxInput;
              if (((l = l === "min" ? this.minDateBox : this.maxDateBox), e)) {
                var s = e.getAttribute("data-hc-time");
                (s = c(s) ? Number(s) : void 0),
                  c(o) &&
                    (c(s) && e.setAttribute("data-hc-time-previous", s),
                    e.setAttribute("data-hc-time", o),
                    (s = o)),
                  (e.value = t.dateFormat(
                    this.inputTypeFormats[e.type] || i.inputEditDateFormat,
                    s
                  )),
                  l && l.attr({ text: t.dateFormat(i.inputDateFormat, s) });
              }
            }
            setInputExtremes(l, o, i) {
              if ((l = l === "min" ? this.minInput : this.maxInput)) {
                const t = this.inputTypeFormats[l.type],
                  e = this.chart.time;
                t &&
                  ((o = e.dateFormat(t, o)),
                  l.min !== o && (l.min = o),
                  (i = e.dateFormat(t, i)),
                  l.max !== i && (l.max = i));
              }
            }
            showInput(l) {
              const o = l === "min" ? this.minDateBox : this.maxDateBox;
              if (
                (l = l === "min" ? this.minInput : this.maxInput) &&
                o &&
                this.inputGroup
              ) {
                const i = l.type === "text",
                  { translateX: t, translateY: e } = this.inputGroup,
                  { inputBoxWidth: s } = this.options;
                D(l, {
                  width: i ? o.width + (s ? -2 : 20) + "px" : "auto",
                  height: o.height - 2 + "px",
                  border: "2px solid silver",
                }),
                  i && s
                    ? D(l, { left: t + o.x + "px", top: e + "px" })
                    : D(l, {
                        left:
                          Math.min(
                            Math.round(o.x + t - (l.offsetWidth - o.width) / 2),
                            this.chart.chartWidth - l.offsetWidth
                          ) + "px",
                        top: e - (l.offsetHeight - o.height) / 2 + "px",
                      });
              }
            }
            hideInput(l) {
              (l = l === "min" ? this.minInput : this.maxInput) &&
                D(l, {
                  top: "-9999em",
                  border: 0,
                  width: "1px",
                  height: "1px",
                });
            }
            defaultInputDateParser(l, o, i) {
              var t = l.split("/").join("-").split(" ").join("T");
              if ((t.indexOf("T") === -1 && (t += "T00:00"), o)) t += "Z";
              else {
                var e;
                (e = O.isSafari) &&
                  ((e = t),
                  (e = !(
                    6 < e.length &&
                    (e.lastIndexOf("-") === e.length - 6 ||
                      e.lastIndexOf("+") === e.length - 6)
                  ))),
                  e &&
                    ((e = new Date(t).getTimezoneOffset() / 60),
                    (t += 0 >= e ? `+${C(-e)}:00` : `-${C(e)}:00`));
              }
              return (
                (t = Date.parse(t)),
                d(t) ||
                  ((l = l.split("-")),
                  (t = Date.UTC(j(l[0]), j(l[1]) - 1, j(l[2])))),
                i && o && d(t) && (t += i.getTimezoneOffset(t)),
                t
              );
            }
            drawInput(l) {
              function o() {
                const { maxInput: B, minInput: x } = s,
                  R = i.xAxis[0];
                var W = i.scroller && i.scroller.xAxis ? i.scroller.xAxis : R;
                const X = W.dataMin;
                W = W.dataMax;
                let Z = s.getInputValue(l);
                Z !== Number(I.getAttribute("data-hc-time-previous")) &&
                  d(Z) &&
                  (I.setAttribute("data-hc-time-previous", Z),
                  w && B && d(X)
                    ? Z > Number(B.getAttribute("data-hc-time"))
                      ? (Z = void 0)
                      : Z < X && (Z = X)
                    : x &&
                      d(W) &&
                      (Z < Number(x.getAttribute("data-hc-time"))
                        ? (Z = void 0)
                        : Z > W && (Z = W)),
                  typeof Z < "u" &&
                    R.setExtremes(
                      w ? Z : R.min,
                      w ? R.max : Z,
                      void 0,
                      void 0,
                      { trigger: "rangeSelectorInput" }
                    ));
              }
              const { chart: i, div: t, inputGroup: e } = this,
                s = this,
                a = i.renderer.style || {};
              var b = i.renderer;
              const r = i.options.rangeSelector,
                w = l === "min";
              var L = Y.lang[w ? "rangeSelectorFrom" : "rangeSelectorTo"] || "";
              (L = b
                .label(L, 0)
                .addClass("highcharts-range-label")
                .attr({ padding: L ? 2 : 0, height: L ? r.inputBoxHeight : 0 })
                .add(e)),
                (b = b
                  .label("", 0)
                  .addClass("highcharts-range-input")
                  .attr({
                    padding: 2,
                    width: r.inputBoxWidth,
                    height: r.inputBoxHeight,
                    "text-align": "center",
                  })
                  .on("click", function () {
                    s.showInput(l), s[l + "Input"].focus();
                  })),
                i.styledMode ||
                  b.attr({ stroke: r.inputBoxBorderColor, "stroke-width": 1 }),
                b.add(e);
              const I = N(
                "input",
                { name: l, className: "highcharts-range-selector" },
                void 0,
                t
              );
              I.setAttribute("type", H(r.inputDateFormat || "%e %b %Y")),
                i.styledMode ||
                  (L.css(g(a, r.labelStyle)),
                  b.css(g({ color: "#333333" }, a, r.inputStyle)),
                  D(
                    I,
                    u(
                      {
                        position: "absolute",
                        border: 0,
                        boxShadow: "0 0 15px rgba(0,0,0,0.3)",
                        width: "1px",
                        height: "1px",
                        padding: 0,
                        textAlign: "center",
                        fontSize: a.fontSize,
                        fontFamily: a.fontFamily,
                        top: "-9999em",
                      },
                      r.inputStyle
                    )
                  )),
                (I.onfocus = () => {
                  s.showInput(l);
                }),
                (I.onblur = () => {
                  I === O.doc.activeElement && o(),
                    s.hideInput(l),
                    s.setInputValue(l),
                    I.blur();
                });
              let V = !1;
              return (
                (I.onchange = () => {
                  V || (o(), s.hideInput(l), I.blur());
                }),
                (I.onkeypress = (B) => {
                  B.keyCode === 13 && o();
                }),
                (I.onkeydown = (B) => {
                  (V = !0), (B.keyCode !== 38 && B.keyCode !== 40) || o();
                }),
                (I.onkeyup = () => {
                  V = !1;
                }),
                { dateBox: b, input: I, label: L }
              );
            }
            getPosition() {
              var l = this.chart;
              const o = l.options.rangeSelector;
              return (
                (l =
                  o.verticalAlign === "top" ? l.plotTop - l.axisOffset[0] : 0),
                {
                  buttonTop: l + o.buttonPosition.y,
                  inputTop: l + o.inputPosition.y - 10,
                }
              );
            }
            getYTDExtremes(l, o, i) {
              const t = this.chart.time;
              var e = new t.Date(l);
              const s = t.get("FullYear", e);
              return (
                (i = i ? t.Date.UTC(s, 0, 1) : +new t.Date(s, 0, 1)),
                (o = Math.max(o, i)),
                (e = e.getTime()),
                { max: Math.min(l || e, e), min: o }
              );
            }
            render(l, o) {
              var i = this.chart,
                t = i.renderer;
              const e = i.container;
              var s = i.options;
              const a = s.rangeSelector,
                b = P(s.chart.style && s.chart.style.zIndex, 0) + 1;
              if (((s = a.inputEnabled), a.enabled !== !1)) {
                if (
                  (this.rendered ||
                    ((this.group = t
                      .g("range-selector-group")
                      .attr({ zIndex: 7 })
                      .add()),
                    (this.div = N("div", void 0, {
                      position: "relative",
                      height: 0,
                      zIndex: b,
                    })),
                    this.buttonOptions.length && this.renderButtons(),
                    e.parentNode && e.parentNode.insertBefore(this.div, e),
                    s &&
                      ((this.inputGroup = t.g("input-group").add(this.group)),
                      (t = this.drawInput("min")),
                      (this.minDateBox = t.dateBox),
                      (this.minLabel = t.label),
                      (this.minInput = t.input),
                      (t = this.drawInput("max")),
                      (this.maxDateBox = t.dateBox),
                      (this.maxLabel = t.label),
                      (this.maxInput = t.input))),
                  s &&
                    (this.setInputValue("min", l),
                    this.setInputValue("max", o),
                    (l =
                      (i.scroller && i.scroller.getUnionExtremes()) ||
                      i.xAxis[0] ||
                      {}),
                    c(l.dataMin) &&
                      c(l.dataMax) &&
                      ((i = i.xAxis[0].minRange || 0),
                      this.setInputExtremes(
                        "min",
                        l.dataMin,
                        Math.min(l.dataMax, this.getInputValue("max")) - i
                      ),
                      this.setInputExtremes(
                        "max",
                        Math.max(l.dataMin, this.getInputValue("min")) + i,
                        l.dataMax
                      )),
                    this.inputGroup))
                ) {
                  let r = 0;
                  [
                    this.minLabel,
                    this.minDateBox,
                    this.maxLabel,
                    this.maxDateBox,
                  ].forEach((w) => {
                    if (w) {
                      const { width: L } = w.getBBox();
                      L && (w.attr({ x: r }), (r += L + a.inputSpacing));
                    }
                  });
                }
                this.alignElements(), (this.rendered = !0);
              }
            }
            renderButtons() {
              const { buttons: l, chart: o, options: i } = this,
                t = Y.lang,
                e = o.renderer,
                s = g(i.buttonTheme),
                a = s && s.states,
                b = s.width || 28;
              delete s.width,
                delete s.states,
                (this.buttonGroup = e
                  .g("range-selector-buttons")
                  .add(this.group));
              const r = (this.dropdown = N(
                "select",
                void 0,
                {
                  position: "absolute",
                  width: "1px",
                  height: "1px",
                  padding: 0,
                  border: 0,
                  top: "-9999em",
                  cursor: "pointer",
                  opacity: 1e-4,
                },
                this.div
              ));
              S(r, "touchstart", () => {
                r.style.fontSize = "16px";
              }),
                [
                  [O.isMS ? "mouseover" : "mouseenter"],
                  [O.isMS ? "mouseout" : "mouseleave"],
                  ["change", "click"],
                ].forEach(([w, L]) => {
                  S(r, w, () => {
                    const I = l[this.currentButtonIndex()];
                    I && n(I.element, L || w);
                  });
                }),
                (this.zoomText = e
                  .label((t && t.rangeSelectorZoom) || "", 0)
                  .attr({
                    padding: i.buttonTheme.padding,
                    height: i.buttonTheme.height,
                    paddingLeft: 0,
                    paddingRight: 0,
                  })
                  .add(this.buttonGroup)),
                this.chart.styledMode ||
                  (this.zoomText.css(i.labelStyle),
                  (s["stroke-width"] = P(s["stroke-width"], 0))),
                N(
                  "option",
                  { textContent: this.zoomText.textStr, disabled: !0 },
                  void 0,
                  r
                ),
                this.buttonOptions.forEach((w, L) => {
                  N("option", { textContent: w.title || w.text }, void 0, r),
                    (l[L] = e
                      .button(
                        w.text,
                        0,
                        0,
                        (I) => {
                          const V = w.events && w.events.click;
                          let B;
                          V && (B = V.call(w, I)),
                            B !== !1 && this.clickButton(L),
                            (this.isActive = !0);
                        },
                        s,
                        a && a.hover,
                        a && a.select,
                        a && a.disabled
                      )
                      .attr({ "text-align": "center", width: b })
                      .add(this.buttonGroup)),
                    w.title && l[L].attr("title", w.title);
                });
            }
            alignElements() {
              const {
                buttonGroup: l,
                buttons: o,
                chart: i,
                group: t,
                inputGroup: e,
                options: s,
                zoomText: a,
              } = this;
              var b = i.options;
              const r =
                  b.exporting &&
                  b.exporting.enabled !== !1 &&
                  b.navigation &&
                  b.navigation.buttonOptions,
                { buttonPosition: w, inputPosition: L, verticalAlign: I } = s;
              b = (R, W) =>
                r &&
                this.titleCollision(i) &&
                I === "top" &&
                W.align === "right" &&
                W.y - R.getBBox().height - 12 <
                  (r.y || 0) + (r.height || 0) + i.spacing[0]
                  ? -40
                  : 0;
              var V = i.plotLeft;
              if (t && w && L) {
                var B = w.x - i.spacing[3];
                if (l) {
                  if ((this.positionButtons(), !this.initialButtonGroupWidth)) {
                    let Z = 0;
                    a && (Z += a.getBBox().width + 5),
                      o.forEach((E, _) => {
                        (Z += E.width),
                          _ !== o.length - 1 && (Z += s.buttonSpacing);
                      }),
                      (this.initialButtonGroupWidth = Z);
                  }
                  (V -= i.spacing[3]), this.updateButtonStates();
                  var x = b(l, w);
                  this.alignButtonGroup(x), (t.placed = l.placed = i.hasLoaded);
                }
                (x = 0),
                  e &&
                    ((x = b(e, L)),
                    L.align === "left"
                      ? (B = V)
                      : L.align === "right" &&
                        (B = -Math.max(i.axisOffset[1], -x)),
                    e.align(
                      {
                        y: L.y,
                        width: e.getBBox().width,
                        align: L.align,
                        x: L.x + B - 2,
                      },
                      !0,
                      i.spacingBox
                    ),
                    (e.placed = i.hasLoaded)),
                  this.handleCollision(x),
                  t.align({ verticalAlign: I }, !0, i.spacingBox),
                  (b = t.alignAttr.translateY),
                  (V = t.getBBox().height + 20),
                  (B = 0),
                  I === "bottom" &&
                    ((B =
                      (B = i.legend && i.legend.options) &&
                      B.verticalAlign === "bottom" &&
                      B.enabled &&
                      !B.floating
                        ? i.legend.legendHeight + P(B.margin, 10)
                        : 0),
                    (V = V + B - 20),
                    (B =
                      b -
                      V -
                      (s.floating ? 0 : s.y) -
                      (i.titleOffset ? i.titleOffset[2] : 0) -
                      10)),
                  I === "top"
                    ? (s.floating && (B = 0),
                      i.titleOffset &&
                        i.titleOffset[0] &&
                        (B = i.titleOffset[0]),
                      (B += i.margin[0] - i.spacing[0] || 0))
                    : I === "middle" &&
                      (L.y === w.y
                        ? (B = b)
                        : (L.y || w.y) &&
                          (B =
                            0 > L.y || 0 > w.y
                              ? B - Math.min(L.y, w.y)
                              : b - V)),
                  t.translate(s.x, s.y + Math.floor(B));
                const { minInput: R, maxInput: W, dropdown: X } = this;
                s.inputEnabled &&
                  R &&
                  W &&
                  ((R.style.marginTop = t.translateY + "px"),
                  (W.style.marginTop = t.translateY + "px")),
                  X && (X.style.marginTop = t.translateY + "px");
              }
            }
            alignButtonGroup(l, o) {
              const { chart: i, options: t, buttonGroup: e } = this,
                { buttonPosition: s } = t,
                a = i.plotLeft - i.spacing[3];
              let b = s.x - i.spacing[3];
              s.align === "right"
                ? (b += l - a)
                : s.align === "center" && (b -= a / 2),
                e &&
                  e.align(
                    {
                      y: s.y,
                      width: P(o, this.initialButtonGroupWidth),
                      align: s.align,
                      x: b,
                    },
                    !0,
                    i.spacingBox
                  );
            }
            positionButtons() {
              const { buttons: l, chart: o, options: i, zoomText: t } = this,
                e = o.hasLoaded ? "animate" : "attr",
                { buttonPosition: s } = i,
                a = o.plotLeft;
              let b = a;
              t &&
                t.visibility !== "hidden" &&
                (t[e]({ x: P(a + s.x, a) }),
                (b += s.x + t.getBBox().width + 5));
              for (let r = 0, w = this.buttonOptions.length; r < w; ++r)
                l[r].visibility !== "hidden"
                  ? (l[r][e]({ x: b }), (b += l[r].width + i.buttonSpacing))
                  : l[r][e]({ x: a });
            }
            handleCollision(l) {
              const { chart: o, buttonGroup: i, inputGroup: t } = this,
                {
                  buttonPosition: e,
                  dropdown: s,
                  inputPosition: a,
                } = this.options,
                b = () => {
                  let L = 0;
                  return (
                    this.buttons.forEach((I) => {
                      (I = I.getBBox()), I.width > L && (L = I.width);
                    }),
                    L
                  );
                },
                r = (L) => {
                  if (t && i) {
                    const I =
                        t.alignAttr.translateX +
                        t.alignOptions.x -
                        l +
                        t.getBBox().x +
                        2,
                      V = t.alignOptions.width,
                      B = i.alignAttr.translateX + i.getBBox().x;
                    return (
                      B + L > I && I + V > B && e.y < a.y + t.getBBox().height
                    );
                  }
                  return !1;
                },
                w = () => {
                  t &&
                    i &&
                    t.attr({
                      translateX:
                        t.alignAttr.translateX +
                        (o.axisOffset[1] >= -l ? 0 : -l),
                      translateY:
                        t.alignAttr.translateY + i.getBBox().height + 10,
                    });
                };
              if (i) {
                if (s === "always") {
                  this.collapseButtons(l), r(b()) && w();
                  return;
                }
                s === "never" && this.expandButtons();
              }
              t && i
                ? a.align === e.align || r(this.initialButtonGroupWidth + 20)
                  ? s === "responsive"
                    ? (this.collapseButtons(l), r(b()) && w())
                    : w()
                  : s === "responsive" && this.expandButtons()
                : i &&
                  s === "responsive" &&
                  (this.initialButtonGroupWidth > o.plotWidth
                    ? this.collapseButtons(l)
                    : this.expandButtons());
            }
            collapseButtons(l) {
              const {
                  buttons: o,
                  buttonOptions: i,
                  chart: t,
                  dropdown: e,
                  options: s,
                  zoomText: a,
                } = this,
                b =
                  (t.userOptions.rangeSelector &&
                    t.userOptions.rangeSelector.buttonTheme) ||
                  {},
                r = (I) => ({
                  text: I ? `${I} ▾` : "▾",
                  width: "auto",
                  paddingLeft: P(s.buttonTheme.paddingLeft, b.padding, 8),
                  paddingRight: P(s.buttonTheme.paddingRight, b.padding, 8),
                });
              a && a.hide();
              let w = !1;
              i.forEach((I, V) => {
                (V = o[V]),
                  V.state !== 2
                    ? V.hide()
                    : (V.show(), V.attr(r(I.text)), (w = !0));
              }),
                w ||
                  (e && (e.selectedIndex = 0),
                  o[0].show(),
                  o[0].attr(r(this.zoomText && this.zoomText.textStr)));
              const { align: L } = s.buttonPosition;
              this.positionButtons(),
                (L !== "right" && L !== "center") ||
                  this.alignButtonGroup(
                    l,
                    o[this.currentButtonIndex()].getBBox().width
                  ),
                this.showDropdown();
            }
            expandButtons() {
              const {
                buttons: l,
                buttonOptions: o,
                options: i,
                zoomText: t,
              } = this;
              this.hideDropdown(),
                t && t.show(),
                o.forEach((e, s) => {
                  (s = l[s]),
                    s.show(),
                    s.attr({
                      text: e.text,
                      width: i.buttonTheme.width || 28,
                      paddingLeft: P(i.buttonTheme.paddingLeft, "unset"),
                      paddingRight: P(i.buttonTheme.paddingRight, "unset"),
                    }),
                    2 > s.state && s.setState(0);
                }),
                this.positionButtons();
            }
            currentButtonIndex() {
              const { dropdown: l } = this;
              return l && 0 < l.selectedIndex ? l.selectedIndex - 1 : 0;
            }
            showDropdown() {
              const {
                buttonGroup: l,
                buttons: o,
                chart: i,
                dropdown: t,
              } = this;
              if (l && t) {
                const { translateX: e, translateY: s } = l,
                  a = o[this.currentButtonIndex()].getBBox();
                D(t, {
                  left: i.plotLeft + e + "px",
                  top: s + 0.5 + "px",
                  width: a.width + "px",
                  height: a.height + "px",
                }),
                  (this.hasVisibleDropdown = !0);
              }
            }
            hideDropdown() {
              const { dropdown: l } = this;
              l &&
                (D(l, { top: "-9999em", width: "1px", height: "1px" }),
                (this.hasVisibleDropdown = !1));
            }
            getHeight() {
              var l = this.options,
                o = this.group;
              const i = l.y,
                t = l.buttonPosition.y,
                e = l.inputPosition.y;
              return l.height
                ? l.height
                : (this.alignElements(),
                  (l = o ? o.getBBox(!0).height + 13 + i : 0),
                  (o = Math.min(e, t)),
                  ((0 > e && 0 > t) || (0 < e && 0 < t)) && (l += Math.abs(o)),
                  l);
            }
            titleCollision(l) {
              return !(l.options.title.text || l.options.subtitle.text);
            }
            update(l) {
              const o = this.chart;
              g(!0, o.options.rangeSelector, l),
                this.destroy(),
                this.init(o),
                this.render();
            }
            destroy() {
              const l = this,
                o = l.minInput,
                i = l.maxInput;
              l.eventsToUnbind &&
                (l.eventsToUnbind.forEach((t) => t()),
                (l.eventsToUnbind = void 0)),
                p(l.buttons),
                o && (o.onfocus = o.onblur = o.onchange = null),
                i && (i.onfocus = i.onblur = i.onchange = null),
                M(
                  l,
                  function (t, e) {
                    t &&
                      e !== "chart" &&
                      (t instanceof G
                        ? t.destroy()
                        : t instanceof window.HTMLElement && f(t)),
                      t !== h.prototype[e] && (l[e] = null);
                  },
                  this
                );
            }
          }
          return (
            u(h.prototype, {
              defaultButtons: [
                { type: "month", count: 1, text: "1m", title: "View 1 month" },
                { type: "month", count: 3, text: "3m", title: "View 3 months" },
                { type: "month", count: 6, text: "6m", title: "View 6 months" },
                { type: "ytd", text: "YTD", title: "View year to date" },
                { type: "year", count: 1, text: "1y", title: "View 1 year" },
                { type: "all", text: "All", title: "View all" },
              ],
              inputTypeFormats: {
                "datetime-local": "%Y-%m-%dT%H:%M:%S",
                date: "%Y-%m-%d",
                time: "%H:%M:%S",
              },
            }),
            h
          );
        }
      ),
      T(
        k,
        "Accessibility/Components/RangeSelectorComponent.js",
        [
          k["Stock/RangeSelector/RangeSelector.js"],
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/Announcer.js"],
          k["Accessibility/KeyboardNavigationHandler.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O, F, G, U) {
          const { unhideChartElementFromAT: H, getAxisRangeDescription: Y } = O,
            { addEvent: S, attr: N } = U;
          class D extends A {
            constructor() {
              super(...arguments), (this.announcer = void 0);
            }
            init() {
              this.announcer = new F(this.chart, "polite");
            }
            onChartUpdate() {
              const p = this.chart,
                f = this,
                u = p.rangeSelector;
              u &&
                (this.updateSelectorVisibility(),
                this.setDropdownAttrs(),
                u.buttons &&
                  u.buttons.length &&
                  u.buttons.forEach((n) => {
                    f.setRangeButtonAttrs(n);
                  }),
                u.maxInput &&
                  u.minInput &&
                  ["minInput", "maxInput"].forEach(function (n, d) {
                    (n = u[n]) &&
                      (H(p, n),
                      f.setRangeInputAttrs(
                        n,
                        "accessibility.rangeSelector." +
                          (d ? "max" : "min") +
                          "InputLabel"
                      ));
                  }));
            }
            updateSelectorVisibility() {
              const p = this.chart,
                f = p.rangeSelector,
                u = f && f.dropdown,
                n = (f && f.buttons) || [];
              f && f.hasVisibleDropdown && u
                ? (H(p, u),
                  n.forEach((d) => d.element.setAttribute("aria-hidden", !0)))
                : (u && u.setAttribute("aria-hidden", !0),
                  n.forEach((d) => H(p, d.element)));
            }
            setDropdownAttrs() {
              var p = this.chart;
              const f = p.rangeSelector && p.rangeSelector.dropdown;
              f &&
                ((p = p.langFormat(
                  "accessibility.rangeSelector.dropdownLabel",
                  { rangeTitle: p.options.lang.rangeSelectorZoom }
                )),
                f.setAttribute("aria-label", p),
                f.setAttribute("tabindex", -1));
            }
            setRangeButtonAttrs(p) {
              N(p.element, { tabindex: -1, role: "button" });
            }
            setRangeInputAttrs(p, f) {
              const u = this.chart;
              N(p, {
                tabindex: -1,
                "aria-label": u.langFormat(f, { chart: u }),
              });
            }
            onButtonNavKbdArrowKey(p, f) {
              const u = p.response,
                n = this.keyCodes,
                d = this.chart,
                g = d.options.accessibility.keyboardNavigation.wrapAround;
              return (
                (f = f === n.left || f === n.up ? -1 : 1),
                d.highlightRangeSelectorButton(
                  d.highlightedRangeSelectorItemIx + f
                )
                  ? u.success
                  : g
                  ? (p.init(f), u.success)
                  : u[0 < f ? "next" : "prev"]
              );
            }
            onButtonNavKbdClick(p) {
              p = p.response;
              const f = this.chart;
              return (
                f.oldRangeSelectorItemState !== 3 &&
                  this.fakeClickEvent(
                    f.rangeSelector.buttons[f.highlightedRangeSelectorItemIx]
                      .element
                  ),
                p.success
              );
            }
            onAfterBtnClick() {
              var p = this.chart;
              const f = Y(p.xAxis[0]);
              (p = p.langFormat(
                "accessibility.rangeSelector.clickButtonAnnouncement",
                { chart: p, axisRangeDescription: f }
              )) && this.announcer.announce(p);
            }
            onInputKbdMove(p) {
              const f = this.chart;
              var u = f.rangeSelector;
              const n = (f.highlightedInputRangeIx =
                (f.highlightedInputRangeIx || 0) + p);
              if (1 < n || 0 > n) {
                if (f.accessibility)
                  return (
                    (f.accessibility.keyboardNavigation.exiting = !0),
                    f.accessibility.keyboardNavigation.tabindexContainer.focus(),
                    f.accessibility.keyboardNavigation.move(p)
                  );
              } else
                u &&
                  ((p = u[n ? "maxDateBox" : "minDateBox"]),
                  (u = u[n ? "maxInput" : "minInput"]),
                  p && u && f.setFocusToElement(p, u));
              return !0;
            }
            onInputNavInit(p) {
              const f = this;
              var u = this.chart;
              const n = 0 < p ? 0 : 1;
              var d = u.rangeSelector;
              const g = d && d[n ? "maxDateBox" : "minDateBox"];
              if (
                ((p = d && d.minInput),
                (d = d && d.maxInput),
                (u.highlightedInputRangeIx = n),
                g && p && d)
              ) {
                u.setFocusToElement(g, n ? d : p),
                  this.removeInputKeydownHandler &&
                    this.removeInputKeydownHandler(),
                  (u = (P) => {
                    (P.which || P.keyCode) === this.keyCodes.tab &&
                      f.onInputKbdMove(P.shiftKey ? -1 : 1) &&
                      (P.preventDefault(), P.stopPropagation());
                  });
                const M = S(p, "keydown", u),
                  C = S(d, "keydown", u);
                this.removeInputKeydownHandler = () => {
                  M(), C();
                };
              }
            }
            onInputNavTerminate() {
              const p = this.chart.rangeSelector || {};
              p.maxInput && p.hideInput("max"),
                p.minInput && p.hideInput("min"),
                this.removeInputKeydownHandler &&
                  (this.removeInputKeydownHandler(),
                  delete this.removeInputKeydownHandler);
            }
            initDropdownNav() {
              const p = this.chart,
                f = p.rangeSelector,
                u = f && f.dropdown;
              f &&
                u &&
                (p.setFocusToElement(f.buttonGroup, u),
                this.removeDropdownKeydownHandler &&
                  this.removeDropdownKeydownHandler(),
                (this.removeDropdownKeydownHandler = S(u, "keydown", (n) => {
                  const d = p.accessibility;
                  (n.which || n.keyCode) === this.keyCodes.tab &&
                    (n.preventDefault(),
                    n.stopPropagation(),
                    d &&
                      (d.keyboardNavigation.tabindexContainer.focus(),
                      d.keyboardNavigation.move(n.shiftKey ? -1 : 1)));
                })));
            }
            getRangeSelectorButtonNavigation() {
              const p = this.chart,
                f = this.keyCodes,
                u = this;
              return new G(p, {
                keyCodeMap: [
                  [
                    [f.left, f.right, f.up, f.down],
                    function (n) {
                      return u.onButtonNavKbdArrowKey(this, n);
                    },
                  ],
                  [
                    [f.enter, f.space],
                    function () {
                      return u.onButtonNavKbdClick(this);
                    },
                  ],
                ],
                validate: function () {
                  return !!(
                    p.rangeSelector &&
                    p.rangeSelector.buttons &&
                    p.rangeSelector.buttons.length
                  );
                },
                init: function (n) {
                  var d = p.rangeSelector;
                  d && d.hasVisibleDropdown
                    ? u.initDropdownNav()
                    : d &&
                      ((d = d.buttons.length - 1),
                      p.highlightRangeSelectorButton(0 < n ? 0 : d));
                },
                terminate: function () {
                  u.removeDropdownKeydownHandler &&
                    (u.removeDropdownKeydownHandler(),
                    delete u.removeDropdownKeydownHandler);
                },
              });
            }
            getRangeSelectorInputNavigation() {
              const p = this.chart,
                f = this;
              return new G(p, {
                keyCodeMap: [],
                validate: function () {
                  return !!(
                    p.rangeSelector &&
                    p.rangeSelector.inputGroup &&
                    p.rangeSelector.inputGroup.element.style.visibility !==
                      "hidden" &&
                    p.options.rangeSelector.inputEnabled !== !1 &&
                    p.rangeSelector.minInput &&
                    p.rangeSelector.maxInput
                  );
                },
                init: function (u) {
                  f.onInputNavInit(u);
                },
                terminate: function () {
                  f.onInputNavTerminate();
                },
              });
            }
            getKeyboardNavigation() {
              return [
                this.getRangeSelectorButtonNavigation(),
                this.getRangeSelectorInputNavigation(),
              ];
            }
            destroy() {
              this.removeDropdownKeydownHandler &&
                this.removeDropdownKeydownHandler(),
                this.removeInputKeydownHandler &&
                  this.removeInputKeydownHandler(),
                this.announcer && this.announcer.destroy();
            }
          }
          return (
            (function (c) {
              function p(n) {
                const d =
                    (this.rangeSelector && this.rangeSelector.buttons) || [],
                  g = this.highlightedRangeSelectorItemIx,
                  M = this.rangeSelector && this.rangeSelector.selected;
                return (
                  typeof g < "u" &&
                    d[g] &&
                    g !== M &&
                    d[g].setState(this.oldRangeSelectorItemState || 0),
                  (this.highlightedRangeSelectorItemIx = n),
                  d[n]
                    ? (this.setFocusToElement(d[n].box, d[n].element),
                      n !== M &&
                        ((this.oldRangeSelectorItemState = d[n].state),
                        d[n].setState(1)),
                      !0)
                    : !1
                );
              }
              function f() {
                const n = this.chart.accessibility;
                if (n && n.components.rangeSelector)
                  return n.components.rangeSelector.onAfterBtnClick();
              }
              const u = [];
              c.compose = function (n, d) {
                U.pushUnique(u, n) &&
                  (n.prototype.highlightRangeSelectorButton = p),
                  U.pushUnique(u, d) && S(y, "afterBtnClick", f);
              };
            })(D || (D = {})),
            D
          );
        }
      ),
      T(
        k,
        "Accessibility/Components/SeriesComponent/ForcedMarkers.js",
        [k["Core/Utilities.js"]],
        function (y) {
          const { addEvent: A, merge: O } = y;
          var F;
          return (
            (function (G) {
              function U(c) {
                O(!0, c, {
                  marker: { enabled: !0, states: { normal: { opacity: 0 } } },
                });
              }
              function H(c) {
                return (
                  c.marker.states &&
                  c.marker.states.normal &&
                  c.marker.states.normal.opacity
                );
              }
              function Y() {
                this.chart.styledMode &&
                  (this.markerGroup &&
                    this.markerGroup[
                      this.a11yMarkersForced ? "addClass" : "removeClass"
                    ]("highcharts-a11y-markers-hidden"),
                  this._hasPointMarkers &&
                    this.points &&
                    this.points.length &&
                    this.points.forEach((c) => {
                      c.graphic &&
                        (c.graphic[
                          c.hasForcedA11yMarker ? "addClass" : "removeClass"
                        ]("highcharts-a11y-marker-hidden"),
                        c.graphic[
                          c.hasForcedA11yMarker === !1
                            ? "addClass"
                            : "removeClass"
                        ]("highcharts-a11y-marker-visible"));
                    }));
              }
              function S(c) {
                this.resetA11yMarkerOptions = O(
                  c.options.marker || {},
                  this.userOptions.marker || {}
                );
              }
              function N() {
                var c = this.options,
                  p =
                    (this.options.accessibility &&
                      this.options.accessibility.enabled) !== !1;
                if (
                  ((p = this.chart.options.accessibility.enabled && p) &&
                    ((p = this.chart.options.accessibility),
                    (p =
                      this.points.length <
                        p.series.pointDescriptionEnabledThreshold ||
                      p.series.pointDescriptionEnabledThreshold === !1)),
                  p)
                ) {
                  if (
                    (c.marker &&
                      c.marker.enabled === !1 &&
                      ((this.a11yMarkersForced = !0), U(this.options)),
                    this._hasPointMarkers && this.points && this.points.length)
                  )
                    for (c = this.points.length; c--; ) {
                      p = this.points[c];
                      const u = p.options;
                      var f = p.hasForcedA11yMarker;
                      delete p.hasForcedA11yMarker,
                        u.marker &&
                          ((f = f && H(u) === 0),
                          u.marker.enabled && !f
                            ? (O(!0, u.marker, {
                                states: { normal: { opacity: H(u) || 1 } },
                              }),
                              (p.hasForcedA11yMarker = !1))
                            : u.marker.enabled === !1 &&
                              (U(u), (p.hasForcedA11yMarker = !0)));
                    }
                } else
                  this.a11yMarkersForced &&
                    (delete this.a11yMarkersForced,
                    (c = this.resetA11yMarkerOptions) &&
                      this.update({
                        marker: {
                          enabled: c.enabled,
                          states: {
                            normal: {
                              opacity:
                                c.states &&
                                c.states.normal &&
                                c.states.normal.opacity,
                            },
                          },
                        },
                      }),
                    delete this.resetA11yMarkerOptions);
              }
              const D = [];
              G.compose = function (c) {
                y.pushUnique(D, c) &&
                  (A(c, "afterSetOptions", S),
                  A(c, "render", N),
                  A(c, "afterRender", Y));
              };
            })(F || (F = {})),
            F
          );
        }
      ),
      T(
        k,
        "Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js",
        [
          k["Core/Series/Point.js"],
          k["Core/Series/Series.js"],
          k["Core/Series/SeriesRegistry.js"],
          k["Core/Globals.js"],
          k["Core/Utilities.js"],
          k["Accessibility/KeyboardNavigationHandler.js"],
          k["Accessibility/Utils/EventProvider.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
        ],
        function (y, A, O, F, G, U, H, Y) {
          function S(m) {
            const h = m.index,
              v = m.series.points;
            let l = v.length;
            if (v[h] !== m) {
              for (; l--; ) if (v[l] === m) return l;
            } else return h;
          }
          function N(m) {
            const h =
                m.chart.options.accessibility.keyboardNavigation
                  .seriesNavigation,
              v = m.options.accessibility || {},
              l = v.keyboardNavigation;
            return (
              (l && l.enabled === !1) ||
              v.enabled === !1 ||
              m.options.enableMouseTracking === !1 ||
              !m.visible ||
              (h.pointNavigationEnabledThreshold &&
                h.pointNavigationEnabledThreshold <= m.points.length)
            );
          }
          function D(m) {
            const h = m.series.chart.options.accessibility,
              v =
                m.options.accessibility &&
                m.options.accessibility.enabled === !1;
            return (
              (m.isNull &&
                h.keyboardNavigation.seriesNavigation.skipNullPoints) ||
              m.visible === !1 ||
              m.isInside === !1 ||
              v ||
              N(m.series)
            );
          }
          function c(m) {
            m = m.series || [];
            const h = m.length;
            for (let l = 0; l < h; ++l)
              if (!N(m[l])) {
                t: {
                  var v = m[l].points || [];
                  const o = v.length;
                  for (let i = 0; i < o; ++i)
                    if (!D(v[i])) {
                      v = v[i];
                      break t;
                    }
                  v = null;
                }
                if (v) return v;
              }
            return null;
          }
          function p(m) {
            let h = m.series.length,
              v = !1;
            for (
              ;
              h-- &&
              ((m.highlightedPoint =
                m.series[h].points[m.series[h].points.length - 1]),
              !(v = m.series[h].highlightNextValidPoint()));

            );
            return v;
          }
          function f(m) {
            return delete m.highlightedPoint, (m = c(m)) ? m.highlight() : !1;
          }
          const { seriesTypes: u } = O,
            { doc: n } = F,
            { defined: d, fireEvent: g } = G,
            { getPointFromXY: M, getSeriesFromName: C, scrollToPoint: P } = Y;
          class j {
            constructor(h, v) {
              (this.keyCodes = v), (this.chart = h);
            }
            init() {
              const h = this,
                v = this.chart,
                l = (this.eventProvider = new H());
              l.addEvent(A, "destroy", function () {
                return h.onSeriesDestroy(this);
              }),
                l.addEvent(v, "afterApplyDrilldown", function () {
                  {
                    const o = c(this);
                    o && o.highlight(!1);
                  }
                }),
                l.addEvent(v, "drilldown", function (o) {
                  o = o.point;
                  const i = o.series;
                  h.lastDrilledDownPoint = {
                    x: o.x,
                    y: o.y,
                    seriesName: i ? i.name : "",
                  };
                }),
                l.addEvent(v, "drillupall", function () {
                  setTimeout(function () {
                    h.onDrillupAll();
                  }, 10);
                }),
                l.addEvent(y, "afterSetState", function () {
                  const o = this.graphic && this.graphic.element,
                    i = n.activeElement;
                  var t = i && i.getAttribute("class");
                  (t = t && -1 < t.indexOf("highcharts-a11y-proxy-button")),
                    v.highlightedPoint === this &&
                      i !== o &&
                      !t &&
                      o &&
                      o.focus &&
                      o.focus();
                });
            }
            onDrillupAll() {
              const h = this.lastDrilledDownPoint,
                v = this.chart,
                l = h && C(v, h.seriesName);
              let o;
              h && l && d(h.x) && d(h.y) && (o = M(l, h.x, h.y)),
                (o = o || c(v)),
                v.container && v.container.focus(),
                o && o.highlight && o.highlight(!1);
            }
            getKeyboardNavigationHandler() {
              const h = this,
                v = this.keyCodes,
                l = this.chart,
                o = l.inverted;
              return new U(l, {
                keyCodeMap: [
                  [
                    o ? [v.up, v.down] : [v.left, v.right],
                    function (i) {
                      return h.onKbdSideways(this, i);
                    },
                  ],
                  [
                    o ? [v.left, v.right] : [v.up, v.down],
                    function (i) {
                      return h.onKbdVertical(this, i);
                    },
                  ],
                  [
                    [v.enter, v.space],
                    function (i, t) {
                      return (
                        (i = l.highlightedPoint) &&
                          ((t.point = i),
                          g(i.series, "click", t),
                          i.firePointEvent("click")),
                        this.response.success
                      );
                    },
                  ],
                  [
                    [v.home],
                    function () {
                      return f(l), this.response.success;
                    },
                  ],
                  [
                    [v.end],
                    function () {
                      return p(l), this.response.success;
                    },
                  ],
                  [
                    [v.pageDown, v.pageUp],
                    function (i) {
                      return (
                        l.highlightAdjacentSeries(i === v.pageDown),
                        this.response.success
                      );
                    },
                  ],
                ],
                init: function () {
                  return h.onHandlerInit(this);
                },
                validate: function () {
                  return !!c(l);
                },
                terminate: function () {
                  return h.onHandlerTerminate();
                },
              });
            }
            onKbdSideways(h, v) {
              const l = this.keyCodes;
              return this.attemptHighlightAdjacentPoint(
                h,
                v === l.right || v === l.down
              );
            }
            onHandlerInit(h) {
              const v = this.chart;
              return (
                v.options.accessibility.keyboardNavigation.seriesNavigation
                  .rememberPointFocus && v.highlightedPoint
                  ? v.highlightedPoint.highlight()
                  : f(v),
                h.response.success
              );
            }
            onKbdVertical(h, v) {
              const l = this.chart;
              var o = this.keyCodes;
              return (
                (v = v === o.down || v === o.right),
                (o =
                  l.options.accessibility.keyboardNavigation.seriesNavigation),
                o.mode && o.mode === "serialize"
                  ? this.attemptHighlightAdjacentPoint(h, v)
                  : (l[
                      l.highlightedPoint &&
                      l.highlightedPoint.series.keyboardMoveVertical
                        ? "highlightAdjacentPointVertical"
                        : "highlightAdjacentSeries"
                    ](v),
                    h.response.success)
              );
            }
            onHandlerTerminate() {
              const h = this.chart,
                v = h.options.accessibility.keyboardNavigation;
              h.tooltip && h.tooltip.hide(0);
              const l = h.highlightedPoint && h.highlightedPoint.series;
              l && l.onMouseOut && l.onMouseOut(),
                h.highlightedPoint &&
                  h.highlightedPoint.onMouseOut &&
                  h.highlightedPoint.onMouseOut(),
                v.seriesNavigation.rememberPointFocus ||
                  delete h.highlightedPoint;
            }
            attemptHighlightAdjacentPoint(h, v) {
              const l = this.chart,
                o = l.options.accessibility.keyboardNavigation.wrapAround;
              return l.highlightAdjacentPoint(v) || (o && (v ? f(l) : p(l)))
                ? h.response.success
                : h.response[v ? "next" : "prev"];
            }
            onSeriesDestroy(h) {
              const v = this.chart;
              v.highlightedPoint &&
                v.highlightedPoint.series === h &&
                (delete v.highlightedPoint,
                v.focusElement && v.focusElement.removeFocusBorder());
            }
            destroy() {
              this.eventProvider.removeAddedEvents();
            }
          }
          return (
            (function (m) {
              function h(s) {
                var a = this.series;
                const b = this.highlightedPoint;
                var r = (b && S(b)) || 0;
                const w = (b && b.series.points) || [];
                var L = this.series && this.series[this.series.length - 1];
                if (
                  ((L = L && L.points && L.points[L.points.length - 1]),
                  !a[0] || !a[0].points)
                )
                  return !1;
                if (b) {
                  if (
                    ((a = a[b.series.index + (s ? 1 : -1)]),
                    (r = w[r + (s ? 1 : -1)]),
                    !r && a && (r = a.points[s ? 0 : a.points.length - 1]),
                    !r)
                  )
                    return !1;
                } else r = s ? a[0].points[0] : L;
                return D(r)
                  ? ((a = r.series),
                    N(a)
                      ? (this.highlightedPoint = s
                          ? a.points[a.points.length - 1]
                          : a.points[0])
                      : (this.highlightedPoint = r),
                    this.highlightAdjacentPoint(s))
                  : r.highlight();
              }
              function v(s) {
                const a = this.highlightedPoint;
                let b = 1 / 0,
                  r;
                return !d(a.plotX) || !d(a.plotY)
                  ? !1
                  : (this.series.forEach((w) => {
                      N(w) ||
                        w.points.forEach((L) => {
                          if (d(L.plotY) && d(L.plotX) && L !== a) {
                            var I = L.plotY - a.plotY,
                              V = Math.abs(L.plotX - a.plotX);
                            (V = Math.abs(I) * Math.abs(I) + V * V * 4),
                              w.yAxis && w.yAxis.reversed && (I *= -1),
                              !(
                                (0 >= I && s) ||
                                (0 <= I && !s) ||
                                5 > V ||
                                D(L)
                              ) &&
                                V < b &&
                                ((b = V), (r = L));
                          }
                        });
                    }),
                    r ? r.highlight() : !1);
              }
              function l(s) {
                const a = this.highlightedPoint;
                var b = this.series && this.series[this.series.length - 1],
                  r = b && b.points && b.points[b.points.length - 1];
                return this.highlightedPoint
                  ? ((b = this.series[a.series.index + (s ? -1 : 1)]),
                    !b || ((r = o(a, b, 4)), !r)
                      ? !1
                      : N(b)
                      ? (r.highlight(),
                        (s = this.highlightAdjacentSeries(s)),
                        s || (a.highlight(), !1))
                      : (r.highlight(), r.series.highlightNextValidPoint()))
                  : ((b = s ? this.series && this.series[0] : b),
                    (r = s ? b && b.points && b.points[0] : r)
                      ? r.highlight()
                      : !1);
              }
              function o(s, a, b, r) {
                let w = 1 / 0,
                  L,
                  I = a.points.length;
                const V = (x) => !(d(x.plotX) && d(x.plotY));
                if (!V(s)) {
                  for (; I--; ) {
                    var B = a.points[I];
                    V(B) ||
                      ((B =
                        (s.plotX - B.plotX) * (s.plotX - B.plotX) * (b || 1) +
                        (s.plotY - B.plotY) * (s.plotY - B.plotY) * (r || 1)),
                      B < w && ((w = B), (L = I)));
                  }
                  return d(L) ? a.points[L] : void 0;
                }
              }
              function i(s = !0) {
                const a = this.series.chart;
                return (
                  !this.isNull && s
                    ? this.onMouseOver()
                    : a.tooltip && a.tooltip.hide(0),
                  P(this),
                  this.graphic &&
                    (a.setFocusToElement(this.graphic),
                    !s && a.focusElement && a.focusElement.removeFocusBorder()),
                  (a.highlightedPoint = this),
                  this
                );
              }
              function t() {
                var s = this.chart.highlightedPoint,
                  a = (s && s.series) === this ? S(s) : 0;
                s = this.points;
                const b = s.length;
                if (s && b) {
                  for (let r = a; r < b; ++r)
                    if (!D(s[r])) return s[r].highlight();
                  for (; 0 <= a; --a) if (!D(s[a])) return s[a].highlight();
                }
                return !1;
              }
              const e = [];
              m.compose = function (s, a, b) {
                G.pushUnique(e, s) &&
                  ((s = s.prototype),
                  (s.highlightAdjacentPoint = h),
                  (s.highlightAdjacentPointVertical = v),
                  (s.highlightAdjacentSeries = l)),
                  G.pushUnique(e, a) && (a.prototype.highlight = i),
                  G.pushUnique(e, b) &&
                    ((a = b.prototype),
                    (a.keyboardMoveVertical = !0),
                    ["column", "gantt", "pie"].forEach((r) => {
                      u[r] && (u[r].prototype.keyboardMoveVertical = !1);
                    }),
                    (a.highlightNextValidPoint = t));
              };
            })(j || (j = {})),
            j
          );
        }
      ),
      T(
        k,
        "Accessibility/Components/SeriesComponent/SeriesComponent.js",
        [
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Components/SeriesComponent/ForcedMarkers.js"],
          k["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"],
          k["Accessibility/Components/SeriesComponent/SeriesDescriber.js"],
          k[
            "Accessibility/Components/SeriesComponent/SeriesKeyboardNavigation.js"
          ],
        ],
        function (y, A, O, F, G, U) {
          const { hideSeriesFromAT: H } = A,
            { describeSeries: Y } = G;
          class S extends y {
            static compose(D, c, p) {
              F.compose(p), O.compose(p), U.compose(D, c, p);
            }
            init() {
              (this.newDataAnnouncer = new F(this.chart)),
                this.newDataAnnouncer.init(),
                (this.keyboardNavigation = new U(this.chart, this.keyCodes)),
                this.keyboardNavigation.init(),
                this.hideTooltipFromATWhenShown(),
                this.hideSeriesLabelsFromATWhenShown();
            }
            hideTooltipFromATWhenShown() {
              const D = this;
              this.chart.tooltip &&
                this.addEvent(
                  this.chart.tooltip.constructor,
                  "refresh",
                  function () {
                    this.chart === D.chart &&
                      this.label &&
                      this.label.element &&
                      this.label.element.setAttribute("aria-hidden", !0);
                  }
                );
            }
            hideSeriesLabelsFromATWhenShown() {
              this.addEvent(this.chart, "afterDrawSeriesLabels", function () {
                this.series.forEach(function (D) {
                  D.labelBySeries && D.labelBySeries.attr("aria-hidden", !0);
                });
              });
            }
            onChartRender() {
              this.chart.series.forEach(function (D) {
                (D.options.accessibility && D.options.accessibility.enabled) !==
                  !1 && D.visible
                  ? Y(D)
                  : H(D);
              });
            }
            getKeyboardNavigation() {
              return this.keyboardNavigation.getKeyboardNavigationHandler();
            }
            destroy() {
              this.newDataAnnouncer.destroy(),
                this.keyboardNavigation.destroy();
            }
          }
          return S;
        }
      ),
      T(
        k,
        "Accessibility/Components/ZoomComponent.js",
        [
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Accessibility/KeyboardNavigationHandler.js"],
          k["Core/Utilities.js"],
        ],
        function (y, A, O, F, G) {
          const { unhideChartElementFromAT: U } = A,
            { getFakeMouseEvent: H } = O,
            { attr: Y, pick: S } = G;
          class N extends y {
            constructor() {
              super(...arguments), (this.focusedMapNavButtonIx = -1);
            }
            init() {
              const c = this,
                p = this.chart;
              this.proxyProvider.addGroup("zoom", "div"),
                [
                  "afterShowResetZoom",
                  "afterApplyDrilldown",
                  "drillupall",
                ].forEach((f) => {
                  c.addEvent(p, f, function () {
                    c.updateProxyOverlays();
                  });
                });
            }
            onChartUpdate() {
              const c = this.chart,
                p = this;
              c.mapNavigation &&
                c.mapNavigation.navButtons.forEach((f, u) => {
                  U(c, f.element),
                    p.setMapNavButtonAttrs(
                      f.element,
                      "accessibility.zoom.mapZoom" + (u ? "Out" : "In")
                    );
                });
            }
            setMapNavButtonAttrs(c, p) {
              const f = this.chart;
              (p = f.langFormat(p, { chart: f })),
                Y(c, { tabindex: -1, role: "button", "aria-label": p });
            }
            onChartRender() {
              this.updateProxyOverlays();
            }
            updateProxyOverlays() {
              const c = this.chart;
              this.proxyProvider.clearGroup("zoom"),
                c.resetZoomButton &&
                  this.createZoomProxyButton(
                    c.resetZoomButton,
                    "resetZoomProxyButton",
                    c.langFormat("accessibility.zoom.resetZoomButton", {
                      chart: c,
                    })
                  ),
                c.drillUpButton &&
                  c.breadcrumbs &&
                  c.breadcrumbs.list &&
                  this.createZoomProxyButton(
                    c.drillUpButton,
                    "drillUpProxyButton",
                    c.langFormat("accessibility.drillUpButton", {
                      chart: c,
                      buttonText: c.breadcrumbs.getButtonText(
                        c.breadcrumbs.list[c.breadcrumbs.list.length - 1]
                      ),
                    })
                  );
            }
            createZoomProxyButton(c, p, f) {
              this[p] = this.proxyProvider.addProxyElement(
                "zoom",
                { click: c },
                { "aria-label": f, tabindex: -1 }
              );
            }
            getMapZoomNavigation() {
              const c = this.keyCodes,
                p = this.chart,
                f = this;
              return new F(p, {
                keyCodeMap: [
                  [
                    [c.up, c.down, c.left, c.right],
                    function (u) {
                      return f.onMapKbdArrow(this, u);
                    },
                  ],
                  [
                    [c.tab],
                    function (u, n) {
                      return f.onMapKbdTab(this, n);
                    },
                  ],
                  [
                    [c.space, c.enter],
                    function () {
                      return f.onMapKbdClick(this);
                    },
                  ],
                ],
                validate: function () {
                  return !!(
                    p.mapView &&
                    p.mapNavigation &&
                    p.mapNavigation.navButtons.length
                  );
                },
                init: function (u) {
                  return f.onMapNavInit(u);
                },
              });
            }
            onMapKbdArrow(c, p) {
              var f = this.chart,
                u = this.keyCodes;
              const n = f.container;
              var d = p === u.up || p === u.down;
              return (
                (p =
                  ((d ? f.plotHeight : f.plotWidth) / 10) *
                  (p === u.left || p === u.up ? 1 : -1)),
                (u = 10 * Math.random()),
                (f = {
                  x: n.offsetLeft + f.plotLeft + f.plotWidth / 2 + u,
                  y: n.offsetTop + f.plotTop + f.plotHeight / 2 + u,
                }),
                (d = d ? { x: f.x, y: f.y + p } : { x: f.x + p, y: f.y }),
                [H("mousedown", f), H("mousemove", d), H("mouseup", d)].forEach(
                  (g) => n.dispatchEvent(g)
                ),
                c.response.success
              );
            }
            onMapKbdTab(c, p) {
              const f = this.chart;
              c = c.response;
              const u =
                ((p = p.shiftKey) && !this.focusedMapNavButtonIx) ||
                (!p && this.focusedMapNavButtonIx);
              return (
                f.mapNavigation.navButtons[this.focusedMapNavButtonIx].setState(
                  0
                ),
                u
                  ? (f.mapView && f.mapView.zoomBy(), c[p ? "prev" : "next"])
                  : ((this.focusedMapNavButtonIx += p ? -1 : 1),
                    (p =
                      f.mapNavigation.navButtons[this.focusedMapNavButtonIx]),
                    f.setFocusToElement(p.box, p.element),
                    p.setState(2),
                    c.success)
              );
            }
            onMapKbdClick(c) {
              return (
                this.fakeClickEvent(
                  this.chart.mapNavigation.navButtons[
                    this.focusedMapNavButtonIx
                  ].element
                ),
                c.response.success
              );
            }
            onMapNavInit(c) {
              const p = this.chart;
              var f = p.mapNavigation.navButtons[0];
              const u = p.mapNavigation.navButtons[1];
              (f = 0 < c ? f : u),
                p.setFocusToElement(f.box, f.element),
                f.setState(2),
                (this.focusedMapNavButtonIx = 0 < c ? 0 : 1);
            }
            simpleButtonNavigation(c, p, f) {
              const u = this.keyCodes,
                n = this,
                d = this.chart;
              return new F(d, {
                keyCodeMap: [
                  [
                    [u.tab, u.up, u.down, u.left, u.right],
                    function (g, M) {
                      return this.response[
                        (g === u.tab && M.shiftKey) ||
                        g === u.left ||
                        g === u.up
                          ? "prev"
                          : "next"
                      ];
                    },
                  ],
                  [
                    [u.space, u.enter],
                    function () {
                      const g = f(this, d);
                      return S(g, this.response.success);
                    },
                  ],
                ],
                validate: function () {
                  return d[c] && d[c].box && n[p].buttonElement;
                },
                init: function () {
                  d.setFocusToElement(d[c].box, n[p].buttonElement);
                },
              });
            }
            getKeyboardNavigation() {
              return [
                this.simpleButtonNavigation(
                  "resetZoomButton",
                  "resetZoomProxyButton",
                  function (c, p) {
                    p.zoomOut();
                  }
                ),
                this.simpleButtonNavigation(
                  "drillUpButton",
                  "drillUpProxyButton",
                  function (c, p) {
                    return p.drillUp(), c.response.prev;
                  }
                ),
                this.getMapZoomNavigation(),
              ];
            }
          }
          return N;
        }
      ),
      T(
        k,
        "Accessibility/HighContrastMode.js",
        [k["Core/Globals.js"]],
        function (y) {
          const { doc: A, isMS: O, win: F } = y;
          return {
            isHighContrastModeActive: function () {
              var G = /(Edg)/.test(F.navigator.userAgent);
              if (F.matchMedia && G)
                return F.matchMedia("(-ms-high-contrast: active)").matches;
              if (O && F.getComputedStyle) {
                (G = A.createElement("div")),
                  (G.style.backgroundImage =
                    "url(data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==)"),
                  A.body.appendChild(G);
                const U = (G.currentStyle || F.getComputedStyle(G))
                  .backgroundImage;
                return A.body.removeChild(G), U === "none";
              }
              return (
                F.matchMedia && F.matchMedia("(forced-colors: active)").matches
              );
            },
            setHighContrastTheme: function (G) {
              G.highContrastModeActive = !0;
              const U = G.options.accessibility.highContrastTheme;
              G.update(U, !1),
                G.series.forEach(function (H) {
                  const Y = U.plotOptions[H.type] || {};
                  H.update({
                    color: Y.color || "windowText",
                    colors: [Y.color || "windowText"],
                    borderColor: Y.borderColor || "window",
                  }),
                    H.points.forEach(function (S) {
                      S.options &&
                        S.options.color &&
                        S.update(
                          {
                            color: Y.color || "windowText",
                            borderColor: Y.borderColor || "window",
                          },
                          !1
                        );
                    });
                }),
                G.redraw();
            },
          };
        }
      ),
      T(k, "Accessibility/HighContrastTheme.js", [], function () {
        return {
          chart: { backgroundColor: "window" },
          title: { style: { color: "windowText" } },
          subtitle: { style: { color: "windowText" } },
          colorAxis: {
            minColor: "windowText",
            maxColor: "windowText",
            stops: [],
          },
          colors: ["windowText"],
          xAxis: {
            gridLineColor: "windowText",
            labels: { style: { color: "windowText" } },
            lineColor: "windowText",
            minorGridLineColor: "windowText",
            tickColor: "windowText",
            title: { style: { color: "windowText" } },
          },
          yAxis: {
            gridLineColor: "windowText",
            labels: { style: { color: "windowText" } },
            lineColor: "windowText",
            minorGridLineColor: "windowText",
            tickColor: "windowText",
            title: { style: { color: "windowText" } },
          },
          tooltip: {
            backgroundColor: "window",
            borderColor: "windowText",
            style: { color: "windowText" },
          },
          plotOptions: {
            series: {
              lineColor: "windowText",
              fillColor: "window",
              borderColor: "windowText",
              edgeColor: "windowText",
              borderWidth: 1,
              dataLabels: {
                connectorColor: "windowText",
                color: "windowText",
                style: { color: "windowText", textOutline: "none" },
              },
              marker: { lineColor: "windowText", fillColor: "windowText" },
            },
            pie: {
              color: "window",
              colors: ["window"],
              borderColor: "windowText",
              borderWidth: 1,
            },
            boxplot: { fillColor: "window" },
            candlestick: { lineColor: "windowText", fillColor: "window" },
            errorbar: { fillColor: "window" },
          },
          legend: {
            backgroundColor: "window",
            itemStyle: { color: "windowText" },
            itemHoverStyle: { color: "windowText" },
            itemHiddenStyle: { color: "#555" },
            title: { style: { color: "windowText" } },
          },
          credits: { style: { color: "windowText" } },
          drilldown: {
            activeAxisLabelStyle: { color: "windowText" },
            activeDataLabelStyle: { color: "windowText" },
          },
          navigation: {
            buttonOptions: {
              symbolStroke: "windowText",
              theme: { fill: "window" },
            },
          },
          rangeSelector: {
            buttonTheme: {
              fill: "window",
              stroke: "windowText",
              style: { color: "windowText" },
              states: {
                hover: {
                  fill: "window",
                  stroke: "windowText",
                  style: { color: "windowText" },
                },
                select: {
                  fill: "#444",
                  stroke: "windowText",
                  style: { color: "windowText" },
                },
              },
            },
            inputBoxBorderColor: "windowText",
            inputStyle: { backgroundColor: "window", color: "windowText" },
            labelStyle: { color: "windowText" },
          },
          navigator: {
            handles: { backgroundColor: "window", borderColor: "windowText" },
            outlineColor: "windowText",
            maskFill: "transparent",
            series: { color: "windowText", lineColor: "windowText" },
            xAxis: { gridLineColor: "windowText" },
          },
          scrollbar: {
            barBackgroundColor: "#444",
            barBorderColor: "windowText",
            buttonArrowColor: "windowText",
            buttonBackgroundColor: "window",
            buttonBorderColor: "windowText",
            rifleColor: "windowText",
            trackBackgroundColor: "window",
            trackBorderColor: "windowText",
          },
        };
      }),
      T(k, "Accessibility/Options/A11yDefaults.js", [], function () {
        return {
          accessibility: {
            enabled: !0,
            screenReaderSection: {
              beforeChartFormat:
                "<{headingTagName}>{chartTitle}</{headingTagName}><div>{typeDescription}</div><div>{chartSubtitle}</div><div>{chartLongdesc}</div><div>{playAsSoundButton}</div><div>{viewTableButton}</div><div>{xAxisDescription}</div><div>{yAxisDescription}</div><div>{annotationsTitle}{annotationsList}</div>",
              afterChartFormat: "{endOfChartMarker}",
              axisRangeDateFormat: "%Y-%m-%d %H:%M:%S",
            },
            series: {
              descriptionFormat:
                "{seriesDescription}{authorDescription}{axisDescription}",
              describeSingleSeries: !1,
              pointDescriptionEnabledThreshold: 200,
            },
            point: {
              valueDescriptionFormat: "{xDescription}{separator}{value}.",
              describeNull: !0,
            },
            landmarkVerbosity: "all",
            linkedDescription:
              '*[data-highcharts-chart="{index}"] + .highcharts-description',
            keyboardNavigation: {
              enabled: !0,
              focusBorder: {
                enabled: !0,
                hideBrowserFocusOutline: !0,
                style: { color: "#334eff", lineWidth: 2, borderRadius: 3 },
                margin: 2,
              },
              order: ["series", "zoom", "rangeSelector", "legend", "chartMenu"],
              wrapAround: !0,
              seriesNavigation: {
                skipNullPoints: !0,
                pointNavigationEnabledThreshold: !1,
                rememberPointFocus: !1,
              },
            },
            announceNewData: {
              enabled: !1,
              minAnnounceInterval: 5e3,
              interruptUser: !1,
            },
          },
          legend: {
            accessibility: { enabled: !0, keyboardNavigation: { enabled: !0 } },
          },
          exporting: { accessibility: { enabled: !0 } },
        };
      }),
      T(k, "Accessibility/Options/LangDefaults.js", [], function () {
        return {
          accessibility: {
            defaultChartTitle: "Chart",
            chartContainerLabel: "{title}. Highcharts interactive chart.",
            svgContainerLabel: "Interactive chart",
            drillUpButton: "{buttonText}",
            credits: "Chart credits: {creditsStr}",
            thousandsSep: ",",
            svgContainerTitle: "",
            graphicContainerLabel: "",
            screenReaderSection: {
              beforeRegionLabel: "",
              afterRegionLabel: "",
              annotations: {
                heading: "Chart annotations summary",
                descriptionSinglePoint:
                  "{annotationText}. Related to {annotationPoint}",
                descriptionMultiplePoints:
                  "{annotationText}. Related to {annotationPoint}{#each additionalAnnotationPoints}, also related to {this}{/each}",
                descriptionNoPoints: "{annotationText}",
              },
              endOfChartMarker: "End of interactive chart.",
            },
            sonification: {
              playAsSoundButtonText: "Play as sound, {chartTitle}",
              playAsSoundClickAnnouncement: "Play",
            },
            legend: {
              legendLabelNoTitle: "Toggle series visibility, {chartTitle}",
              legendLabel: "Chart legend: {legendTitle}",
              legendItem: "Show {itemName}",
            },
            zoom: {
              mapZoomIn: "Zoom chart",
              mapZoomOut: "Zoom out chart",
              resetZoomButton: "Reset zoom",
            },
            rangeSelector: {
              dropdownLabel: "{rangeTitle}",
              minInputLabel: "Select start date.",
              maxInputLabel: "Select end date.",
              clickButtonAnnouncement: "Viewing {axisRangeDescription}",
            },
            table: {
              viewAsDataTableButtonText: "View as data table, {chartTitle}",
              tableSummary: "Table representation of chart.",
            },
            announceNewData: {
              newDataAnnounce: "Updated data for chart {chartTitle}",
              newSeriesAnnounceSingle: "New data series: {seriesDesc}",
              newPointAnnounceSingle: "New data point: {pointDesc}",
              newSeriesAnnounceMultiple:
                "New data series in chart {chartTitle}: {seriesDesc}",
              newPointAnnounceMultiple:
                "New data point in chart {chartTitle}: {pointDesc}",
            },
            seriesTypeDescriptions: {
              boxplot:
                "Box plot charts are typically used to display groups of statistical data. Each data point in the chart can have up to 5 values: minimum, lower quartile, median, upper quartile, and maximum.",
              arearange:
                "Arearange charts are line charts displaying a range between a lower and higher value for each point.",
              areasplinerange:
                "These charts are line charts displaying a range between a lower and higher value for each point.",
              bubble:
                "Bubble charts are scatter charts where each data point also has a size value.",
              columnrange:
                "Columnrange charts are column charts displaying a range between a lower and higher value for each point.",
              errorbar:
                "Errorbar series are used to display the variability of the data.",
              funnel:
                "Funnel charts are used to display reduction of data in stages.",
              pyramid:
                "Pyramid charts consist of a single pyramid with item heights corresponding to each point value.",
              waterfall:
                "A waterfall chart is a column chart where each column contributes towards a total end value.",
            },
            chartTypes: {
              emptyChart: "Empty chart",
              mapTypeDescription:
                "Map of {mapTitle} with {numSeries} data series.",
              unknownMap:
                "Map of unspecified region with {numSeries} data series.",
              combinationChart:
                "Combination chart with {numSeries} data series.",
              defaultSingle:
                "Chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
              defaultMultiple: "Chart with {numSeries} data series.",
              splineSingle:
                "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
              splineMultiple: "Line chart with {numSeries} lines.",
              lineSingle:
                "Line chart with {numPoints} data {#eq numPoints 1}point{else}points{/eq}.",
              lineMultiple: "Line chart with {numSeries} lines.",
              columnSingle:
                "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
              columnMultiple: "Bar chart with {numSeries} data series.",
              barSingle:
                "Bar chart with {numPoints} {#eq numPoints 1}bar{else}bars{/eq}.",
              barMultiple: "Bar chart with {numSeries} data series.",
              pieSingle:
                "Pie chart with {numPoints} {#eq numPoints 1}slice{else}slices{/eq}.",
              pieMultiple: "Pie chart with {numSeries} pies.",
              scatterSingle:
                "Scatter chart with {numPoints} {#eq numPoints 1}point{else}points{/eq}.",
              scatterMultiple: "Scatter chart with {numSeries} data series.",
              boxplotSingle:
                "Boxplot with {numPoints} {#eq numPoints 1}box{else}boxes{/eq}.",
              boxplotMultiple: "Boxplot with {numSeries} data series.",
              bubbleSingle:
                "Bubble chart with {numPoints} {#eq numPoints 1}bubbles{else}bubble{/eq}.",
              bubbleMultiple: "Bubble chart with {numSeries} data series.",
            },
            axis: {
              xAxisDescriptionSingular:
                "The chart has 1 X axis displaying {names[0]}. {ranges[0]}",
              xAxisDescriptionPlural:
                "The chart has {numAxes} X axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
              yAxisDescriptionSingular:
                "The chart has 1 Y axis displaying {names[0]}. {ranges[0]}",
              yAxisDescriptionPlural:
                "The chart has {numAxes} Y axes displaying {#each names}{#unless @first},{/unless}{#if @last} and{/if} {this}{/each}.",
              timeRangeDays: "Data range: {range} days.",
              timeRangeHours: "Data range: {range} hours.",
              timeRangeMinutes: "Data range: {range} minutes.",
              timeRangeSeconds: "Data range: {range} seconds.",
              rangeFromTo: "Data ranges from {rangeFrom} to {rangeTo}.",
              rangeCategories: "Data range: {numCategories} categories.",
            },
            exporting: {
              chartMenuLabel: "Chart menu",
              menuButtonLabel: "View chart menu, {chartTitle}",
            },
            series: {
              summary: {
                default:
                  "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                defaultCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                line: "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                lineCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                spline:
                  "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                splineCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                column:
                  "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                columnCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                bar: "{series.name}, bar series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                barCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bar series with {series.points.length} {#eq series.points.length 1}bar{else}bars{/eq}.",
                pie: "{series.name}, pie {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
                pieCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Pie with {series.points.length} {#eq series.points.length 1}slice{else}slices{/eq}.",
                scatter:
                  "{series.name}, scatter plot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
                scatterCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}, scatter plot with {series.points.length} {#eq series.points.length 1}point{else}points{/eq}.",
                boxplot:
                  "{series.name}, boxplot {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
                boxplotCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Boxplot with {series.points.length} {#eq series.points.length 1}box{else}boxes{/eq}.",
                bubble:
                  "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
                bubbleCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
                map: "{series.name}, map {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
                mapCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Map with {series.points.length} {#eq series.points.length 1}area{else}areas{/eq}.",
                mapline:
                  "{series.name}, line {seriesNumber} of {chart.series.length} with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                maplineCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Line with {series.points.length} data {#eq series.points.length 1}point{else}points{/eq}.",
                mapbubble:
                  "{series.name}, bubble series {seriesNumber} of {chart.series.length} with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
                mapbubbleCombination:
                  "{series.name}, series {seriesNumber} of {chart.series.length}. Bubble series with {series.points.length} {#eq series.points.length 1}bubble{else}bubbles{/eq}.",
              },
              description: "{description}",
              xAxisDescription: "X axis, {name}",
              yAxisDescription: "Y axis, {name}",
              nullPointValue: "No value",
              pointAnnotationsDescription:
                "{#each annotations}Annotation: {this}{/each}",
            },
          },
        };
      }),
      T(
        k,
        "Accessibility/Options/DeprecatedOptions.js",
        [k["Core/Utilities.js"]],
        function (y) {
          function A(S, N, D) {
            let c,
              p = 0;
            for (; p < N.length - 1; ++p) (c = N[p]), (S = S[c] = Y(S[c], {}));
            S[N[N.length - 1]] = D;
          }
          function O(S, N, D, c) {
            function p(n, d) {
              return d.reduce(function (g, M) {
                return g[M];
              }, n);
            }
            const f = p(S.options, N),
              u = p(S.options, D);
            Object.keys(c).forEach(function (n) {
              const d = f[n];
              typeof d < "u" &&
                (A(u, c[n], d),
                H(32, !1, S, {
                  [N.join(".") + "." + n]: D.join(".") + "." + c[n].join("."),
                }));
            });
          }
          function F(S) {
            const N = S.options.chart,
              D = S.options.accessibility || {};
            ["description", "typeDescription"].forEach(function (c) {
              N[c] &&
                ((D[c] = N[c]),
                H(32, !1, S, { [`chart.${c}`]: `use accessibility.${c}` }));
            });
          }
          function G(S) {
            S.axes.forEach(function (N) {
              (N = N.options) &&
                N.description &&
                ((N.accessibility = N.accessibility || {}),
                (N.accessibility.description = N.description),
                H(32, !1, S, {
                  "axis.description": "use axis.accessibility.description",
                }));
            });
          }
          function U(S) {
            const N = {
              description: ["accessibility", "description"],
              exposeElementToA11y: ["accessibility", "exposeAsGroupOnly"],
              pointDescriptionFormatter: [
                "accessibility",
                "point",
                "descriptionFormatter",
              ],
              skipKeyboardNavigation: [
                "accessibility",
                "keyboardNavigation",
                "enabled",
              ],
              "accessibility.pointDescriptionFormatter": [
                "accessibility",
                "point",
                "descriptionFormatter",
              ],
            };
            S.series.forEach(function (D) {
              Object.keys(N).forEach(function (c) {
                let p = D.options[c];
                c === "accessibility.pointDescriptionFormatter" &&
                  (p =
                    D.options.accessibility &&
                    D.options.accessibility.pointDescriptionFormatter),
                  typeof p < "u" &&
                    (A(
                      D.options,
                      N[c],
                      c === "skipKeyboardNavigation" ? !p : p
                    ),
                    H(32, !1, S, {
                      [`series.${c}`]: "series." + N[c].join("."),
                    }));
              });
            });
          }
          const { error: H, pick: Y } = y;
          return function (S) {
            F(S),
              G(S),
              S.series && U(S),
              O(S, ["accessibility"], ["accessibility"], {
                pointDateFormat: ["point", "dateFormat"],
                pointDateFormatter: ["point", "dateFormatter"],
                pointDescriptionFormatter: ["point", "descriptionFormatter"],
                pointDescriptionThreshold: [
                  "series",
                  "pointDescriptionEnabledThreshold",
                ],
                pointNavigationThreshold: [
                  "keyboardNavigation",
                  "seriesNavigation",
                  "pointNavigationEnabledThreshold",
                ],
                pointValueDecimals: ["point", "valueDecimals"],
                pointValuePrefix: ["point", "valuePrefix"],
                pointValueSuffix: ["point", "valueSuffix"],
                screenReaderSectionFormatter: [
                  "screenReaderSection",
                  "beforeChartFormatter",
                ],
                describeSingleSeries: ["series", "describeSingleSeries"],
                seriesDescriptionFormatter: ["series", "descriptionFormatter"],
                onTableAnchorClick: [
                  "screenReaderSection",
                  "onViewDataTableClick",
                ],
                axisRangeDateFormat: [
                  "screenReaderSection",
                  "axisRangeDateFormat",
                ],
              }),
              O(
                S,
                ["accessibility", "keyboardNavigation"],
                ["accessibility", "keyboardNavigation", "seriesNavigation"],
                { skipNullPoints: ["skipNullPoints"], mode: ["mode"] }
              ),
              O(S, ["lang", "accessibility"], ["lang", "accessibility"], {
                legendItem: ["legend", "legendItem"],
                legendLabel: ["legend", "legendLabel"],
                mapZoomIn: ["zoom", "mapZoomIn"],
                mapZoomOut: ["zoom", "mapZoomOut"],
                resetZoomButton: ["zoom", "resetZoomButton"],
                screenReaderRegionLabel: [
                  "screenReaderSection",
                  "beforeRegionLabel",
                ],
                rangeSelectorButton: ["rangeSelector", "buttonText"],
                rangeSelectorMaxInput: ["rangeSelector", "maxInputLabel"],
                rangeSelectorMinInput: ["rangeSelector", "minInputLabel"],
                svgContainerEnd: ["screenReaderSection", "endOfChartMarker"],
                viewAsDataTable: ["table", "viewAsDataTableButtonText"],
                tableSummary: ["table", "tableSummary"],
              });
          };
        }
      ),
      T(
        k,
        "Accessibility/Accessibility.js",
        [
          k["Core/Defaults.js"],
          k["Core/Globals.js"],
          k["Core/Utilities.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Accessibility/A11yI18n.js"],
          k["Accessibility/Components/ContainerComponent.js"],
          k["Accessibility/FocusBorder.js"],
          k["Accessibility/Components/InfoRegionsComponent.js"],
          k["Accessibility/KeyboardNavigation.js"],
          k["Accessibility/Components/LegendComponent.js"],
          k["Accessibility/Components/MenuComponent.js"],
          k["Accessibility/Components/SeriesComponent/NewDataAnnouncer.js"],
          k["Accessibility/ProxyProvider.js"],
          k["Accessibility/Components/RangeSelectorComponent.js"],
          k["Accessibility/Components/SeriesComponent/SeriesComponent.js"],
          k["Accessibility/Components/ZoomComponent.js"],
          k["Accessibility/HighContrastMode.js"],
          k["Accessibility/HighContrastTheme.js"],
          k["Accessibility/Options/A11yDefaults.js"],
          k["Accessibility/Options/LangDefaults.js"],
          k["Accessibility/Options/DeprecatedOptions.js"],
        ],
        function (
          y,
          A,
          O,
          F,
          G,
          U,
          H,
          Y,
          S,
          N,
          D,
          c,
          p,
          f,
          u,
          n,
          d,
          g,
          M,
          C,
          P
        ) {
          ({ defaultOptions: y } = y);
          const { doc: j } = A,
            { addEvent: m, extend: h, fireEvent: v, merge: l } = O,
            { removeElement: o } = F;
          class i {
            constructor(e) {
              (this.proxyProvider =
                this.keyboardNavigation =
                this.components =
                this.chart =
                  void 0),
                this.init(e);
            }
            init(e) {
              (this.chart = e),
                j.addEventListener
                  ? (P(e),
                    (this.proxyProvider = new p(this.chart)),
                    this.initComponents(),
                    (this.keyboardNavigation = new S(e, this.components)))
                  : ((this.zombie = !0),
                    (this.components = {}),
                    e.renderTo.setAttribute("aria-hidden", !0));
            }
            initComponents() {
              const e = this.chart,
                s = this.proxyProvider,
                a = e.options.accessibility;
              (this.components = {
                container: new U(),
                infoRegions: new Y(),
                legend: new N(),
                chartMenu: new D(),
                rangeSelector: new f(),
                series: new u(),
                zoom: new n(),
              }),
                a.customComponents && h(this.components, a.customComponents);
              const b = this.components;
              this.getComponentOrder().forEach(function (r) {
                b[r].initBase(e, s), b[r].init();
              });
            }
            getComponentOrder() {
              if (!this.components) return [];
              if (!this.components.series) return Object.keys(this.components);
              const e = Object.keys(this.components).filter(
                (s) => s !== "series"
              );
              return ["series"].concat(e);
            }
            update() {
              const e = this.components,
                s = this.chart;
              var a = s.options.accessibility;
              v(s, "beforeA11yUpdate"),
                (s.types = this.getChartTypes()),
                (a = a.keyboardNavigation.order),
                this.proxyProvider.updateGroupOrder(a),
                this.getComponentOrder().forEach(function (b) {
                  e[b].onChartUpdate(),
                    v(s, "afterA11yComponentUpdate", {
                      name: b,
                      component: e[b],
                    });
                }),
                this.keyboardNavigation.update(a),
                !s.highContrastModeActive &&
                  d.isHighContrastModeActive() &&
                  d.setHighContrastTheme(s),
                v(s, "afterA11yUpdate", { accessibility: this });
            }
            destroy() {
              const e = this.chart || {},
                s = this.components;
              Object.keys(s).forEach(function (a) {
                s[a].destroy(), s[a].destroyBase();
              }),
                this.proxyProvider && this.proxyProvider.destroy(),
                e.announcerContainer && o(e.announcerContainer),
                this.keyboardNavigation && this.keyboardNavigation.destroy(),
                e.renderTo && e.renderTo.setAttribute("aria-hidden", !0),
                e.focusElement && e.focusElement.removeFocusBorder();
            }
            getChartTypes() {
              const e = {};
              return (
                this.chart.series.forEach(function (s) {
                  e[s.type] = 1;
                }),
                Object.keys(e)
              );
            }
          }
          return (
            (function (t) {
              function e() {
                this.accessibility && this.accessibility.destroy();
              }
              function s() {
                this.a11yDirty &&
                  this.renderTo &&
                  (delete this.a11yDirty, this.updateA11yEnabled());
                const L = this.accessibility;
                L &&
                  !L.zombie &&
                  (L.proxyProvider.updateProxyElementPositions(),
                  L.getComponentOrder().forEach(function (I) {
                    L.components[I].onChartRender();
                  }));
              }
              function a(L) {
                (L = L.options.accessibility) &&
                  (L.customComponents &&
                    ((this.options.accessibility.customComponents =
                      L.customComponents),
                    delete L.customComponents),
                  l(!0, this.options.accessibility, L),
                  this.accessibility &&
                    this.accessibility.destroy &&
                    (this.accessibility.destroy(), delete this.accessibility)),
                  (this.a11yDirty = !0);
              }
              function b() {
                let L = this.accessibility;
                const I = this.options.accessibility;
                I && I.enabled
                  ? L && !L.zombie
                    ? L.update()
                    : ((this.accessibility = L = new t(this)),
                      !L.zombie && L.update())
                  : L
                  ? (L.destroy && L.destroy(), delete this.accessibility)
                  : this.renderTo.setAttribute("aria-hidden", !0);
              }
              function r() {
                this.series.chart.accessibility &&
                  (this.series.chart.a11yDirty = !0);
              }
              const w = [];
              (t.i18nFormat = G.i18nFormat),
                (t.compose = function (L, I, V, B, x, R) {
                  S.compose(L),
                    c.compose(B),
                    N.compose(L, I),
                    D.compose(L),
                    u.compose(L, V, B),
                    G.compose(L),
                    H.compose(L, x),
                    R && f.compose(L, R),
                    O.pushUnique(w, L) &&
                      ((L.prototype.updateA11yEnabled = b),
                      m(L, "destroy", e),
                      m(L, "render", s),
                      m(L, "update", a),
                      ["addSeries", "init"].forEach((W) => {
                        m(L, W, function () {
                          this.a11yDirty = !0;
                        });
                      }),
                      ["afterApplyDrilldown", "drillupall"].forEach((W) => {
                        m(L, W, function () {
                          const X = this.accessibility;
                          X && !X.zombie && X.update();
                        });
                      })),
                    O.pushUnique(w, V) && m(V, "update", r),
                    O.pushUnique(w, B) &&
                      ["update", "updatedData", "remove"].forEach((W) => {
                        m(B, W, function () {
                          this.chart.accessibility &&
                            (this.chart.a11yDirty = !0);
                        });
                      });
                });
            })(i || (i = {})),
            l(!0, y, M, { accessibility: { highContrastTheme: g }, lang: C }),
            i
          );
        }
      ),
      T(
        k,
        "masters/modules/accessibility.src.js",
        [
          k["Core/Globals.js"],
          k["Accessibility/Accessibility.js"],
          k["Accessibility/AccessibilityComponent.js"],
          k["Accessibility/Utils/ChartUtilities.js"],
          k["Accessibility/Utils/HTMLUtilities.js"],
          k["Accessibility/KeyboardNavigationHandler.js"],
          k["Accessibility/Components/SeriesComponent/SeriesDescriber.js"],
        ],
        function (y, A, O, F, G, U, H) {
          (y.i18nFormat = A.i18nFormat),
            (y.A11yChartUtilities = F),
            (y.A11yHTMLUtilities = G),
            (y.AccessibilityComponent = O),
            (y.KeyboardNavigationHandler = U),
            (y.SeriesAccessibilityDescriber = H),
            A.compose(
              y.Chart,
              y.Legend,
              y.Point,
              y.Series,
              y.SVGElement,
              y.RangeSelector
            );
        }
      );
  });
})(Ei);
var Xi = Ei.exports;
const Vi = Ci(Xi);
function qi(q) {
  let k;
  return {
    c() {
      (k = Mt("div")), this.h();
    },
    l(T) {
      (k = wt(T, "DIV", { style: !0, class: !0 })), vt(k).forEach(pt), this.h();
    },
    h() {
      dt(k, "style", q[0]),
        dt(k, "class", q[1]),
        At(k, "highcharts-dark", q[3]),
        At(k, "highcharts-light", !q[3]);
    },
    m(T, y) {
      Et(T, k, y), q[6](k);
    },
    p(T, [y]) {
      y & 1 && dt(k, "style", T[0]),
        y & 2 && dt(k, "class", T[1]),
        y & 10 && At(k, "highcharts-dark", T[3]),
        y & 10 && At(k, "highcharts-light", !T[3]);
    },
    i: se,
    o: se,
    d(T) {
      T && pt(k), q[6](null);
    },
  };
}
function Ki(q, k, T) {
  let y;
  Mi(q, Bi, (N) => T(3, (y = N)));
  var A =
    (this && this.__awaiter) ||
    function (N, D, c, p) {
      function f(u) {
        return u instanceof c
          ? u
          : new c(function (n) {
              n(u);
            });
      }
      return new (c || (c = Promise))(function (u, n) {
        function d(C) {
          try {
            M(p.next(C));
          } catch (P) {
            n(P);
          }
        }
        function g(C) {
          try {
            M(p.throw(C));
          } catch (P) {
            n(P);
          }
        }
        function M(C) {
          C.done ? u(C.value) : f(C.value).then(d, g);
        }
        M((p = p.apply(N, D || [])).next());
      });
    };
  let { useStockChart: O = !1 } = k,
    { options: F } = k,
    { style: G = "height: 400px" } = k,
    { class: U = "w-100" } = k,
    H,
    Y;
  je(() =>
    A(void 0, void 0, void 0, function* () {
      Vi(Wi),
        T(4, (F.chart = F.chart || {}), F),
        T(4, (F.chart.styledMode = !0), F),
        T(
          4,
          (F.credits = {
            text: "Open-Meteo.com",
            href: "http://open-meteo.com",
          }),
          F
        ),
        (Y = O ? new De.StockChart(H, F) : new De.Chart(H, F));
    })
  ),
    Di(() => {
      Y.destroy();
    });
  function S(N) {
    ke[N ? "unshift" : "push"](() => {
      (H = N), T(2, H);
    });
  }
  return (
    (q.$$set = (N) => {
      "useStockChart" in N && T(5, (O = N.useStockChart)),
        "options" in N && T(4, (F = N.options)),
        "style" in N && T(0, (G = N.style)),
        "class" in N && T(1, (U = N.class));
    }),
    [G, U, H, y, F, O, S]
  );
}
class Zi extends te {
  constructor(k) {
    super(),
      ee(this, k, Ki, qi, $t, {
        useStockChart: 5,
        options: 4,
        style: 0,
        class: 1,
      });
  }
}
function Qi(q) {
  let k,
    T,
    y,
    A,
    O,
    F = q[17].message + "",
    G,
    U,
    H,
    Y,
    S,
    N,
    D,
    c;
  return (
    (y = new zi({ props: { class: "me-2" } })),
    (Y = new Ai({ props: { class: "me-2" } })),
    {
      c() {
        (k = Mt("div")),
          (T = Mt("div")),
          oe(y.$$.fragment),
          (A = Ot()),
          (O = Mt("div")),
          (G = jt(F)),
          (U = Ot()),
          (H = Mt("button")),
          oe(Y.$$.fragment),
          (S = jt("Reload Chart")),
          this.h();
      },
      l(p) {
        k = wt(p, "DIV", { class: !0 });
        var f = vt(k);
        T = wt(f, "DIV", { class: !0, role: !0 });
        var u = vt(T);
        ne(y.$$.fragment, u), (A = Lt(u)), (O = wt(u, "DIV", {}));
        var n = vt(O);
        (G = Nt(n, F)),
          n.forEach(pt),
          (U = Lt(u)),
          (H = wt(u, "BUTTON", { type: !0, class: !0 }));
        var d = vt(H);
        ne(Y.$$.fragment, d),
          (S = Nt(d, "Reload Chart")),
          d.forEach(pt),
          u.forEach(pt),
          f.forEach(pt),
          this.h();
      },
      h() {
        dt(H, "type", "submit"),
          dt(H, "class", "btn btn-danger ms-2"),
          dt(T, "class", "alert alert-danger d-flex align-items-center"),
          dt(T, "role", "alert"),
          dt(
            k,
            "class",
            "h-100 d-flex justify-content-center align-items-center bg-secondary-subtle rounded-3"
          );
      },
      m(p, f) {
        Et(p, k, f),
          xt(k, T),
          re(y, T, null),
          xt(T, A),
          xt(T, O),
          xt(O, G),
          xt(T, U),
          xt(T, H),
          re(Y, H, null),
          xt(H, S),
          (N = !0),
          D || ((c = Dt(H, "click", q[6])), (D = !0));
      },
      p(p, f) {
        (!N || f & 32) && F !== (F = p[17].message + "") && Ut(G, F);
      },
      i(p) {
        N || (Pt(y.$$.fragment, p), Pt(Y.$$.fragment, p), (N = !0));
      },
      o(p) {
        Bt(y.$$.fragment, p), Bt(Y.$$.fragment, p), (N = !1);
      },
      d(p) {
        p && pt(k), ae(y), ae(Y), (D = !1), c();
      },
    }
  );
}
function Ji(q) {
  let k, T, y, A;
  const O = [ts, $i],
    F = [];
  function G(U, H) {
    return U[5] ? 0 : 1;
  }
  return (
    (k = G(q)),
    (T = F[k] = O[k](q)),
    {
      c() {
        T.c(), (y = ge());
      },
      l(U) {
        T.l(U), (y = ge());
      },
      m(U, H) {
        F[k].m(U, H), Et(U, y, H), (A = !0);
      },
      p(U, H) {
        let Y = k;
        (k = G(U)),
          k === Y
            ? F[k].p(U, H)
            : (Qt(),
              Bt(F[Y], 1, 1, () => {
                F[Y] = null;
              }),
              Jt(),
              (T = F[k]),
              T ? T.p(U, H) : ((T = F[k] = O[k](U)), T.c()),
              Pt(T, 1),
              T.m(y.parentNode, y));
      },
      i(U) {
        A || (Pt(T), (A = !0));
      },
      o(U) {
        Bt(T), (A = !1);
      },
      d(U) {
        U && pt(y), F[k].d(U);
      },
    }
  );
}
function $i(q) {
  let k, T, y, A, O, F, G, U, H, Y, S, N;
  return (
    (y = new Yi({ props: { class: "me-2" } })),
    (U = new Ai({ props: { class: "me-2" } })),
    {
      c() {
        (k = Mt("div")),
          (T = Mt("div")),
          oe(y.$$.fragment),
          (A = Ot()),
          (O = Mt("div")),
          (F = jt(`Parameters have changed.
							`)),
          (G = Mt("button")),
          oe(U.$$.fragment),
          (H = jt("Reload Chart")),
          this.h();
      },
      l(D) {
        k = wt(D, "DIV", { class: !0 });
        var c = vt(k);
        T = wt(c, "DIV", { class: !0, role: !0 });
        var p = vt(T);
        ne(y.$$.fragment, p), (A = Lt(p)), (O = wt(p, "DIV", {}));
        var f = vt(O);
        (F = Nt(
          f,
          `Parameters have changed.
							`
        )),
          (G = wt(f, "BUTTON", { type: !0, class: !0 }));
        var u = vt(G);
        ne(U.$$.fragment, u),
          (H = Nt(u, "Reload Chart")),
          u.forEach(pt),
          f.forEach(pt),
          p.forEach(pt),
          c.forEach(pt),
          this.h();
      },
      h() {
        dt(G, "type", "submit"),
          dt(G, "class", "btn btn-primary ms-2"),
          dt(T, "class", "alert alert-primary d-flex align-items-center"),
          dt(T, "role", "alert"),
          dt(
            k,
            "class",
            "h-100 d-flex justify-content-center align-items-center bg-secondary-subtle rounded-3"
          );
      },
      m(D, c) {
        Et(D, k, c),
          xt(k, T),
          re(y, T, null),
          xt(T, A),
          xt(T, O),
          xt(O, F),
          xt(O, G),
          re(U, G, null),
          xt(G, H),
          (Y = !0),
          S || ((N = Dt(G, "click", q[6])), (S = !0));
      },
      p: se,
      i(D) {
        Y || (Pt(y.$$.fragment, D), Pt(U.$$.fragment, D), (Y = !0));
      },
      o(D) {
        Bt(y.$$.fragment, D), Bt(U.$$.fragment, D), (Y = !1);
      },
      d(D) {
        D && pt(k), ae(y), ae(U), (S = !1), N();
      },
    }
  );
}
function ts(q) {
  let k, T;
  return (
    (k = new Zi({
      props: {
        options: q[5],
        useStockChart: q[1],
        style: q[1] ? "height: 500px" : "height: 400px",
      },
    })),
    {
      c() {
        oe(k.$$.fragment);
      },
      l(y) {
        ne(k.$$.fragment, y);
      },
      m(y, A) {
        re(k, y, A), (T = !0);
      },
      p(y, A) {
        const O = {};
        A & 32 && (O.options = y[5]),
          A & 2 && (O.useStockChart = y[1]),
          A & 2 && (O.style = y[1] ? "height: 500px" : "height: 400px"),
          k.$set(O);
      },
      i(y) {
        T || (Pt(k.$$.fragment, y), (T = !0));
      },
      o(y) {
        Bt(k.$$.fragment, y), (T = !1);
      },
      d(y) {
        ae(k, y);
      },
    }
  );
}
function es(q) {
  let k,
    T =
      '<div class="spinner-border" role="status"><span class="visually-hidden">Loading...</span></div>';
  return {
    c() {
      (k = Mt("div")), (k.innerHTML = T), this.h();
    },
    l(y) {
      (k = wt(y, "DIV", { class: !0, ["data-svelte-h"]: !0 })),
        pe(k) !== "svelte-jznz4u" && (k.innerHTML = T),
        this.h();
    },
    h() {
      dt(
        k,
        "class",
        "h-100 d-flex justify-content-center align-items-center bg-secondary-subtle rounded-3"
      );
    },
    m(y, A) {
      Et(y, k, A);
    },
    p: se,
    i: se,
    o: se,
    d(y) {
      y && pt(k);
    },
  };
}
function is(q) {
  let k,
    T,
    y = "Preview and API URL",
    A,
    O,
    F,
    G,
    U,
    H,
    Y,
    S,
    N,
    D,
    c,
    p,
    f,
    u,
    n = "API URL",
    d,
    g,
    M,
    C,
    P,
    j,
    m,
    h,
    v,
    l,
    o,
    i = {
      ctx: q,
      current: null,
      token: null,
      hasCatch: !0,
      pending: es,
      then: Ji,
      catch: Qi,
      value: 5,
      error: 17,
      blocks: [, , ,],
    };
  return (
    Ue((F = q[5]), i),
    {
      c() {
        (k = Mt("div")),
          (T = Mt("h2")),
          (T.textContent = y),
          (A = Ot()),
          (O = Mt("div")),
          i.block.c(),
          (U = Ot()),
          (H = Mt("div")),
          (Y = Mt("a")),
          (S = jt("Download XLSX")),
          (N = Ot()),
          (D = Mt("a")),
          (c = jt("Download CSV")),
          (p = Ot()),
          (f = Mt("div")),
          (u = Mt("label")),
          (u.textContent = n),
          (d = Ot()),
          (g = Mt("small")),
          (M = jt("(")),
          (C = Mt("a")),
          (P = jt("Open in new tab")),
          (j = jt(` or copy this URL into
		your application)`)),
          (m = Ot()),
          (h = Mt("input")),
          this.h();
      },
      l(t) {
        k = wt(t, "DIV", { class: !0 });
        var e = vt(k);
        (T = wt(e, "H2", { ["data-svelte-h"]: !0 })),
          pe(T) !== "svelte-1exa2dq" && (T.textContent = y),
          (A = Lt(e)),
          (O = wt(e, "DIV", { id: !0, style: !0 }));
        var s = vt(O);
        i.block.l(s),
          s.forEach(pt),
          e.forEach(pt),
          (U = Lt(t)),
          (H = wt(t, "DIV", { class: !0 }));
        var a = vt(H);
        Y = wt(a, "A", { href: !0, class: !0 });
        var b = vt(Y);
        (S = Nt(b, "Download XLSX")),
          b.forEach(pt),
          (N = Lt(a)),
          (D = wt(a, "A", { href: !0, class: !0 }));
        var r = vt(D);
        (c = Nt(r, "Download CSV")),
          r.forEach(pt),
          a.forEach(pt),
          (p = Lt(t)),
          (f = wt(t, "DIV", { class: !0 }));
        var w = vt(f);
        (u = wt(w, "LABEL", { for: !0, class: !0, ["data-svelte-h"]: !0 })),
          pe(u) !== "svelte-14m0pbn" && (u.textContent = n),
          (d = Lt(w)),
          (g = wt(w, "SMALL", { class: !0 }));
        var L = vt(g);
        (M = Nt(L, "(")), (C = wt(L, "A", { id: !0, target: !0, href: !0 }));
        var I = vt(C);
        (P = Nt(I, "Open in new tab")),
          I.forEach(pt),
          (j = Nt(
            L,
            ` or copy this URL into
		your application)`
          )),
          L.forEach(pt),
          (m = Lt(w)),
          (h = wt(w, "INPUT", { type: !0, class: !0, id: !0 })),
          w.forEach(pt),
          this.h();
      },
      h() {
        dt(O, "id", "container w-100"),
          dt(O, "style", (G = q[1] ? "height: 500px" : "height: 400px")),
          dt(k, "class", "col-12 my-4"),
          dt(Y, "href", q[3]),
          dt(Y, "class", "btn btn-outline-primary"),
          dt(D, "href", q[2]),
          dt(D, "class", "btn btn-outline-primary"),
          dt(H, "class", "col-12"),
          dt(u, "for", "api_url"),
          dt(u, "class", "form-label"),
          dt(C, "id", "api_url_link"),
          dt(C, "target", "_blank"),
          dt(C, "href", q[4]),
          dt(g, "class", "text-muted"),
          dt(h, "type", "text"),
          dt(h, "class", "form-control"),
          dt(h, "id", "api_url"),
          (h.readOnly = !0),
          dt(f, "class", "col-12 my-4");
      },
      m(t, e) {
        Et(t, k, e),
          xt(k, T),
          xt(k, A),
          xt(k, O),
          i.block.m(O, (i.anchor = null)),
          (i.mount = () => O),
          (i.anchor = null),
          Et(t, U, e),
          Et(t, H, e),
          xt(H, Y),
          xt(Y, S),
          xt(H, N),
          xt(H, D),
          xt(D, c),
          Et(t, p, e),
          Et(t, f, e),
          xt(f, u),
          xt(f, d),
          xt(f, g),
          xt(g, M),
          xt(g, C),
          xt(C, P),
          xt(g, j),
          xt(f, m),
          xt(f, h),
          ze(h, q[4]),
          (v = !0),
          l || ((o = Dt(h, "input", q[12])), (l = !0));
      },
      p(t, [e]) {
        (q = t),
          (i.ctx = q),
          (e & 32 && F !== (F = q[5]) && Ue(F, i)) || Li(i, q, e),
          (!v ||
            (e & 2 && G !== (G = q[1] ? "height: 500px" : "height: 400px"))) &&
            dt(O, "style", G),
          (!v || e & 8) && dt(Y, "href", q[3]),
          (!v || e & 4) && dt(D, "href", q[2]),
          (!v || e & 16) && dt(C, "href", q[4]),
          e & 16 && h.value !== q[4] && ze(h, q[4]);
      },
      i(t) {
        v || (Pt(i.block), (v = !0));
      },
      o(t) {
        for (let e = 0; e < 3; e += 1) {
          const s = i.blocks[e];
          Bt(s);
        }
        v = !1;
      },
      d(t) {
        t && (pt(k), pt(U), pt(H), pt(p), pt(f)),
          i.block.d(),
          (i.token = null),
          (i = null),
          (l = !1),
          o();
      },
    }
  );
}
function ss(q, k) {
  const T = {};
  for (const y in q) q[y] && q[y] != "" && q[y] !== k[y] && (T[y] = q[y]);
  return T;
}
function os(q, k) {
  let T = [];
  const y = {
    0: "fair",
    1: "mainly clear",
    2: "partly cloudy",
    3: "overcast",
    45: "fog",
    48: "depositing rime fog",
    51: "light drizzle",
    53: "moderate drizzle",
    55: "dense drizzle",
    56: "light freezing drizzle",
    57: "dense freezing drizzle",
    61: "slight rain",
    63: "moderate rain",
    65: "heavy rain",
    66: "light freezing rain",
    67: "heavy freezing rain",
    71: "slight snow fall",
    73: "moderate snow fall",
    75: "heavy snow fall",
    77: "snow grains",
    80: "slight rain showers",
    81: "moderate rain showers",
    82: "heavy rain showers",
    85: "slight snow showers",
    86: "heavy snow showers",
    95: "slight to moderate thunderstorm",
    96: "thunderstorm with slight hail",
    99: "thunderstorm with heavy hail",
  };
  let A = [];
  ["hourly", "six_hourly", "three_hourly", "daily", "minutely_15"].forEach(
    function (N, D) {
      N in q &&
        Object.entries(q[N] || []).forEach(function (c) {
          if (c[0] == "time" || c[0] == "sunrise" || c[0] == "sunset") return;
          let p = (q[N].time[0] + q.utc_offset_seconds) * 1e3,
            f = (q[N].time[1] - q[N].time[0]) * 1e3,
            u = q[`${N}_units`][c[0]],
            n = null;
          for (let g = 0; g < T.length; g++) T[g].title.text == u && (n = g);
          n == null && (T.push({ title: { text: u } }), (n = T.length - 1));
          let d = {
            name: c[0],
            data: c[1],
            yAxis: n,
            pointStart: p,
            pointInterval: f,
            type:
              u == "mm" || u == "cm" || u == "inch" || u == "MJ/m²"
                ? "column"
                : "line",
            tooltip: { valueSuffix: " " + u },
            dataGrouping: { groupPixelWidth: 12 },
          };
          c[0] == "weathercode" &&
            (d.tooltip.pointFormatter = function () {
              let g = y[this.y];
              return (
                '<span style="color:' +
                this.series.color +
                '">●</span> ' +
                this.series.name +
                ": <b>" +
                g +
                "</b> (" +
                this.y +
                " wmo)<br/>"
              );
            }),
            A.push(d);
        });
    }
  );
  let O = [];
  if ("daily" in q && "sunrise" in q.daily && "sunset" in q.daily) {
    let N = q.daily.sunrise,
      D = q.daily.sunset;
    N.map(function (c, p) {
      return {
        color: "rgb(255, 255, 194)",
        from: (c + q.utc_offset_seconds) * 1e3,
        to: (D[p] + q.utc_offset_seconds) * 1e3,
      };
    });
  }
  let F = q.latitude.toFixed(2),
    G = q.longitude.toFixed(2),
    U = `${F}°N ${G}°E`;
  if ("elevation" in q) {
    let N = q.elevation.toFixed(0);
    U = `${U} ${N}m above sea level`;
  }
  let H = q.generationtime_ms.toFixed(2),
    Y = q.utc_offset_seconds < 0 ? "" : "+";
  return {
    title: { text: U },
    subtitle: {
      text: `Generated in ${H}ms, downloaded in ${k.toFixed(
        0
      )}ms, time in GMT${Y}${q.utc_offset_seconds / 3600}`,
    },
    chart: { zoomType: "x" },
    yAxis: T,
    xAxis: {
      type: "datetime",
      plotLines: [
        {
          value: Date.now() + q.utc_offset_seconds * 1e3,
          color: "red",
          width: 2,
        },
      ],
      plotBands: O,
    },
    legend: { layout: "vertical", align: "right", verticalAlign: "middle" },
    plotOptions: { series: { label: { connectorAllowed: !1 } } },
    series: A,
    responsive: {
      rules: [
        {
          condition: { maxWidth: 800 },
          chartOptions: {
            legend: {
              layout: "horizontal",
              align: "center",
              verticalAlign: "bottom",
            },
          },
        },
      ],
    },
    tooltip: { shared: A.length <= 5, animation: !1 },
  };
}
function ns(q, k, T) {
  let y,
    A,
    O,
    F,
    G = se,
    U = () => (G(), (G = Pi(S, (C) => T(10, (F = C)))), S),
    H;
  Mi(q, Ye, (C) => T(11, (H = C))), q.$$.on_destroy.push(() => G());
  var Y =
    (this && this.__awaiter) ||
    function (C, P, j, m) {
      function h(v) {
        return v instanceof j
          ? v
          : new j(function (l) {
              l(v);
            });
      }
      return new (j || (j = Promise))(function (v, l) {
        function o(e) {
          try {
            t(m.next(e));
          } catch (s) {
            l(s);
          }
        }
        function i(e) {
          try {
            t(m.throw(e));
          } catch (s) {
            l(s);
          }
        }
        function t(e) {
          e.done ? v(e.value) : h(e.value).then(o, i);
        }
        t((m = m.apply(C, P || [])).next());
      });
    };
  let { params: S } = k;
  U();
  let { type: N = "forecast" } = k,
    { action: D = "forecast" } = k,
    { defaultParameter: c } = k,
    { useStockChart: p = !1 } = k;
  function f(C, P) {
    let j = N == "forecast" ? "api" : `${N}-api`,
      m,
      h = {};
    switch (C.use) {
      case "commercial":
        (m = `https://customer-${j}.open-meteo.com/v1/${D}?`),
          (h = { apikey: C.apikey });
        break;
      case "self_hosted":
        m = `${C.self_host_server}/v1/${D}?`;
        break;
      default:
        m = `https://${j}.open-meteo.com/v1/${D}?`;
    }
    let v = ss(Object.assign(Object.assign({}, P), h), c);
    return `${m}${new URLSearchParams(v)}`.replaceAll("%2C", ",");
  }
  let u = Promise.resolve(null);
  function n() {
    T(5, (u = Promise.resolve(null)));
  }
  S.subscribe(n), Ye.subscribe(n);
  function d() {
    return Y(this, void 0, void 0, function* () {
      const C = f(
          H,
          Object.assign(Object.assign({}, F), {
            format: "json",
            timeformat: "unixtime",
          })
        ),
        P = performance.now(),
        j = yield fetch(C);
      if (!j.ok) throw new Error(yield j.text());
      return os(yield j.json(), performance.now() - P);
    });
  }
  function g() {
    T(5, (u = d()));
  }
  je(() => {
    g();
  });
  function M() {
    (y = this.value), T(4, y), T(11, H), T(10, F);
  }
  return (
    (q.$$set = (C) => {
      "params" in C && U(T(0, (S = C.params))),
        "type" in C && T(7, (N = C.type)),
        "action" in C && T(8, (D = C.action)),
        "defaultParameter" in C && T(9, (c = C.defaultParameter)),
        "useStockChart" in C && T(1, (p = C.useStockChart));
    }),
    (q.$$.update = () => {
      q.$$.dirty & 3072 && T(4, (y = f(H, F))),
        q.$$.dirty & 3072 &&
          T(
            3,
            (A = f(H, Object.assign(Object.assign({}, F), { format: "xlsx" })))
          ),
        q.$$.dirty & 3072 &&
          T(
            2,
            (O = f(H, Object.assign(Object.assign({}, F), { format: "csv" })))
          );
    }),
    [S, p, O, A, y, u, g, N, D, c, F, H, M]
  );
}
class Es extends te {
  constructor(k) {
    super(),
      ee(this, k, ns, is, $t, {
        params: 0,
        type: 7,
        action: 8,
        defaultParameter: 9,
        useStockChart: 1,
      });
  }
}
const rs = {
    days: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday",
    ],
    daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
    daysMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December",
    ],
    monthsShort: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec",
    ],
    meridiem: ["am", "pm"],
    suffix: ["st", "nd", "rd", "th"],
    todayBtn: "Today",
    clearBtn: "Clear",
    timeView: "Show time view",
    backToDate: "Back to calendar view",
  },
  as = {
    theme: "sdt-calendar-colors",
    mode: "auto",
    format: "yyyy-mm-dd",
    formatType: "standard",
    minuteIncrement: 1,
    weekStart: 1,
    inputClasses: "",
    todayBtnClasses: "sdt-action-btn sdt-today-btn",
    clearBtnClasses: "sdt-action-btn sdt-clear-btn",
    todayBtn: !0,
    clearBtn: !0,
    autoclose: !0,
    clearToggle: !0,
    i18n: rs,
  },
  qt = 0,
  ce = 1,
  Xt = 2;
function we(q, k, T, y, A) {
  if (T === qt) {
    let g = 10,
      M = 20;
    const C = -1,
      P = [];
    let j = [],
      m = q.getFullYear() - (q.getFullYear() % 10);
    (m -= m % 20 ? 12 : 10), m % 10 && ((g = 12), (M = 22));
    for (let v = 0; v < 32; v++)
      j.push(m + v), j.length === 4 && (P.push(j), (j = []));
    let h = null;
    return (
      k || (k = new Date()),
      k.getFullYear() >= m && (h = k.getFullYear() % m),
      { years: P, todayMark: C, nextFrom: M, prevTo: g, selectionMark: h }
    );
  }
  if (T === ce) {
    let g = [],
      M = [],
      C = 12,
      P = 24;
    const j = q.toISOString().split("T")[0].substring(0, 8),
      m = new Date(j + "01 00:00:00"),
      h = m.getFullYear() - 1;
    m.setFullYear(h);
    let v = 0;
    for (let o = 0; o < 3; o++) {
      for (let i = 0; i < 12; i++)
        m.setMonth(i),
          M.push(y.monthsShort[i % 12]),
          M.length === 4 && (g.push(M), (M = []));
      m.setFullYear(m.getFullYear() + 1);
    }
    let l = null;
    return (
      k || (k = new Date()),
      k.getFullYear() - h >= 0 &&
        k.getFullYear() - h <= 2 &&
        (l = k.getMonth() + (k.getFullYear() - h || 0) * 12),
      { months: g, todayMark: v, nextFrom: P, prevTo: C, selectionMark: l }
    );
  }
  let O = q || new Date(),
    F = O.getFullYear(),
    G = O.getMonth();
  O.getDate(), O.getHours();
  let U = new Date(),
    H = new Date(F, G - 1, 28, 0, 0, 0, 0),
    Y = _e.getDaysInMonth(H.getFullYear(), H.getMonth());
  H.setDate(Y), H.setDate(Y - ((H.getDay() - A + 7) % 7));
  let S = new Date(H);
  S.setDate(S.getDate() + 42);
  let N = S.valueOf(),
    D = [],
    c = [],
    p = -1,
    f = null,
    u = 0,
    n = 42,
    d = 0;
  for (; H.valueOf() < N; )
    d++,
      c.push(new Date(H)),
      H.getFullYear() < F || (H.getFullYear() === F && H.getMonth() < G)
        ? (u = d)
        : n === 42 &&
          (H.getFullYear() > F ||
            (H.getFullYear() === F && H.getMonth() > G)) &&
          (n = d - 1),
      H.setDate(H.getDate() + 1),
      H.getFullYear() === U.getFullYear() &&
        H.getMonth() === U.getMonth() &&
        H.getDate() === U.getDate() &&
        (p = d),
      !f &&
        k &&
        H.getFullYear() === k.getFullYear() &&
        H.getMonth() === k.getMonth() &&
        H.getDate() === k.getDate() &&
        (f = d),
      c.length === 7 && (D.push(c), (c = []));
  return { grid: D, todayMark: p, prevTo: u, nextFrom: n, selectionMark: f };
}
function Se(q, k) {
  return q < 0 && (q = 42 + q), { x: q % 7, y: Math.floor(q / 7) };
}
const _e = {
  isLeapYear: function (q) {
    return (q % 4 === 0 && q % 100 !== 0) || q % 400 === 0;
  },
  getDaysInMonth: function (q, k) {
    return [
      31,
      _e.isLeapYear(q) ? 29 : 28,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31,
    ][k];
  },
};
function We(q, k) {
  return q instanceof Date
    ? q.getFullYear() < k.getFullYear() ||
        q.getMonth() < k.getMonth() ||
        q.getDate() <= k.getDate()
    : !1;
}
function Xe(q, k) {
  return q instanceof Date
    ? q.getFullYear() > k.getFullYear() ||
        q.getMonth() > k.getMonth() ||
        q.getDate() >= k.getDate()
    : !1;
}
function ve(q, k, T, y) {
  if (q instanceof Date) return q;
  const A =
    y === "php"
      ? { date: "Y-m-d", datetime: "Y-m-d H:i", datetime_s: "Y-m-d H:i:s" }
      : {
          date: "yyyy-mm-dd",
          datetime: "yyyy-mm-dd hh:ii",
          datetime_s: "yyyy-mm-dd hh:ii:ss",
        };
  let O;
  /^\d{4}\-\d{1,2}\-\d{1,2}$/.test(q)
    ? (O = ie.parseFormat(A.date, y))
    : /^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}$/.test(q)
    ? (O = ie.parseFormat(A.datetime, y))
    : /^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}\:\d{1,2}[Z]{0,1}$/.test(q)
    ? (O = ie.parseFormat(A.datetime_s, y))
    : (O = ie.parseFormat(k, y));
  const F = (q && q.toString().match(ie.nonpunctuation)) || [];
  (q = new Date()), q.setHours(0, 0, 0, 0);
  const G = {},
    { setters_order: U, setters_map: H } = ie.setters(y);
  let Y, S;
  if (F.length !== O.parts.length && O.parts.includes("S")) {
    const p = F[O.parts.indexOf("S") - 1].match(/(\d+)([a-zA-Z]+)/).slice(1, 3);
    F.splice(O.parts.indexOf("S") - 1, 1, ...p);
  }
  if (F.length === O.parts.length) {
    for (var N = 0, D = O.parts.length; N < D; N++) {
      if (((Y = parseInt(F[N], 10)), (S = O.parts[N]), isNaN(Y)))
        if (y === "standard")
          switch (S) {
            case "MM":
              Y = T.months.indexOf(F[N]) + 1;
              break;
            case "M":
              Y = T.monthsShort.indexOf(F[N]) + 1;
              break;
            case "p":
            case "P":
              Y = T.meridiem.indexOf(F[N].toLowerCase());
              break;
          }
        else
          switch (S) {
            case "D":
              Y = T.daysShort.indexOf(F[N]) + 1;
              break;
            case "l":
              Y = T.days.indexOf(F[N]) + 1;
              break;
            case "F":
              Y = T.months.indexOf(F[N]) + 1;
              break;
            case "M":
              Y = T.monthsShort.indexOf(F[N]) + 1;
              break;
            case "a":
            case "A":
              Y = T.meridiem.indexOf(F[N].toLowerCase());
              break;
          }
      G[S] = Y;
    }
    for (var N = 0, c; N < U.length; N++)
      (c = U[N]), c in G && !isNaN(G[c]) && H[`${c}`] && H[`${c}`](q, G[c]);
  }
  return q;
}
function Ee(q, k, T, y) {
  if (q === null) return "";
  const A = q.getDate();
  let O;
  if (y === "standard")
    (O = {
      t: q.getTime(),
      yy: q.getFullYear().toString().substring(2),
      yyyy: q.getFullYear(),
      m: q.getMonth() + 1,
      M: T.monthsShort[q.getMonth()],
      MM: T.months[q.getMonth()],
      d: A,
      D: T.daysShort[q.getDay()],
      DD: T.days[q.getDay()],
      S:
        A % 10 && A % 10 <= T.suffix.length
          ? T.suffix[(A % 10) - 1]
          : T.suffix[T.suffix.length - 1],
      p: T.meridiem.length === 2 ? T.meridiem[q.getHours() < 12 ? 0 : 1] : "",
      h: q.getHours(),
      ii: (q.getMinutes() < 10 ? "0" : "") + q.getMinutes(),
      ss: (q.getUTCSeconds() < 10 ? "0" : "") + q.getUTCSeconds(),
    }),
      T.meridiem.length === 2
        ? (O.H = O.h % 12 === 0 ? 12 : O.h % 12)
        : (O.H = O.h),
      (O.HH = (O.H < 10 ? "0" : "") + O.H),
      (O.P = O.p.toUpperCase()),
      (O.hh = (O.h < 10 ? "0" : "") + O.h),
      (O.i = O.ii),
      (O.s = O.ss),
      (O.dd = (O.d < 10 ? "0" : "") + O.d),
      (O.mm = (O.m < 10 ? "0" : "") + O.m);
  else if (y === "php")
    (O = {
      y: q.getFullYear().toString().substring(2),
      Y: q.getFullYear(),
      F: T.months[q.getMonth()],
      M: T.monthsShort[q.getMonth()],
      n: q.getMonth() + 1,
      t: _e.getDaysInMonth(q.getFullYear(), q.getMonth()),
      j: q.getDate(),
      l: T.days[q.getDay()],
      D: T.daysShort[q.getDay()],
      w: q.getDay(),
      N: q.getDay() === 0 ? 7 : q.getDay(),
      S:
        A % 10 && A % 10 <= T.suffix.length
          ? T.suffix[(A % 10) - 1]
          : T.suffix[T.suffix.length - 1],
      a: T.meridiem.length === 2 ? T.meridiem[q.getHours() < 12 ? 0 : 1] : "",
      g: q.getHours() % 12 === 0 ? 12 : q.getHours() % 12,
      G: q.getHours(),
      i: q.getMinutes(),
      s: q.getSeconds(),
      U: Math.floor(q.getTime() / 1e3),
    }),
      (O.m = (O.n < 10 ? "0" : "") + O.n),
      (O.d = (O.j < 10 ? "0" : "") + O.j),
      (O.A = O.a.toString().toUpperCase()),
      (O.h = (O.g < 10 ? "0" : "") + O.g),
      (O.H = (O.G < 10 ? "0" : "") + O.G),
      (O.i = (O.i < 10 ? "0" : "") + O.i),
      (O.s = (O.s < 10 ? "0" : "") + O.s);
  else throw new Error("Invalid format type.");
  let F = [];
  k = ie.parseFormat(k, y);
  for (var G = 0, U = k.parts.length; G < U; G++)
    k.separators.length && F.push(k.separators.shift()), F.push(O[k.parts[G]]);
  return k.separators.length && F.push(k.separators.shift()), F.join("");
}
const ie = {
  validParts: function (q) {
    if (q === "standard")
      return /t|hh?|HH?|p|P|z|ii?|ss?|dd?|DD?|S|mm?|MM?|yy(?:yy)?/g;
    if (q === "php") return /[dDjlNwzFmMnStyYaABgGhHisU]/g;
    throw new Error("Invalid format type.");
  },
  nonpunctuation: /[^ -\/:-@\[-`{-~\t\n\rTZ]+/g,
  parseFormat: function (q, k) {
    var T = q.replace(this.validParts(k), "\0").split("\0"),
      y = q.match(this.validParts(k));
    return (
      (!T || !T.length || !y || y.length === 0) &&
        (console.warn("invalid date format", T, y), (y = [])),
      { separators: T, parts: y }
    );
  },
  setters: function (q) {
    let k, T;
    return (
      q === "standard"
        ? ((k = [
            "yyyy",
            "yy",
            "m",
            "mm",
            "M",
            "MM",
            "d",
            "dd",
            "D",
            "DD",
            "hh",
            "h",
            "HH",
            "H",
            "ii",
            "i",
            "ss",
            "s",
            "S",
            "p",
            "P",
            "t",
          ]),
          (T = {
            hh: (y, A) => y.setHours(A),
            h: (y, A) => y.setHours(A),
            HH: (y, A) => y.setHours(A === 12 ? 0 : A),
            H: (y, A) => y.setHours(A === 12 ? 0 : A),
            i: (y, A) => y.setMinutes(A),
            s: (y, A) => y.setSeconds(A),
            yyyy: (y, A) => y.setFullYear(A),
            yy: (y, A) => y.setFullYear((A < 50 ? 2e3 : 1900) + A),
            m: (y, A) => {
              for (A -= 1; A < 0; ) A += 12;
              for (A %= 12, y.setMonth(A); y.getMonth() !== A; ) {
                if (isNaN(y.getMonth())) return y;
                y.setDate(y.getDate() - 1);
              }
              return y;
            },
            d: (y, A) => y.setDate(A),
            p: (y, A) =>
              y.setHours(
                A === 1 && y.getHours() < 12 ? y.getHours() + 12 : y.getHours()
              ),
            t: (y, A) => y.setTime(A),
            mm: () => {},
            M: () => {},
            MM: () => {},
            ii: () => {},
            ss: () => {},
            dd: () => {},
            D: () => {},
            DD: () => {},
            P: () => {},
          }),
          (T.mm = T.M = T.MM = T.m),
          (T.ii = T.i),
          (T.ss = T.s),
          (T.dd = T.D = T.DD = T.d),
          (T.P = T.p))
        : ((k = [
            "Y",
            "yy",
            "m",
            "M",
            "F",
            "n",
            "d",
            "D",
            "j",
            "l",
            "N",
            "S",
            "H",
            "G",
            "h",
            "g",
            "i",
            "s",
            "p",
            "P",
            "U",
          ]),
          (T = {
            H: (y, A) => y.setHours(A),
            G: (y, A) => y.setHours(A),
            h: (y, A) => y.setHours(A === 12 ? 0 : A),
            g: (y, A) => y.setHours(A === 12 ? 0 : A),
            i: (y, A) => y.setMinutes(A),
            s: (y, A) => y.setSeconds(A),
            Y: (y, A) => y.setFullYear(A),
            yy: (y, A) => y.setFullYear((A < 50 ? 2e3 : 1900) + A),
            m: (y, A) => {
              for (A -= 1; A < 0; ) A += 12;
              for (A %= 12, y.setMonth(A); y.getMonth() !== A; ) {
                if (isNaN(y.getMonth())) return y;
                y.setDate(y.getDate() - 1);
              }
              return y;
            },
            d: (y, A) => y.setDate(A),
            a: (y, A) => y.setHours(A === 1 ? y.getHours() + 12 : y.getHours()),
            U: (y, A) => y.setTime(A * 1e3),
          }),
          (T.F = T.M = T.m),
          (T.D = T.j = T.l = T.N = T.d),
          (T.A = T.a)),
      { setters_order: k, setters_map: T }
    );
  },
};
function ls(q, { inputEl: k, visible: T, inputRect: y }) {
  if (!T) {
    const O = q.getBoundingClientRect(),
      F = ["position: absolute", "z-index: 12250"];
    F.push(
      y.x + O.width > window.innerWidth ? "right: 1rem" : `left: ${y.left}px`
    ),
      O.height + O.top > window.innerHeight + window.scrollY
        ? F.push("bottom: 1rem")
        : F.push(`top: ${y.top + y.height + window.scrollY}px`),
      (q.style = F.join(";")),
      (q.hidden = !1),
      document.body.appendChild(q);
  }
  q.hidden = !1;
  function A() {
    q.parentNode && q.parentNode.removeChild(q);
  }
  return { destroy: A };
}
function hs(
  q,
  {
    delay: k = 0,
    duration: T = 400,
    easing: y = ji,
    start: A = 0,
    end: O = 1,
    opacity: F = 0,
  } = {}
) {
  const G = getComputedStyle(q),
    U = +G.opacity,
    H = G.transform === "none" ? "" : G.transform,
    Y = 1 - A,
    S = U * (1 - F);
  return {
    delay: k,
    duration: T,
    easing: y,
    css: (N, D) => `
        transform: ${H} scale(${O !== 1 ? A + O * D : 1 - Y * D});
        opacity: ${U - S * D};
      `,
  };
}
function Ve(q, k, T) {
  const y = q.slice();
  return (y[40] = k[T]), (y[42] = T), y;
}
function qe(q, k, T) {
  const y = q.slice();
  return (y[43] = k[T]), (y[45] = T), y;
}
function Ke(q, k, T) {
  const y = q.slice();
  return (y[46] = k[T]), y;
}
function Ze(q, k, T) {
  const y = q.slice();
  return (y[40] = k[T]), (y[42] = T), y;
}
function Qe(q, k, T) {
  const y = q.slice();
  return (y[50] = k[T]), (y[45] = T), y;
}
function Je(q, k, T) {
  const y = q.slice();
  return (y[40] = k[T]), (y[42] = T), y;
}
function $e(q, k, T) {
  const y = q.slice();
  return (y[53] = k[T]), (y[45] = T), y;
}
function ti(q) {
  let k, T, y, A, O, F;
  return {
    c() {
      (k = Mt("button")), (T = zt("svg")), (y = zt("path")), this.h();
    },
    l(G) {
      k = wt(G, "BUTTON", { class: !0, title: !0 });
      var U = vt(k);
      T = Gt(U, "svg", {
        class: !0,
        xmlns: !0,
        viewBox: !0,
        width: !0,
        height: !0,
      });
      var H = vt(T);
      (y = Gt(H, "path", { "fill-rule": !0, d: !0 })),
        vt(y).forEach(pt),
        H.forEach(pt),
        U.forEach(pt),
        this.h();
    },
    h() {
      dt(y, "fill-rule", "evenodd"),
        dt(
          y,
          "d",
          "M1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0zM8 0a8 8 0 100 16A8 8 0 008 0zm.5 4.75a.75.75 0 00-1.5 0v3.5a.75.75 0 00.471.696l2.5 1a.75.75 0 00.557-1.392L8.5 7.742V4.75z"
        ),
        dt(T, "class", "sdt-svg svelte-6hyah7"),
        dt(T, "xmlns", "http://www.w3.org/2000/svg"),
        dt(T, "viewBox", "0 0 16 16"),
        dt(T, "width", "16"),
        dt(T, "height", "16"),
        dt(
          k,
          "class",
          "std-btn std-btn-header icon-btn sdt-time-icon svelte-6hyah7"
        ),
        dt(k, "title", (A = q[0].timeView));
    },
    m(G, U) {
      Et(G, k, U),
        xt(k, T),
        xt(T, y),
        O || ((F = Dt(k, "click", Kt(q[21]))), (O = !0));
    },
    p(G, U) {
      U[0] & 1 && A !== (A = G[0].timeView) && dt(k, "title", A);
    },
    d(G) {
      G && pt(k), (O = !1), F();
    },
  };
}
function ei(q) {
  let k,
    T,
    y,
    A,
    O,
    F,
    G,
    U,
    H = Ft(q[10].years),
    Y = [];
  for (let S = 0; S < H.length; S += 1) Y[S] = si(Je(q, H, S));
  return {
    c() {
      (k = Mt("table")), (T = Mt("tbody"));
      for (let S = 0; S < Y.length; S += 1) Y[S].c();
      this.h();
    },
    l(S) {
      k = wt(S, "TABLE", { class: !0, style: !0 });
      var N = vt(k);
      T = wt(N, "TBODY", { class: !0, style: !0 });
      var D = vt(T);
      for (let c = 0; c < Y.length; c += 1) Y[c].l(D);
      D.forEach(pt), N.forEach(pt), this.h();
    },
    h() {
      dt(T, "class", "sdt-tbody-lg svelte-6hyah7"),
        dt(T, "style", (y = `transform: translateY(-${q[7]}px); color: red`)),
        At(T, "animate-transition", !!q[8]),
        dt(k, "class", "sdt-table svelte-6hyah7"),
        Ge(k, "max-height", "221px"),
        Ge(k, "height", "221px");
    },
    m(S, N) {
      Et(S, k, N), xt(k, T);
      for (let D = 0; D < Y.length; D += 1) Y[D] && Y[D].m(T, null);
      (F = !0),
        G ||
          ((U = [Dt(T, "outroend", q[20]), Dt(T, "transitionend", q[31])]),
          (G = !0));
    },
    p(S, N) {
      if (((q = S), N[0] & 623624)) {
        H = Ft(q[10].years);
        let D;
        for (D = 0; D < H.length; D += 1) {
          const c = Je(q, H, D);
          Y[D] ? Y[D].p(c, N) : ((Y[D] = si(c)), Y[D].c(), Y[D].m(T, null));
        }
        for (; D < Y.length; D += 1) Y[D].d(1);
        Y.length = H.length;
      }
      (!F ||
        (N[0] & 128 &&
          y !== (y = `transform: translateY(-${q[7]}px); color: red`))) &&
        dt(T, "style", y),
        (!F || N[0] & 256) && At(T, "animate-transition", !!q[8]);
    },
    i(S) {
      F ||
        (S &&
          he(() => {
            F &&
              (O && O.end(1),
              (A = Ce(T, q[12], { duration: ye, start: q[14], opacity: 1 })),
              A.start());
          }),
        (F = !0));
    },
    o(S) {
      A && A.invalidate(),
        S && (O = Re(T, q[12], { duration: ye, end: q[13], start: 1 })),
        (F = !1);
    },
    d(S) {
      S && pt(k), Me(Y, S), S && O && O.end(), (G = !1), xe(U);
    },
  };
}
function ii(q, k) {
  let T,
    y,
    A = k[53] + "",
    O,
    F,
    G,
    U;
  function H() {
    return k[30](k[53]);
  }
  return {
    key: q,
    first: null,
    c() {
      (T = Mt("td")), (y = Mt("button")), (O = jt(A)), this.h();
    },
    l(Y) {
      T = wt(Y, "TD", { class: !0 });
      var S = vt(T);
      y = wt(S, "BUTTON", { class: !0 });
      var N = vt(y);
      (O = Nt(N, A)), N.forEach(pt), S.forEach(pt), this.h();
    },
    h() {
      dt(y, "class", "std-btn svelte-6hyah7"),
        (y.disabled = F =
          k[16](new Date(k[53], k[3].getMonth(), k[3].getDate()))),
        At(y, "not-current", !k[15](k[42] * 4 + k[45])),
        dt(T, "class", "sdt-cal-td svelte-6hyah7"),
        At(T, "is-selected", k[42] * 4 + k[45] === k[10].selectionMark),
        (this.first = T);
    },
    m(Y, S) {
      Et(Y, T, S),
        xt(T, y),
        xt(y, O),
        G || ((U = Dt(y, "click", Kt(H))), (G = !0));
    },
    p(Y, S) {
      (k = Y),
        S[0] & 1024 && A !== (A = k[53] + "") && Ut(O, A),
        S[0] & 1032 &&
          F !== (F = k[16](new Date(k[53], k[3].getMonth(), k[3].getDate()))) &&
          (y.disabled = F),
        S[0] & 33792 && At(y, "not-current", !k[15](k[42] * 4 + k[45])),
        S[0] & 1024 &&
          At(T, "is-selected", k[42] * 4 + k[45] === k[10].selectionMark);
    },
    d(Y) {
      Y && pt(T), (G = !1), U();
    },
  };
}
function si(q) {
  let k,
    T = [],
    y = new Map(),
    A,
    O = Ft(q[40]);
  const F = (G) => G[45];
  for (let G = 0; G < O.length; G += 1) {
    let U = $e(q, O, G),
      H = F(U);
    y.set(H, (T[G] = ii(H, U)));
  }
  return {
    c() {
      k = Mt("tr");
      for (let G = 0; G < T.length; G += 1) T[G].c();
      (A = Ot()), this.h();
    },
    l(G) {
      k = wt(G, "TR", { class: !0 });
      var U = vt(k);
      for (let H = 0; H < T.length; H += 1) T[H].l(U);
      (A = Lt(U)), U.forEach(pt), this.h();
    },
    h() {
      dt(k, "class", "sdt-cal-td svelte-6hyah7");
    },
    m(G, U) {
      Et(G, k, U);
      for (let H = 0; H < T.length; H += 1) T[H] && T[H].m(k, null);
      xt(k, A);
    },
    p(G, U) {
      U[0] & 623624 &&
        ((O = Ft(G[40])), (T = Ae(T, U, F, 1, G, O, y, k, He, ii, A, $e)));
    },
    d(G) {
      G && pt(k);
      for (let U = 0; U < T.length; U += 1) T[U].d();
    },
  };
}
function oi(q) {
  let k,
    T,
    y,
    A,
    O,
    F,
    G,
    U,
    H = Ft(q[10].months),
    Y = [];
  for (let S = 0; S < H.length; S += 1) Y[S] = ri(Ze(q, H, S));
  return {
    c() {
      (k = Mt("table")), (T = Mt("tbody"));
      for (let S = 0; S < Y.length; S += 1) Y[S].c();
      this.h();
    },
    l(S) {
      k = wt(S, "TABLE", { class: !0 });
      var N = vt(k);
      T = wt(N, "TBODY", { class: !0, style: !0 });
      var D = vt(T);
      for (let c = 0; c < Y.length; c += 1) Y[c].l(D);
      D.forEach(pt), N.forEach(pt), this.h();
    },
    h() {
      dt(T, "class", "sdt-tbody-lg svelte-6hyah7"),
        dt(T, "style", (y = `transform: translateY(-${q[7]}px)`)),
        At(T, "animate-transition", !!q[8]),
        dt(k, "class", "sdt-table svelte-6hyah7");
    },
    m(S, N) {
      Et(S, k, N), xt(k, T);
      for (let D = 0; D < Y.length; D += 1) Y[D] && Y[D].m(T, null);
      (F = !0),
        G ||
          ((U = [Dt(T, "outroend", q[20]), Dt(T, "transitionend", q[33])]),
          (G = !0));
    },
    p(S, N) {
      if (((q = S), N[0] & 623625)) {
        H = Ft(q[10].months);
        let D;
        for (D = 0; D < H.length; D += 1) {
          const c = Ze(q, H, D);
          Y[D] ? Y[D].p(c, N) : ((Y[D] = ri(c)), Y[D].c(), Y[D].m(T, null));
        }
        for (; D < Y.length; D += 1) Y[D].d(1);
        Y.length = H.length;
      }
      (!F || (N[0] & 128 && y !== (y = `transform: translateY(-${q[7]}px)`))) &&
        dt(T, "style", y),
        (!F || N[0] & 256) && At(T, "animate-transition", !!q[8]);
    },
    i(S) {
      F ||
        (S &&
          he(() => {
            F &&
              (O && O.end(1),
              (A = Ce(T, q[12], { duration: ye, start: q[14], opacity: 1 })),
              A.start());
          }),
        (F = !0));
    },
    o(S) {
      A && A.invalidate(),
        S && (O = Re(T, q[12], { duration: ye, end: q[13], start: 1 })),
        (F = !1);
    },
    d(S) {
      S && pt(k), Me(Y, S), S && O && O.end(), (G = !1), xe(U);
    },
  };
}
function ni(q, k) {
  let T,
    y,
    A = k[50] + "",
    O,
    F,
    G,
    U;
  function H() {
    return k[32](k[50]);
  }
  return {
    key: q,
    first: null,
    c() {
      (T = Mt("td")), (y = Mt("button")), (O = jt(A)), this.h();
    },
    l(Y) {
      T = wt(Y, "TD", { class: !0 });
      var S = vt(T);
      y = wt(S, "BUTTON", { class: !0 });
      var N = vt(y);
      (O = Nt(N, A)), N.forEach(pt), S.forEach(pt), this.h();
    },
    h() {
      dt(y, "class", "std-btn svelte-6hyah7"),
        (y.disabled = F =
          k[16](
            new Date(
              k[3].getFullYear(),
              k[0].monthsShort.indexOf(k[50]),
              k[3].getDate()
            )
          )),
        At(y, "not-current", !k[15](k[42] * 4 + k[45])),
        dt(T, "class", "sdt-cal-td svelte-6hyah7"),
        At(T, "is-selected", k[42] * 4 + k[45] === k[10].selectionMark),
        (this.first = T);
    },
    m(Y, S) {
      Et(Y, T, S),
        xt(T, y),
        xt(y, O),
        G || ((U = Dt(y, "click", Kt(H))), (G = !0));
    },
    p(Y, S) {
      (k = Y),
        S[0] & 1024 && A !== (A = k[50] + "") && Ut(O, A),
        S[0] & 1033 &&
          F !==
            (F = k[16](
              new Date(
                k[3].getFullYear(),
                k[0].monthsShort.indexOf(k[50]),
                k[3].getDate()
              )
            )) &&
          (y.disabled = F),
        S[0] & 33792 && At(y, "not-current", !k[15](k[42] * 4 + k[45])),
        S[0] & 1024 &&
          At(T, "is-selected", k[42] * 4 + k[45] === k[10].selectionMark);
    },
    d(Y) {
      Y && pt(T), (G = !1), U();
    },
  };
}
function ri(q) {
  let k,
    T = [],
    y = new Map(),
    A,
    O = Ft(q[40]);
  const F = (G) => G[45];
  for (let G = 0; G < O.length; G += 1) {
    let U = Qe(q, O, G),
      H = F(U);
    y.set(H, (T[G] = ni(H, U)));
  }
  return {
    c() {
      k = Mt("tr");
      for (let G = 0; G < T.length; G += 1) T[G].c();
      (A = Ot()), this.h();
    },
    l(G) {
      k = wt(G, "TR", { class: !0 });
      var U = vt(k);
      for (let H = 0; H < T.length; H += 1) T[H].l(U);
      (A = Lt(U)), U.forEach(pt), this.h();
    },
    h() {
      dt(k, "class", "sdt-cal-td svelte-6hyah7");
    },
    m(G, U) {
      Et(G, k, U);
      for (let H = 0; H < T.length; H += 1) T[H] && T[H].m(k, null);
      xt(k, A);
    },
    p(G, U) {
      U[0] & 623625 &&
        ((O = Ft(G[40])), (T = Ae(T, U, F, 1, G, O, y, k, He, ni, A, Qe)));
    },
    d(G) {
      G && pt(k);
      for (let U = 0; U < T.length; U += 1) T[U].d();
    },
  };
}
function ai(q) {
  let k,
    T,
    y,
    A,
    O,
    F,
    G,
    U,
    H,
    Y = Ft(q[11]),
    S = [];
  for (let c = 0; c < Y.length; c += 1) S[c] = li(Ke(q, Y, c));
  let N = Ft(q[10].grid),
    D = [];
  for (let c = 0; c < N.length; c += 1) D[c] = ci(Ve(q, N, c));
  return {
    c() {
      (k = Mt("table")), (T = Mt("tbody")), (y = Mt("tr"));
      for (let c = 0; c < S.length; c += 1) S[c].c();
      A = Ot();
      for (let c = 0; c < D.length; c += 1) D[c].c();
      this.h();
    },
    l(c) {
      k = wt(c, "TABLE", { class: !0 });
      var p = vt(k);
      T = wt(p, "TBODY", {});
      var f = vt(T);
      y = wt(f, "TR", { class: !0 });
      var u = vt(y);
      for (let n = 0; n < S.length; n += 1) S[n].l(u);
      u.forEach(pt), (A = Lt(f));
      for (let n = 0; n < D.length; n += 1) D[n].l(f);
      f.forEach(pt), p.forEach(pt), this.h();
    },
    h() {
      dt(y, "class", "sdt-cal-td svelte-6hyah7"),
        dt(k, "class", "sdt-table sdt-table-height svelte-6hyah7");
    },
    m(c, p) {
      Et(c, k, p), xt(k, T), xt(T, y);
      for (let f = 0; f < S.length; f += 1) S[f] && S[f].m(y, null);
      xt(T, A);
      for (let f = 0; f < D.length; f += 1) D[f] && D[f].m(T, null);
      (G = !0), U || ((H = Dt(T, "outroend", q[20])), (U = !0));
    },
    p(c, p) {
      if (((q = c), p[0] & 2048)) {
        Y = Ft(q[11]);
        let f;
        for (f = 0; f < Y.length; f += 1) {
          const u = Ke(q, Y, f);
          S[f] ? S[f].p(u, p) : ((S[f] = li(u)), S[f].c(), S[f].m(y, null));
        }
        for (; f < S.length; f += 1) S[f].d(1);
        S.length = Y.length;
      }
      if (p[0] & 623616) {
        N = Ft(q[10].grid);
        let f;
        for (f = 0; f < N.length; f += 1) {
          const u = Ve(q, N, f);
          D[f] ? D[f].p(u, p) : ((D[f] = ci(u)), D[f].c(), D[f].m(T, null));
        }
        for (; f < D.length; f += 1) D[f].d(1);
        D.length = N.length;
      }
    },
    i(c) {
      G ||
        (c &&
          he(() => {
            G &&
              (F && F.end(1),
              (O = Ce(T, q[12], { duration: ye, start: 0.5, opacity: 1 })),
              O.start());
          }),
        (G = !0));
    },
    o(c) {
      O && O.invalidate(),
        c && (F = Re(T, q[12], { duration: ye, start: Math.abs(q[5]) })),
        (G = !1);
    },
    d(c) {
      c && pt(k), Me(S, c), Me(D, c), c && F && F.end(), (U = !1), H();
    },
  };
}
function li(q) {
  let k,
    T = q[46] + "",
    y;
  return {
    c() {
      (k = Mt("th")), (y = jt(T)), this.h();
    },
    l(A) {
      k = wt(A, "TH", { class: !0 });
      var O = vt(k);
      (y = Nt(O, T)), O.forEach(pt), this.h();
    },
    h() {
      dt(k, "class", "sdt-cal-th svelte-6hyah7");
    },
    m(A, O) {
      Et(A, k, O), xt(k, y);
    },
    p(A, O) {
      O[0] & 2048 && T !== (T = A[46] + "") && Ut(y, T);
    },
    d(A) {
      A && pt(k);
    },
  };
}
function hi(q, k) {
  let T,
    y,
    A = k[43].getDate() + "",
    O,
    F,
    G,
    U;
  function H() {
    return k[34](k[43]);
  }
  return {
    key: q,
    first: null,
    c() {
      (T = Mt("td")), (y = Mt("button")), (O = jt(A)), this.h();
    },
    l(Y) {
      T = wt(Y, "TD", { class: !0 });
      var S = vt(T);
      y = wt(S, "BUTTON", { class: !0 });
      var N = vt(y);
      (O = Nt(N, A)), N.forEach(pt), S.forEach(pt), this.h();
    },
    h() {
      dt(y, "class", "std-btn sdt-btn-day svelte-6hyah7"),
        (y.disabled = F = k[16](k[43])),
        At(y, "not-current", !k[15](k[42] * 7 + k[45])),
        dt(T, "class", "sdt-cal-td svelte-6hyah7"),
        At(T, "sdt-today", k[42] * 7 + k[45] === k[10].todayMark),
        At(T, "is-selected", k[42] * 7 + k[45] === k[10].selectionMark),
        (this.first = T);
    },
    m(Y, S) {
      Et(Y, T, S),
        xt(T, y),
        xt(y, O),
        G || ((U = Dt(y, "click", Kt(H))), (G = !0));
    },
    p(Y, S) {
      (k = Y),
        S[0] & 1024 && A !== (A = k[43].getDate() + "") && Ut(O, A),
        S[0] & 1024 && F !== (F = k[16](k[43])) && (y.disabled = F),
        S[0] & 33792 && At(y, "not-current", !k[15](k[42] * 7 + k[45])),
        S[0] & 1024 &&
          At(T, "sdt-today", k[42] * 7 + k[45] === k[10].todayMark),
        S[0] & 1024 &&
          At(T, "is-selected", k[42] * 7 + k[45] === k[10].selectionMark);
    },
    d(Y) {
      Y && pt(T), (G = !1), U();
    },
  };
}
function ci(q) {
  let k,
    T = [],
    y = new Map(),
    A,
    O = Ft(q[40]);
  const F = (G) => G[45];
  for (let G = 0; G < O.length; G += 1) {
    let U = qe(q, O, G),
      H = F(U);
    y.set(H, (T[G] = hi(H, U)));
  }
  return {
    c() {
      k = Mt("tr");
      for (let G = 0; G < T.length; G += 1) T[G].c();
      A = Ot();
    },
    l(G) {
      k = wt(G, "TR", {});
      var U = vt(k);
      for (let H = 0; H < T.length; H += 1) T[H].l(U);
      (A = Lt(U)), U.forEach(pt);
    },
    m(G, U) {
      Et(G, k, U);
      for (let H = 0; H < T.length; H += 1) T[H] && T[H].m(k, null);
      xt(k, A);
    },
    p(G, U) {
      U[0] & 623616 &&
        ((O = Ft(G[40])), (T = Ae(T, U, F, 1, G, O, y, k, He, hi, A, qe)));
    },
    d(G) {
      G && pt(k);
      for (let U = 0; U < T.length; U += 1) T[U].d();
    },
  };
}
function cs(q) {
  let k,
    T,
    y,
    A,
    O,
    F,
    G,
    U =
      '<svg class="sdt-svg svelte-6hyah7" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="24" height="24"><path d="M4.427 9.573l3.396-3.396a.25.25 0 01.354 0l3.396 3.396a.25.25 0 01-.177.427H4.604a.25.25 0 01-.177-.427z"></path></svg>',
    H,
    Y,
    S =
      '<svg class="sdt-svg svelte-6hyah7" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" width="24" height="24"><path d="M4.427 7.427l3.396 3.396a.25.25 0 00.354 0l3.396-3.396A.25.25 0 0011.396 7H4.604a.25.25 0 00-.177.427z"></path></svg>',
    N,
    D,
    c,
    p,
    f,
    u,
    n = q[1] && q[2] && ti(q),
    d = q[4] === qt && ei(q),
    g = q[4] === ce && oi(q),
    M = q[4] === Xt && ai(q);
  return {
    c() {
      (k = Mt("div")),
        (T = Mt("button")),
        (y = jt(q[9])),
        (A = Ot()),
        (O = Mt("div")),
        n && n.c(),
        (F = Ot()),
        (G = Mt("button")),
        (G.innerHTML = U),
        (H = Ot()),
        (Y = Mt("button")),
        (Y.innerHTML = S),
        (N = Ot()),
        (D = Mt("div")),
        d && d.c(),
        (c = Ot()),
        g && g.c(),
        (p = Ot()),
        M && M.c(),
        this.h();
    },
    l(C) {
      k = wt(C, "DIV", { class: !0 });
      var P = vt(k);
      T = wt(P, "BUTTON", { class: !0 });
      var j = vt(T);
      (y = Nt(j, q[9])),
        j.forEach(pt),
        (A = Lt(P)),
        (O = wt(P, "DIV", { class: !0 }));
      var m = vt(O);
      n && n.l(m),
        (F = Lt(m)),
        (G = wt(m, "BUTTON", { class: !0, ["data-svelte-h"]: !0 })),
        pe(G) !== "svelte-lnym66" && (G.innerHTML = U),
        (H = Lt(m)),
        (Y = wt(m, "BUTTON", { class: !0, ["data-svelte-h"]: !0 })),
        pe(Y) !== "svelte-1l0b3y7" && (Y.innerHTML = S),
        m.forEach(pt),
        P.forEach(pt),
        (N = Lt(C)),
        (D = wt(C, "DIV", { class: !0 }));
      var h = vt(D);
      d && d.l(h),
        (c = Lt(h)),
        g && g.l(h),
        (p = Lt(h)),
        M && M.l(h),
        h.forEach(pt),
        this.h();
    },
    h() {
      dt(T, "class", "std-btn std-btn-header sdt-toggle-btn svelte-6hyah7"),
        dt(G, "class", "std-btn std-btn-header icon-btn svelte-6hyah7"),
        dt(Y, "class", "std-btn std-btn-header icon-btn svelte-6hyah7"),
        dt(O, "class", "sdt-nav-btns svelte-6hyah7"),
        dt(k, "class", "sdt-thead-nav svelte-6hyah7"),
        dt(D, "class", "sdt-calendar svelte-6hyah7"),
        At(D, "is-grid", q[6]);
    },
    m(C, P) {
      Et(C, k, P),
        xt(k, T),
        xt(T, y),
        xt(k, A),
        xt(k, O),
        n && n.m(O, null),
        xt(O, F),
        xt(O, G),
        xt(O, H),
        xt(O, Y),
        Et(C, N, P),
        Et(C, D, P),
        d && d.m(D, null),
        xt(D, c),
        g && g.m(D, null),
        xt(D, p),
        M && M.m(D, null),
        f ||
          ((u = [
            Dt(T, "click", Kt(q[18])),
            Dt(G, "click", Kt(q[28])),
            Dt(Y, "click", Kt(q[29])),
          ]),
          (f = !0));
    },
    p(C, P) {
      P[0] & 512 && Ut(y, C[9]),
        C[1] && C[2]
          ? n
            ? n.p(C, P)
            : ((n = ti(C)), n.c(), n.m(O, F))
          : n && (n.d(1), (n = null)),
        C[4] === qt
          ? d
            ? (d.p(C, P), P[0] & 16 && Pt(d, 1))
            : ((d = ei(C)), d.c(), Pt(d, 1), d.m(D, c))
          : d &&
            (Qt(),
            Bt(d, 1, 1, () => {
              d = null;
            }),
            Jt()),
        C[4] === ce
          ? g
            ? (g.p(C, P), P[0] & 16 && Pt(g, 1))
            : ((g = oi(C)), g.c(), Pt(g, 1), g.m(D, p))
          : g &&
            (Qt(),
            Bt(g, 1, 1, () => {
              g = null;
            }),
            Jt()),
        C[4] === Xt
          ? M
            ? (M.p(C, P), P[0] & 16 && Pt(M, 1))
            : ((M = ai(C)), M.c(), Pt(M, 1), M.m(D, null))
          : M &&
            (Qt(),
            Bt(M, 1, 1, () => {
              M = null;
            }),
            Jt()),
        P[0] & 64 && At(D, "is-grid", C[6]);
    },
    i(C) {
      Pt(d), Pt(g), Pt(M);
    },
    o(C) {
      Bt(d), Bt(g), Bt(M);
    },
    d(C) {
      C && (pt(k), pt(N), pt(D)),
        n && n.d(),
        d && d.d(),
        g && g.d(),
        M && M.d(),
        (f = !1),
        xe(u);
    },
  };
}
let ye = 400;
const Vt = 222,
  be = 148;
function ds(q, k, T) {
  let y,
    A,
    O,
    F,
    G,
    U,
    H,
    { date: Y = null } = k,
    { startDate: S = null } = k,
    { endDate: N = null } = k,
    { weekStart: D = 1 } = k,
    { initialView: c = Xt } = k,
    { i18n: p } = k,
    { enableTimeToggle: f = !1 } = k;
  function u(R, W) {
    if (!d) {
      e(new Date());
      return;
    }
    let X, Z;
    switch (R) {
      case "PageDown":
        W = !0;
      case "ArrowDown":
        if (W) return n(g.getFullYear(), g.getMonth() + 1, 1);
        if (((Z = G.selectionMark + 7), Z >= G.nextFrom)) {
          const E = new Date(g.getFullYear(), g.getUTCMonth() + 1, 28);
          let _ = we(E, d, C, p, D);
          o(1),
            (X =
              _.selectionMark !== null
                ? {
                    y: Math.floor((_.selectionMark + 7) / 7),
                    x: (_.selectionMark + 7) % 7,
                  }
                : { y: (Z + 7) % 7 < _.prevTo ? 1 : 0, x: (Z + 7) % 7 }),
            e(_.grid[X.y][X.x]);
          return;
        }
        (X = Se(G.selectionMark + 7)),
          G.grid[X.y][X.x].getMonth() !== g.getMonth() && o(1),
          e(G.grid[X.y][X.x]);
        break;
      case "PageUp":
        W = !0;
      case "ArrowUp":
        if (W) return n(g.getFullYear(), g.getMonth() - 1, -1);
        if (((Z = G.selectionMark - 7), Z <= G.prevTo)) {
          const E = new Date(
              g.getFullYear() + (g.getMonth() > 0 ? 0 : -1),
              g.getMonth() > 0 ? g.getMonth() - 1 : 11,
              1
            ),
            _ = we(E, d, C, p, D);
          o(-1),
            (X =
              _.selectionMark !== null
                ? {
                    x: Math.floor((_.selectionMark - 7) / 7),
                    y: (_.selectionMark - 7) % 7,
                  }
                : { x: 5, y: Z }),
            e(_.grid[X.x][X.y]);
          return;
        }
        (X = Se(G.selectionMark - 7)),
          G.grid[X.y][X.x].getMonth() !== g.getMonth() && o(-1),
          e(G.grid[X.y][X.x]);
        break;
      case "ArrowLeft":
        if (W) return n(g.getFullYear() - 1, g.getMonth(), 1);
        (X = Se(G.selectionMark - 1)),
          G.grid[X.y][X.x].getMonth() !== g.getMonth() && o(-1),
          e(G.grid[X.y][X.x]);
        break;
      case "ArrowRight":
        if (W) return n(g.getFullYear() + 1, g.getMonth(), 1);
        (X = Se(G.selectionMark + 1)),
          G.grid[X.y][X.x].getMonth() !== g.getMonth() && o(1),
          e(G.grid[X.y][X.x]);
        break;
    }
  }
  function n(R, W, X) {
    let Z,
      E = g.getDate();
    do (Z = new Date(R, W, E)), E--;
    while (Z.getMonth() === g.getMonth());
    const _ = we(Z, Z, C, p, D),
      z = _.grid[Math.floor(_.selectionMark / 7)][_.selectionMark % 7];
    (N && Xe(z, N)) || (S && We(z, S)) || (o(X), e(z));
  }
  let d = Y,
    g = Y ? new Date(Y.valueOf()) : new Date();
  const M = Ne();
  let C = c,
    P = -2,
    j = !1,
    m = Vt,
    h = null;
  function v(R) {
    return G.prevTo <= R && R < G.nextFrom;
  }
  function l(R) {
    switch (C) {
      case Xt:
        if ((y && y > R) || (N && N <= R)) return !0;
        break;
      case ce:
        if (
          (y &&
            y.getFullYear() === R.getFullYear() &&
            y.getMonth() > R.getMonth()) ||
          (N &&
            N.getFullYear() === R.getFullYear() &&
            N.getMonth() < R.getMonth())
        )
          return !0;
        break;
      case qt:
        if (
          (y && y.getFullYear() > R.getFullYear()) ||
          (N && N.getFullYear() < R.getFullYear())
        )
          return !0;
        break;
    }
    return !1;
  }
  function o(R) {
    const W = C === qt ? 120 : C === ce ? 12 : 1;
    g.setMonth(g.getMonth() + R * W),
      T(3, g),
      T(22, Y),
      T(2, d),
      T(8, (h = null)),
      T(7, (m = C === qt ? (g.getFullYear() % 20 >= 10 ? Vt : be) : Vt));
  }
  function i(R) {
    if (C === Xt) return o(R);
    if (
      (T(
        8,
        (h = () => {
          o(R);
        })
      ),
      C === qt)
    ) {
      T(
        7,
        (m =
          m === be ? (R === -1 ? m - Vt : Vt + be) : R === -1 ? m - Vt : m + be)
      );
      return;
    }
    T(7, (m = R === -1 ? m - Vt : m + Vt));
  }
  function t() {
    if ((T(5, (P = -1)), T(6, (j = !0)), C && T(4, C--, C), C === qt)) {
      const R = (Math.floor(g.getFullYear() / 10) * 10) % 20 === 0;
      T(7, (m = R ? be : Vt));
    }
  }
  function e(R) {
    switch ((T(5, (P = 1)), T(6, (j = !0)), C)) {
      case 0:
        g.setFullYear(R), T(3, g), T(22, Y), T(2, d);
        break;
      case 1:
        g.setMonth(p.monthsShort.indexOf(R)), T(3, g), T(22, Y), T(2, d);
        break;
      case 2:
        if ((S && !Xe(R, S)) || (N && !We(R, N))) return;
        const W = new Date(R.getFullYear(), R.getMonth(), R.getDate());
        d && (W.setMinutes(d.getMinutes()), W.setHours(d.getHours())),
          T(2, (d = W)),
          M("date", d);
        break;
    }
    C < Xt && T(4, C++, C), T(7, (m = Vt));
  }
  function s() {
    T(6, (j = !1));
  }
  function a() {
    M("switch", "time");
  }
  function b(R, W) {
    switch (R) {
      case qt:
        const X = [Math.floor(G.prevTo / 4), G.prevTo % 4],
          Z = [Math.floor(G.nextFrom / 4), G.nextFrom % 4];
        return `${G.years[X.shift()][X.shift()]} - ${
          G.years[Z.shift()][Z.shift()] - 1
        }`;
      case ce:
        return W.getFullYear();
      case Xt:
        return p.months[W.getMonth()] + " " + W.getFullYear();
    }
  }
  const r = () => i(-1),
    w = () => i(1),
    L = (R) => {
      e(R);
    },
    I = () => h && h(),
    V = (R) => {
      e(R);
    },
    B = () => h && h(),
    x = (R) => {
      e(R);
    };
  return (
    (q.$$set = (R) => {
      "date" in R && T(22, (Y = R.date)),
        "startDate" in R && T(23, (S = R.startDate)),
        "endDate" in R && T(24, (N = R.endDate)),
        "weekStart" in R && T(25, (D = R.weekStart)),
        "initialView" in R && T(26, (c = R.initialView)),
        "i18n" in R && T(0, (p = R.i18n)),
        "enableTimeToggle" in R && T(1, (f = R.enableTimeToggle));
    }),
    (q.$$.update = () => {
      q.$$.dirty[0] & 8388608 &&
        (y = S
          ? new Date(S.getFullYear(), S.getMonth(), S.getDate(), 0, 0, 0, 0)
          : null),
        q.$$.dirty[0] & 4194308 &&
          Y !== d &&
          (T(2, (d = Y)),
          Y && T(3, (g = new Date(Y.valueOf()))),
          T(5, (P = 1)),
          T(6, (j = !0)),
          T(4, (C = Xt))),
        q.$$.dirty[0] & 32 && T(14, (A = P < 1 ? 1.5 : 0.5)),
        q.$$.dirty[0] & 32 && T(13, (O = P < 1 ? 1 : 1.5)),
        q.$$.dirty[0] & 32 &&
          T(12, (F = P === -2 ? le : P !== null ? hs : () => {})),
        q.$$.dirty[0] & 33554461 && T(10, (G = we(g, d, C, p, D))),
        q.$$.dirty[0] & 33554433 &&
          T(
            11,
            (U =
              D > -1
                ? p.daysMin.concat(p.daysMin).slice(D, 7 + D)
                : p.daysMin.slice(D, 7 + D))
          ),
        q.$$.dirty[0] & 25 && T(9, (H = p && b(C, g)));
    }),
    [
      p,
      f,
      d,
      g,
      C,
      P,
      j,
      m,
      h,
      H,
      G,
      U,
      F,
      O,
      A,
      v,
      l,
      i,
      t,
      e,
      s,
      a,
      Y,
      S,
      N,
      D,
      c,
      u,
      r,
      w,
      L,
      I,
      V,
      B,
      x,
    ]
  );
}
class us extends te {
  constructor(k) {
    super(),
      ee(
        this,
        k,
        ds,
        cs,
        $t,
        {
          date: 22,
          startDate: 23,
          endDate: 24,
          weekStart: 25,
          initialView: 26,
          i18n: 0,
          enableTimeToggle: 1,
          handleGridNav: 27,
        },
        null,
        [-1, -1]
      );
  }
  get handleGridNav() {
    return this.$$.ctx[27];
  }
}
function di(q, k, T) {
  const y = q.slice();
  return (y[36] = k[T]), (y[38] = T), y;
}
function ui(q, k, T) {
  const y = q.slice();
  return (y[36] = k[T]), (y[38] = T), y;
}
function pi(q) {
  let k, T, y, A, O, F;
  return {
    c() {
      (k = Mt("button")), (T = zt("svg")), (y = zt("path")), this.h();
    },
    l(G) {
      k = wt(G, "BUTTON", { class: !0, title: !0 });
      var U = vt(k);
      T = Gt(U, "svg", {
        class: !0,
        xmlns: !0,
        viewBox: !0,
        width: !0,
        height: !0,
      });
      var H = vt(T);
      (y = Gt(H, "path", { "fill-rule": !0, d: !0 })),
        vt(y).forEach(pt),
        H.forEach(pt),
        U.forEach(pt),
        this.h();
    },
    h() {
      dt(y, "fill-rule", "evenodd"),
        dt(
          y,
          "d",
          "M6.75 0a.75.75 0 01.75.75V3h9V.75a.75.75 0 011.5 0V3h2.75c.966 0 1.75.784 1.75 1.75v16a1.75 1.75 0 01-1.75 1.75H3.25a1.75 1.75 0 01-1.75-1.75v-16C1.5 3.784 2.284 3 3.25 3H6V.75A.75.75 0 016.75 0zm-3.5 4.5a.25.25 0 00-.25.25V8h18V4.75a.25.25 0 00-.25-.25H3.25zM21 9.5H3v11.25c0 .138.112.25.25.25h17.5a.25.25 0 00.25-.25V9.5z"
        ),
        dt(T, "class", "sdt-svg svelte-163fzlc"),
        dt(T, "xmlns", "http://www.w3.org/2000/svg"),
        dt(T, "viewBox", "0 0 24 24"),
        dt(T, "width", "20"),
        dt(T, "height", "20"),
        dt(k, "class", "sdt-time-btn sdt-back-btn svelte-163fzlc"),
        dt(k, "title", (A = q[4].backToDate));
    },
    m(G, U) {
      Et(G, k, U),
        xt(k, T),
        xt(T, y),
        O || ((F = Dt(k, "click", q[20])), (O = !0));
    },
    p(G, U) {
      U[0] & 16 && A !== (A = G[4].backToDate) && dt(k, "title", A);
    },
    d(G) {
      G && pt(k), (O = !1), F();
    },
  };
}
function gi(q) {
  let k,
    T,
    y = q[11] ? "PM" : "AM",
    A,
    O,
    F,
    G;
  return {
    c() {
      (k = Mt("div")), (T = Mt("button")), (A = jt(y)), this.h();
    },
    l(U) {
      k = wt(U, "DIV", { class: !0 });
      var H = vt(k);
      T = wt(H, "BUTTON", { type: !0, class: !0, "data-value": !0 });
      var Y = vt(T);
      (A = Nt(Y, y)), Y.forEach(pt), H.forEach(pt), this.h();
    },
    h() {
      dt(T, "type", "button"),
        dt(T, "class", "sdt-time-btn sdt-time-figure is-active svelte-163fzlc"),
        dt(T, "data-value", (O = q[11] ? q[6] % 12 : q[6] + 12)),
        dt(k, "class", "sdt-meridian svelte-163fzlc");
    },
    m(U, H) {
      Et(U, k, H),
        xt(k, T),
        xt(T, A),
        F || ((G = Dt(T, "click", q[18])), (F = !0));
    },
    p(U, H) {
      H[0] & 2048 && y !== (y = U[11] ? "PM" : "AM") && Ut(A, y),
        H[0] & 2112 &&
          O !== (O = U[11] ? U[6] % 12 : U[6] + 12) &&
          dt(T, "data-value", O);
    },
    d(U) {
      U && pt(k), (F = !1), G();
    },
  };
}
function fi(q, k) {
  let T,
    y = k[36].val + "",
    A,
    O,
    F,
    G,
    U,
    H;
  return {
    key: q,
    first: null,
    c() {
      (T = Mt("button")), (A = jt(y)), this.h();
    },
    l(Y) {
      T = wt(Y, "BUTTON", { type: !0, style: !0, class: !0, "data-value": !0 });
      var S = vt(T);
      (A = Nt(S, y)), S.forEach(pt), this.h();
    },
    h() {
      dt(T, "type", "button"),
        dt(T, "style", (O = `left:${k[36].x}px; top:${k[36].y}px`)),
        dt(T, "class", "sdt-tick svelte-163fzlc"),
        dt(T, "data-value", (F = k[36].val)),
        (T.disabled = G = (k[0] || k[1]) && k[16](k[36].val, !1)),
        At(T, "outer-tick", k[5]),
        At(T, "is-selected", k[15](k[6], k[36].val, k[38])),
        (this.first = T);
    },
    m(Y, S) {
      Et(Y, T, S), xt(T, A), (H = !0);
    },
    p(Y, S) {
      (k = Y),
        (!H || S[0] & 8192) && y !== (y = k[36].val + "") && Ut(A, y),
        (!H ||
          (S[0] & 8192 && O !== (O = `left:${k[36].x}px; top:${k[36].y}px`))) &&
          dt(T, "style", O),
        (!H || (S[0] & 8192 && F !== (F = k[36].val))) &&
          dt(T, "data-value", F),
        (!H ||
          (S[0] & 8195 &&
            G !== (G = (k[0] || k[1]) && k[16](k[36].val, !1)))) &&
          (T.disabled = G),
        (!H || S[0] & 32) && At(T, "outer-tick", k[5]),
        (!H || S[0] & 41024) &&
          At(T, "is-selected", k[15](k[6], k[36].val, k[38]));
    },
    i(Y) {
      H ||
        (Y &&
          he(() => {
            H && (U || (U = me(T, le, { duration: 200 }, !0)), U.run(1));
          }),
        (H = !0));
    },
    o(Y) {
      Y && (U || (U = me(T, le, { duration: 200 }, !1)), U.run(0)), (H = !1);
    },
    d(Y) {
      Y && pt(T), Y && U && U.end();
    },
  };
}
function mi(q) {
  let k,
    T = q[36].val + "",
    y,
    A,
    O,
    F,
    G,
    U;
  return {
    c() {
      (k = Mt("button")), (y = jt(T)), this.h();
    },
    l(H) {
      k = wt(H, "BUTTON", { type: !0, style: !0, class: !0, "data-value": !0 });
      var Y = vt(k);
      (y = Nt(Y, T)), Y.forEach(pt), this.h();
    },
    h() {
      dt(k, "type", "button"),
        dt(k, "style", (A = `left:${q[36].x}px; top:${q[36].y}px;`)),
        dt(k, "class", "sdt-tick svelte-163fzlc"),
        dt(k, "data-value", (O = q[36].val)),
        (k.disabled = F = (q[0] || q[1]) && q[16](q[36].val, !1)),
        At(k, "outer-tick", q[2] && !q[5]),
        At(k, "is-selected", q[15](q[5] ? q[7] : q[6], q[36].val, q[38]));
    },
    m(H, Y) {
      Et(H, k, Y), xt(k, y), (U = !0);
    },
    p(H, Y) {
      (!U || Y[0] & 4096) && T !== (T = H[36].val + "") && Ut(y, T),
        (!U ||
          (Y[0] & 4096 &&
            A !== (A = `left:${H[36].x}px; top:${H[36].y}px;`))) &&
          dt(k, "style", A),
        (!U || (Y[0] & 4096 && O !== (O = H[36].val))) &&
          dt(k, "data-value", O),
        (!U ||
          (Y[0] & 4099 &&
            F !== (F = (H[0] || H[1]) && H[16](H[36].val, !1)))) &&
          (k.disabled = F),
        (!U || Y[0] & 36) && At(k, "outer-tick", H[2] && !H[5]),
        (!U || Y[0] & 37088) &&
          At(k, "is-selected", H[15](H[5] ? H[7] : H[6], H[36].val, H[38]));
    },
    i(H) {
      U ||
        (H &&
          he(() => {
            U && (G || (G = me(k, le, { duration: 200 }, !0)), G.run(1));
          }),
        (U = !0));
    },
    o(H) {
      H && (G || (G = me(k, le, { duration: 200 }, !1)), G.run(0)), (U = !1);
    },
    d(H) {
      H && pt(k), H && G && G.end();
    },
  };
}
function ps(q) {
  let k,
    T,
    y,
    A,
    O = q[14](q[6], q[2]) + "",
    F,
    G,
    U,
    H = ":",
    Y,
    S,
    N = q[14](q[7], !1) + "",
    D,
    c,
    p,
    f,
    u,
    n,
    d,
    g,
    M,
    C = [],
    P = new Map(),
    j,
    m,
    h,
    v,
    l,
    o = q[3] && pi(q),
    i = q[2] && gi(q),
    t = Ft(q[13]);
  const e = (r) => r[36].val;
  for (let r = 0; r < t.length; r += 1) {
    let w = ui(q, t, r),
      L = e(w);
    P.set(L, (C[r] = fi(L, w)));
  }
  let s = Ft(q[12]),
    a = [];
  for (let r = 0; r < s.length; r += 1) a[r] = mi(di(q, s, r));
  const b = (r) =>
    Bt(a[r], 1, 1, () => {
      a[r] = null;
    });
  return {
    c() {
      (k = Mt("div")),
        (T = Mt("div")),
        o && o.c(),
        (y = Ot()),
        (A = Mt("button")),
        (F = jt(O)),
        (G = Ot()),
        (U = Mt("span")),
        (U.textContent = H),
        (Y = Ot()),
        (S = Mt("button")),
        (D = jt(N)),
        (c = Ot()),
        i && i.c(),
        (p = Ot()),
        (f = Mt("div")),
        (u = Mt("div")),
        (n = Ot()),
        (d = Mt("div")),
        (g = Mt("div")),
        (M = Ot());
      for (let r = 0; r < C.length; r += 1) C[r].c();
      j = Ot();
      for (let r = 0; r < a.length; r += 1) a[r].c();
      this.h();
    },
    l(r) {
      k = wt(r, "DIV", { class: !0 });
      var w = vt(k);
      T = wt(w, "DIV", { class: !0 });
      var L = vt(T);
      o && o.l(L), (y = Lt(L)), (A = wt(L, "BUTTON", { class: !0 }));
      var I = vt(A);
      (F = Nt(I, O)),
        I.forEach(pt),
        (G = Lt(L)),
        (U = wt(L, "SPAN", { ["data-svelte-h"]: !0 })),
        pe(U) !== "svelte-5vnx5k" && (U.textContent = H),
        (Y = Lt(L)),
        (S = wt(L, "BUTTON", { class: !0 }));
      var V = vt(S);
      (D = Nt(V, N)),
        V.forEach(pt),
        (c = Lt(L)),
        i && i.l(L),
        L.forEach(pt),
        (p = Lt(w)),
        (f = wt(w, "DIV", { class: !0 }));
      var B = vt(f);
      (u = wt(B, "DIV", { class: !0 })),
        vt(u).forEach(pt),
        (n = Lt(B)),
        (d = wt(B, "DIV", { class: !0, style: !0 }));
      var x = vt(d);
      (g = wt(x, "DIV", { class: !0 })),
        vt(g).forEach(pt),
        x.forEach(pt),
        (M = Lt(B));
      for (let R = 0; R < C.length; R += 1) C[R].l(B);
      j = Lt(B);
      for (let R = 0; R < a.length; R += 1) a[R].l(B);
      B.forEach(pt), w.forEach(pt), this.h();
    },
    h() {
      dt(A, "class", "sdt-time-btn sdt-time-figure svelte-163fzlc"),
        At(A, "is-active", !q[5]),
        dt(S, "class", "sdt-time-btn sdt-time-figure svelte-163fzlc"),
        At(S, "is-active", q[5]),
        dt(T, "class", "sdt-time-head svelte-163fzlc"),
        dt(u, "class", "sdt-middle-dot svelte-163fzlc"),
        dt(g, "class", "sdt-hand-circle svelte-163fzlc"),
        dt(d, "class", "sdt-hand-pointer svelte-163fzlc"),
        dt(d, "style", q[10]),
        dt(f, "class", "sdt-clock svelte-163fzlc"),
        dt(k, "class", "sdt-timer svelte-163fzlc");
    },
    m(r, w) {
      Et(r, k, w),
        xt(k, T),
        o && o.m(T, null),
        xt(T, y),
        xt(T, A),
        xt(A, F),
        xt(T, G),
        xt(T, U),
        xt(T, Y),
        xt(T, S),
        xt(S, D),
        xt(T, c),
        i && i.m(T, null),
        xt(k, p),
        xt(k, f),
        xt(f, u),
        xt(f, n),
        xt(f, d),
        xt(d, g),
        xt(f, M);
      for (let L = 0; L < C.length; L += 1) C[L] && C[L].m(f, null);
      xt(f, j);
      for (let L = 0; L < a.length; L += 1) a[L] && a[L].m(f, null);
      q[29](f),
        (h = !0),
        v ||
          ((l = [
            Dt(A, "click", q[26]),
            Dt(S, "click", q[27]),
            Dt(f, "click", Kt(q[17])),
            Dt(f, "mousedown", q[19]),
            Dt(f, "mousemove", q[28]),
            Dt(f, "mouseup", q[19]),
          ]),
          (v = !0));
    },
    p(r, w) {
      if (
        (r[3]
          ? o
            ? o.p(r, w)
            : ((o = pi(r)), o.c(), o.m(T, y))
          : o && (o.d(1), (o = null)),
        (!h || w[0] & 68) && O !== (O = r[14](r[6], r[2]) + "") && Ut(F, O),
        (!h || w[0] & 32) && At(A, "is-active", !r[5]),
        (!h || w[0] & 128) && N !== (N = r[14](r[7], !1) + "") && Ut(D, N),
        (!h || w[0] & 32) && At(S, "is-active", r[5]),
        r[2]
          ? i
            ? i.p(r, w)
            : ((i = gi(r)), i.c(), i.m(T, null))
          : i && (i.d(1), (i = null)),
        (!h || w[0] & 1024) && dt(d, "style", r[10]),
        w[0] & 106595 &&
          ((t = Ft(r[13])),
          Qt(),
          (C = Ae(C, w, e, 1, r, t, P, f, Ni, fi, j, ui)),
          Jt()),
        w[0] & 102631)
      ) {
        s = Ft(r[12]);
        let L;
        for (L = 0; L < s.length; L += 1) {
          const I = di(r, s, L);
          a[L]
            ? (a[L].p(I, w), Pt(a[L], 1))
            : ((a[L] = mi(I)), a[L].c(), Pt(a[L], 1), a[L].m(f, null));
        }
        for (Qt(), L = s.length; L < a.length; L += 1) b(L);
        Jt();
      }
    },
    i(r) {
      if (!h) {
        for (let w = 0; w < t.length; w += 1) Pt(C[w]);
        for (let w = 0; w < s.length; w += 1) Pt(a[w]);
        r &&
          (m ||
            he(() => {
              (m = Ce(k, le, { duration: 200 })), m.start();
            })),
          (h = !0);
      }
    },
    o(r) {
      for (let w = 0; w < C.length; w += 1) Bt(C[w]);
      a = a.filter(Boolean);
      for (let w = 0; w < a.length; w += 1) Bt(a[w]);
      h = !1;
    },
    d(r) {
      r && pt(k), o && o.d(), i && i.d();
      for (let w = 0; w < C.length; w += 1) C[w].d();
      Me(a, r), q[29](null), (v = !1), xe(l);
    },
  };
}
function gs(q, k, T) {
  let y,
    A,
    O,
    F,
    G,
    U,
    H,
    { date: Y = null } = k,
    { startDate: S = null } = k,
    { endDate: N = null } = k,
    { minuteIncrement: D = 1 } = k,
    { showMeridian: c = !1 } = k,
    { hasDateComponent: p = !1 } = k,
    { i18n: f } = k;
  function u(I) {
    if (I === null) return g;
    T(5, (g = I));
  }
  function n(I) {
    g
      ? ((I = I * 5 + O),
        I % 5 !== 0 && (I = I < O ? I + (5 - (I % 5)) : I - (I % 5)))
      : (I = y + I),
      (C = !1),
      t({ target: { tagName: "BUTTON", dataset: { value: I } } }),
      (C = !0);
  }
  let d,
    g = !1,
    M = !1,
    C = !0,
    P = Y || new Date();
  Y || ((Y = P), Y.setHours(0, 0, 0, 0));
  let j = !0;
  const m = Ne();
  let h = "";
  function v(I, V, B, x, R) {
    const W = I / 2;
    V = V || W;
    const X = [0, 1 - 0.5, 1 - 0.134, 1, 1 - 0.134, 1 - 0.5],
      Z = X.concat(X),
      E = X.slice(3).concat(X).concat(X.slice(0, 3)),
      _ = [];
    for (let z = 0; z < 12; z++)
      _.push({
        x: Math.abs(Z[z] * W + (z <= 6 ? 1 : -1) * V),
        y: Math.abs(E[z] * W + (z >= 9 || z < 3 ? -1 : 1) * V),
        val: x ? z * 5 || B : z ? z + R : B,
      });
    return _;
  }
  function l(I, V) {
    return V
      ? A && I === 12
        ? 12
        : I < 10 || I % 12 < 10
        ? `0${I % 12}`
        : I % 12
      : I < 10
      ? `0${I}`
      : I;
  }
  function o(I, V, B) {
    return g
      ? V === I || (B === 0 && B === I)
      : c
      ? (A && V == 12 && I === 12) || (!A && V == 12 && I === 0)
        ? !0
        : V === (I ? I % 12 : 12)
      : V > 12
      ? (B ? F * B + 12 : 0) === I
      : V === "00" || V === "12"
      ? (I === 12 && parseInt(V) == 12) || (V === "00" && I === 0)
      : V === I;
  }
  function i(I, V = !1) {
    return (
      typeof I == "string" && (I = parseInt(I)),
      S && N && G
        ? g || V
          ? (S.getHours() === P.getHours() && S.getMinutes() > I) ||
            (N.getHours() === P.getHours() && N.getMinutes() < I)
          : S.getHours() > I || N.getHours() < I
        : S &&
          S.getDate() === P.getDate() &&
          S.getMonth() === P.getMonth() &&
          S.getFullYear() === P.getFullYear()
        ? g || V
          ? S.getHours() === P.getHours() && S.getMinutes() > I
          : S.getHours() > I
        : N &&
          N.getDate() === P.getDate() &&
          N.getMonth() === P.getMonth() &&
          N.getFullYear() === P.getFullYear()
        ? g || V
          ? N.getHours() === P.getHours() && N.getMinutes() < I
          : N.getHours() < I
        : !1
    );
  }
  function t(I) {
    if (
      !j ||
      !I.target ||
      (I.type === "mousemove" && !M) ||
      (!g && I.target.tagName !== "BUTTON")
    )
      return;
    let V = 0,
      B = 0;
    if (I.target.tagName === "BUTTON" && (!g || D === 1)) {
      let x = parseInt(I.target.dataset.value);
      const R = g ? "setMinutes" : "setHours";
      !g && A && (x += 12), P[R](x);
    } else if (g) {
      const x = d.getBoundingClientRect(),
        R = I.clientX - x.left,
        W = I.clientY - x.top,
        X = 130,
        Z = 130;
      let E = null;
      switch ((R > X ? (E = W > Z ? 2 : 1) : (E = W > Z ? 3 : 4), E)) {
        case 1:
          (V = R - X), (B = Z - W);
          break;
        case 2:
          (V = R - X), (B = W - Z);
          break;
        case 3:
          (V = X - R), (B = W - Z);
          break;
        case 4:
          (V = X - R), (B = Z - W);
          break;
      }
      const _ = Math.sqrt(V * V + B * B),
        z = 90 - Math.asin(V / _) * (180 / Math.PI);
      let J = 0;
      switch (E) {
        case 1:
          J = 90 - z;
          break;
        case 2:
          J = z + 90;
          break;
        case 3:
          J = 270 - z;
          break;
        case 4:
          J = z + 270;
          break;
      }
      (J = Math.round(J / 6 / D) * D), J === 60 && (J = 0), P.setMinutes(J);
    }
    T(25, P),
      T(21, Y),
      (j = !1),
      m("time", P),
      !M &&
        g &&
        setTimeout(() => {
          m("close");
        }, 300),
      C && !g && T(5, (g = !0)),
      (C = !0),
      setTimeout(() => {
        (C = !1), (j = !0);
      }, 200);
  }
  function e(I) {
    const V = parseInt(I.target.dataset.value);
    P.setHours(V), T(25, P), T(21, Y), m("time", P);
  }
  function s(I) {
    T(9, (M = I.type === "mousedown"));
  }
  function a() {
    m("switch", "date");
  }
  const b = () => T(5, (g = !1)),
    r = () => T(5, (g = !0)),
    w = (I) => {
      M && t(I);
    };
  function L(I) {
    ke[I ? "unshift" : "push"](() => {
      (d = I), T(8, d);
    });
  }
  return (
    (q.$$set = (I) => {
      "date" in I && T(21, (Y = I.date)),
        "startDate" in I && T(0, (S = I.startDate)),
        "endDate" in I && T(1, (N = I.endDate)),
        "minuteIncrement" in I && T(22, (D = I.minuteIncrement)),
        "showMeridian" in I && T(2, (c = I.showMeridian)),
        "hasDateComponent" in I && T(3, (p = I.hasDateComponent)),
        "i18n" in I && T(4, (f = I.i18n));
    }),
    (q.$$.update = () => {
      if (
        (q.$$.dirty[0] & 35651584 && Y !== P && Y && T(25, (P = Y)),
        q.$$.dirty[0] & 33554435)
      ) {
        let I = !1;
        S &&
          S.toDateString() === P.toDateString() &&
          (i(P.getHours()) && (P.setHours(S.getHours()), (I = !0)),
          i(P.getMinutes(), !0) && (P.setMinutes(S.getMinutes()), (I = !0))),
          N &&
            N.toDateString() === P.toDateString() &&
            (i(P.getHours()) && (P.setHours(N.getHours()), (I = !0)),
            i(P.getMinutes(), !0) && (P.setMinutes(N.getMinutes()), (I = !0))),
          I && wi().then(() => m("time", P));
      }
      if (
        (q.$$.dirty[0] & 33554432 && T(6, (y = P ? P.getHours() : 0)),
        q.$$.dirty[0] & 68 && T(11, (A = c ? y >= 12 : !1)),
        q.$$.dirty[0] & 33554432 && T(7, (O = P ? P.getMinutes() : 0)),
        q.$$.dirty[0] & 228)
      ) {
        let I = g ? O * 6 : (y % 12) * 30;
        T(
          10,
          (h =
            g || c || y < 12
              ? `transform: rotateZ(${I}deg);`
              : `transform: rotateZ(${I}deg); height: calc(25% + 1px)`)
        );
      }
      q.$$.dirty[0] & 32 && (F = g ? 5 : 1),
        q.$$.dirty[0] & 3 &&
          (G =
            S &&
            N &&
            ["getFullYear", "getMonth", "getDate"].every(
              (I) => N[I]() === S[I]()
            )),
        q.$$.dirty[0] & 32 && T(13, (U = v(g ? 260 : 220, 130, "00", !1, 0))),
        q.$$.dirty[0] & 32 &&
          T(12, (H = v(g ? 220 : 140, 130, g ? "00" : "12", g, 12))),
        q.$$.dirty[0] & 32 && m("time-switch", g);
    }),
    [
      S,
      N,
      c,
      p,
      f,
      g,
      y,
      O,
      d,
      M,
      h,
      A,
      H,
      U,
      l,
      o,
      i,
      t,
      e,
      s,
      a,
      Y,
      D,
      u,
      n,
      P,
      b,
      r,
      w,
      L,
    ]
  );
}
class fs extends te {
  constructor(k) {
    super(),
      ee(
        this,
        k,
        gs,
        ps,
        $t,
        {
          date: 21,
          startDate: 0,
          endDate: 1,
          minuteIncrement: 22,
          showMeridian: 2,
          hasDateComponent: 3,
          i18n: 4,
          minuteSwitch: 23,
          makeTick: 24,
        },
        null,
        [-1, -1]
      );
  }
  get minuteSwitch() {
    return this.$$.ctx[23];
  }
  get makeTick() {
    return this.$$.ctx[24];
  }
}
function yi(q) {
  let k, T, y, A, O;
  return {
    c() {
      (k = Mt("input")), this.h();
    },
    l(F) {
      (k = wt(F, "INPUT", {
        type: !0,
        id: !0,
        inputmode: !0,
        tabindex: !0,
        name: !0,
        placeholder: !0,
        autocomplete: !0,
        class: !0,
      })),
        this.h();
    },
    h() {
      dt(k, "type", (T = q[8] ? "hidden" : "text")),
        dt(k, "id", q[3]),
        dt(k, "inputmode", "none"),
        dt(k, "tabindex", "0"),
        dt(k, "name", q[4]),
        (k.disabled = q[5]),
        (k.required = q[7]),
        (k.value = q[1]),
        dt(k, "placeholder", q[6]),
        dt(k, "autocomplete", "off"),
        dt(k, "class", (y = fe(q[14]) + " svelte-1t6pprq")),
        (k.readOnly = q[22]);
    },
    m(F, G) {
      Et(F, k, G),
        q[60](k),
        A ||
          ((O = [
            Si(q[35].call(null, k, q[36])),
            Dt(k, "focus", q[43]),
            Dt(k, "blur", q[44]),
            Dt(k, "click", q[61]),
            Dt(k, "input", q[58]),
            Dt(k, "change", q[59]),
            Dt(k, "keydown", q[40]),
          ]),
          (A = !0));
    },
    p(F, G) {
      G[0] & 256 && T !== (T = F[8] ? "hidden" : "text") && dt(k, "type", T),
        G[0] & 8 && dt(k, "id", F[3]),
        G[0] & 16 && dt(k, "name", F[4]),
        G[0] & 32 && (k.disabled = F[5]),
        G[0] & 128 && (k.required = F[7]),
        G[0] & 2 && k.value !== F[1] && (k.value = F[1]),
        G[0] & 64 && dt(k, "placeholder", F[6]),
        G[0] & 16384 &&
          y !== (y = fe(F[14]) + " svelte-1t6pprq") &&
          dt(k, "class", y),
        G[0] & 4194304 && (k.readOnly = F[22]);
    },
    d(F) {
      F && pt(k), q[60](null), (A = !1), xe(O);
    },
  };
}
function xi(q) {
  let k, T, y, A, O, F, G, U, H;
  const Y = [ys, ms],
    S = [];
  function N(D, c) {
    return D[24] === "date" ? 0 : 1;
  }
  return (
    (T = N(q)),
    (y = S[T] = Y[T](q)),
    {
      c() {
        (k = Mt("div")), y.c(), this.h();
      },
      l(D) {
        k = wt(D, "DIV", { class: !0 });
        var c = vt(k);
        y.l(c), c.forEach(pt), this.h();
      },
      h() {
        dt(
          k,
          "class",
          (A = "std-calendar-wrap is-popup " + q[9] + " svelte-1t6pprq")
        );
      },
      m(D, c) {
        Et(D, k, c),
          S[T].m(k, null),
          (G = !0),
          U ||
            ((H = [
              Si(
                (O = q[20].call(null, k, {
                  inputEl: q[28],
                  visible: q[32],
                  inputRect: q[29],
                }))
              ),
              Dt(k, "mousedown", Kt(q[57])),
            ]),
            (U = !0));
      },
      p(D, c) {
        let p = T;
        (T = N(D)),
          T === p
            ? S[T].p(D, c)
            : (Qt(),
              Bt(S[p], 1, 1, () => {
                S[p] = null;
              }),
              Jt(),
              (y = S[T]),
              y ? y.p(D, c) : ((y = S[T] = Y[T](D)), y.c()),
              Pt(y, 1),
              y.m(k, null)),
          (!G ||
            (c[0] & 512 &&
              A !==
                (A =
                  "std-calendar-wrap is-popup " + D[9] + " svelte-1t6pprq"))) &&
            dt(k, "class", A),
          O &&
            Oi(O.update) &&
            (c[0] & 805306368) | (c[1] & 2) &&
            O.update.call(null, {
              inputEl: D[28],
              visible: D[32],
              inputRect: D[29],
            });
      },
      i(D) {
        G ||
          (Pt(y),
          D &&
            he(() => {
              G && (F || (F = me(k, q[33], { duration: 200 }, !0)), F.run(1));
            }),
          (G = !0));
      },
      o(D) {
        Bt(y),
          D && (F || (F = me(k, q[33], { duration: 200 }, !1)), F.run(0)),
          (G = !1);
      },
      d(D) {
        D && pt(k), S[T].d(), D && F && F.end(), (U = !1), xe(H);
      },
    }
  );
}
function ms(q) {
  let k,
    T,
    y = {
      date: q[21],
      startDate: q[26],
      endDate: q[27],
      hasDateComponent: q[23] !== "time",
      showMeridian: q[10].match(q[11] === "php" ? "a|A" : "p|P") !== null,
      i18n: q[19],
      minuteIncrement: q[12],
    };
  return (
    (k = new fs({ props: y })),
    q[63](k),
    k.$on("time", q[37]),
    k.$on("switch", q[41]),
    k.$on("close", q[42]),
    k.$on("time-switch", q[45]),
    {
      c() {
        oe(k.$$.fragment);
      },
      l(A) {
        ne(k.$$.fragment, A);
      },
      m(A, O) {
        re(k, A, O), (T = !0);
      },
      p(A, O) {
        const F = {};
        O[0] & 2097152 && (F.date = A[21]),
          O[0] & 67108864 && (F.startDate = A[26]),
          O[0] & 134217728 && (F.endDate = A[27]),
          O[0] & 8388608 && (F.hasDateComponent = A[23] !== "time"),
          O[0] & 3072 &&
            (F.showMeridian =
              A[10].match(A[11] === "php" ? "a|A" : "p|P") !== null),
          O[0] & 524288 && (F.i18n = A[19]),
          O[0] & 4096 && (F.minuteIncrement = A[12]),
          k.$set(F);
      },
      i(A) {
        T || (Pt(k.$$.fragment, A), (T = !0));
      },
      o(A) {
        Bt(k.$$.fragment, A), (T = !1);
      },
      d(A) {
        q[63](null), ae(k, A);
      },
    }
  );
}
function ys(q) {
  var G;
  let k,
    T,
    y,
    A,
    O = {
      date: q[21],
      startDate: q[26],
      endDate: q[27],
      enableTimeToggle: (G = q[23]) == null ? void 0 : G.includes("time"),
      initialView: q[2] > 2 ? 2 : q[2],
      i18n: q[19],
      weekStart: q[13],
    };
  (k = new us({ props: O })),
    q[62](k),
    k.$on("date", q[37]),
    k.$on("switch", q[41]);
  let F = (q[17] || q[18]) && vi(q);
  return {
    c() {
      oe(k.$$.fragment), (T = Ot()), F && F.c(), (y = ge());
    },
    l(U) {
      ne(k.$$.fragment, U), (T = Lt(U)), F && F.l(U), (y = ge());
    },
    m(U, H) {
      re(k, U, H), Et(U, T, H), F && F.m(U, H), Et(U, y, H), (A = !0);
    },
    p(U, H) {
      var S;
      const Y = {};
      H[0] & 2097152 && (Y.date = U[21]),
        H[0] & 67108864 && (Y.startDate = U[26]),
        H[0] & 134217728 && (Y.endDate = U[27]),
        H[0] & 8388608 &&
          (Y.enableTimeToggle =
            (S = U[23]) == null ? void 0 : S.includes("time")),
        H[0] & 4 && (Y.initialView = U[2] > 2 ? 2 : U[2]),
        H[0] & 524288 && (Y.i18n = U[19]),
        H[0] & 8192 && (Y.weekStart = U[13]),
        k.$set(Y),
        U[17] || U[18]
          ? F
            ? F.p(U, H)
            : ((F = vi(U)), F.c(), F.m(y.parentNode, y))
          : F && (F.d(1), (F = null));
    },
    i(U) {
      A || (Pt(k.$$.fragment, U), (A = !0));
    },
    o(U) {
      Bt(k.$$.fragment, U), (A = !1);
    },
    d(U) {
      U && (pt(T), pt(y)), q[62](null), ae(k, U), F && F.d(U);
    },
  };
}
function vi(q) {
  let k,
    T,
    y = q[17] && bi(q),
    A = q[18] && ki(q);
  return {
    c() {
      (k = Mt("div")), y && y.c(), (T = Ot()), A && A.c(), this.h();
    },
    l(O) {
      k = wt(O, "DIV", { class: !0 });
      var F = vt(k);
      y && y.l(F), (T = Lt(F)), A && A.l(F), F.forEach(pt), this.h();
    },
    h() {
      dt(k, "class", "std-btn-row svelte-1t6pprq");
    },
    m(O, F) {
      Et(O, k, F), y && y.m(k, null), xt(k, T), A && A.m(k, null);
    },
    p(O, F) {
      O[17]
        ? y
          ? y.p(O, F)
          : ((y = bi(O)), y.c(), y.m(k, T))
        : y && (y.d(1), (y = null)),
        O[18]
          ? A
            ? A.p(O, F)
            : ((A = ki(O)), A.c(), A.m(k, null))
          : A && (A.d(1), (A = null));
    },
    d(O) {
      O && pt(k), y && y.d(), A && A.d();
    },
  };
}
function bi(q) {
  let k,
    T = q[19].todayBtn + "",
    y,
    A,
    O,
    F;
  return {
    c() {
      (k = Mt("button")), (y = jt(T)), this.h();
    },
    l(G) {
      k = wt(G, "BUTTON", { class: !0 });
      var U = vt(k);
      (y = Nt(U, T)), U.forEach(pt), this.h();
    },
    h() {
      dt(k, "class", (A = fe(q[15]) + " svelte-1t6pprq")), (k.disabled = q[34]);
    },
    m(G, U) {
      Et(G, k, U), xt(k, y), O || ((F = Dt(k, "click", q[38])), (O = !0));
    },
    p(G, U) {
      U[0] & 524288 && T !== (T = G[19].todayBtn + "") && Ut(y, T),
        U[0] & 32768 &&
          A !== (A = fe(G[15]) + " svelte-1t6pprq") &&
          dt(k, "class", A),
        U[1] & 8 && (k.disabled = G[34]);
    },
    d(G) {
      G && pt(k), (O = !1), F();
    },
  };
}
function ki(q) {
  let k,
    T = q[19].clearBtn + "",
    y,
    A,
    O,
    F,
    G;
  return {
    c() {
      (k = Mt("button")), (y = jt(T)), this.h();
    },
    l(U) {
      k = wt(U, "BUTTON", { class: !0 });
      var H = vt(k);
      (y = Nt(H, T)), H.forEach(pt), this.h();
    },
    h() {
      dt(k, "class", (A = fe(q[16]) + " svelte-1t6pprq")),
        (k.disabled = O = !q[21]);
    },
    m(U, H) {
      Et(U, k, H), xt(k, y), F || ((G = Dt(k, "click", q[39])), (F = !0));
    },
    p(U, H) {
      H[0] & 524288 && T !== (T = U[19].clearBtn + "") && Ut(y, T),
        H[0] & 65536 &&
          A !== (A = fe(U[16]) + " svelte-1t6pprq") &&
          dt(k, "class", A),
        H[0] & 2097152 && O !== (O = !U[21]) && (k.disabled = O);
    },
    d(U) {
      U && pt(k), (F = !1), G();
    },
  };
}
function xs(q) {
  let k,
    T,
    y,
    A = !q[0] && yi(q),
    O = q[25] && q[22] && xi(q);
  return {
    c() {
      A && A.c(), (k = Ot()), O && O.c(), (T = ge());
    },
    l(F) {
      A && A.l(F), (k = Lt(F)), O && O.l(F), (T = ge());
    },
    m(F, G) {
      A && A.m(F, G), Et(F, k, G), O && O.m(F, G), Et(F, T, G), (y = !0);
    },
    p(F, G) {
      F[0]
        ? A && (A.d(1), (A = null))
        : A
        ? A.p(F, G)
        : ((A = yi(F)), A.c(), A.m(k.parentNode, k)),
        F[25] && F[22]
          ? O
            ? (O.p(F, G), G[0] & 37748736 && Pt(O, 1))
            : ((O = xi(F)), O.c(), Pt(O, 1), O.m(T.parentNode, T))
          : O &&
            (Qt(),
            Bt(O, 1, 1, () => {
              O = null;
            }),
            Jt());
    },
    i(F) {
      y || (Pt(O), (y = !0));
    },
    o(F) {
      Bt(O), (y = !1);
    },
    d(F) {
      F && (pt(k), pt(T)), A && A.d(F), O && O.d(F);
    },
  };
}
const _t = as;
function vs(q, k, T) {
  let y,
    A,
    O,
    F,
    G,
    U,
    { inputId: H = "" } = k,
    { name: Y = "date" } = k,
    { disabled: S = !1 } = k,
    { placeholder: N = null } = k,
    { required: D = !1 } = k,
    { inputElement: c = null } = k,
    { value: p = null } = k,
    { initialDate: f = null } = k,
    { startDate: u = null } = k,
    { endDate: n = null } = k,
    { pickerOnly: d = !1 } = k,
    { startView: g = Xt } = k,
    { theme: M = _t.theme } = k,
    { mode: C = _t.mode } = k,
    { format: P = _t.format } = k,
    { formatType: j = _t.formatType } = k,
    { minuteIncrement: m = _t.minuteIncrement } = k,
    { weekStart: h = _t.weekStart } = k,
    { inputClasses: v = _t.inputClasses } = k,
    { todayBtnClasses: l = _t.todayBtnClasses } = k,
    { clearBtnClasses: o = _t.clearBtnClasses } = k,
    { todayBtn: i = _t.todayBtn } = k,
    { clearBtn: t = _t.clearBtn } = k,
    { clearToggle: e = _t.clearToggle } = k,
    { autoclose: s = _t.autoclose } = k,
    { i18n: a = _t.i18n } = k,
    { positionFn: b = ls } = k,
    { validatorAction: r = null } = k;
  function w(ut) {
    T(21, (x = ve(ut, P, a, j)));
  }
  function L() {
    return rt;
  }
  const I = Ne();
  p && (p = p.replace(/(:\d+):\d+/, "$1"));
  let V = p,
    B = P,
    x = f && f instanceof Date ? f : p ? ve(p, P, a, j) : null;
  x && f && (p = Ee(x, P, a, j));
  let R = d,
    W = c,
    X = null,
    Z = r ? r.shift() : () => {},
    E = r || [],
    _,
    z,
    J = !1,
    tt = null,
    $ = g && g === 3 ? "time" : "",
    it = $ === "time" ? "time" : "date",
    nt = !1,
    rt = null;
  function at() {
    T(2, (g = Xt)),
      (nt = !1),
      d || T(25, (F = !1)),
      $ !== "time" && T(24, (it = "date"));
  }
  function ct(ut) {
    let Tt = ut.detail || null;
    it === "date" ? (rt = "date") : (rt = nt ? "minute" : "hour"),
      ut.detail &&
        x &&
        x.getFullYear() === ut.detail.getFullYear() &&
        x.getMonth() === ut.detail.getMonth() &&
        x.getDate() === ut.detail.getDate() &&
        $ === "date" &&
        e &&
        (Tt = null),
      T(1, (p = Tt ? Ee(Tt, P, a, j) : null)),
      s && ($ === "date" || !Tt) && !d && !J && at(),
      Tt && !J && $ === "datetime" && it === "date" && T(24, (it = "time")),
      J && it === "time"
        ? (tt = setTimeout(() => {
            J = !1;
          }, 400))
        : (J = !1),
      wi().then(() => {
        c && T(0, (c.value = p || ""), c),
          W && W.dispatchEvent(new Event("input")),
          I("change", p);
      });
  }
  function Q() {
    const ut = new Date();
    if (y && y > ut) return;
    const Tt = x ? x.getHours() : ut.getHours(),
      Rt = x ? x.getMinutes() : ut.getMinutes();
    ct(
      new CustomEvent("ontoday", {
        detail: new Date(
          ut.getFullYear(),
          ut.getMonth(),
          ut.getDate(),
          Tt,
          Rt,
          0
        ),
      })
    );
  }
  function K() {
    ct(new CustomEvent("clear", { detail: null }));
  }
  function st(ut) {
    if (
      (F ||
        (["Backspace", "Delete"].includes(ut.key) && K(),
        ut.key === "Enter" && lt()),
      !F && ut.key !== "Tab")
    ) {
      T(25, (F = ut.key !== "Shift")), ut.preventDefault();
      return;
    }
    switch (ut.key) {
      case "PageDown":
      case "PageUp":
      case "ArrowDown":
      case "ArrowUp":
      case "ArrowLeft":
      case "ArrowRight":
        ut.preventDefault(),
          tt && clearTimeout(tt),
          (J = !0),
          it === "date"
            ? _.handleGridNav(ut.key, ut.shiftKey)
            : z.makeTick(
                ["ArrowDown", "ArrowLeft", "PageDown"].includes(ut.key) ? -1 : 1
              );
        break;
      case "Escape":
        R && T(25, (F = !1));
        break;
      case "Backspace":
      case "Delete":
        K();
        break;
      case "Enter":
        if ((R && ut.preventDefault(), it === "time"))
          return z.minuteSwitch(null) ? at() : z.minuteSwitch(!0);
        R && $ === "date" && T(25, (F = !1)),
          x && $.includes("time") && T(24, (it = "time"));
        break;
      case "Tab":
        F && (T(25, (F = !1)), ut.preventDefault());
      case "F5":
        break;
      default:
        ut.preventDefault();
    }
  }
  function et(ut) {
    T(2, (g = Xt)), T(24, (it = ut.detail)), (nt = !1);
  }
  function ot() {
    s && !J && at();
  }
  function lt() {
    T(29, (X = W && W.getBoundingClientRect())),
      T(22, (R = !0)),
      T(25, (F = !0));
  }
  function ht() {
    T(22, (R = !1)), T(25, (F = !1)), !c && I("blur");
  }
  function mt(ut) {
    nt = ut.detail;
  }
  je(() => {
    c &&
      (T(0, (c.onfocus = lt), c),
      T(0, (c.onblur = ht), c),
      T(0, (c.onclick = () => !F && lt()), c),
      T(0, (c.onkeydown = st), c));
  });
  function yt(ut) {
    Te.call(this, q, ut);
  }
  function gt(ut) {
    Te.call(this, q, ut);
  }
  function ft(ut) {
    Te.call(this, q, ut);
  }
  function St(ut) {
    ke[ut ? "unshift" : "push"](() => {
      (W = ut), T(28, W);
    });
  }
  const bt = () => {
    !F && lt();
  };
  function kt(ut) {
    ke[ut ? "unshift" : "push"](() => {
      (_ = ut), T(30, _);
    });
  }
  function Ct(ut) {
    ke[ut ? "unshift" : "push"](() => {
      (z = ut), T(31, z);
    });
  }
  return (
    (q.$$set = (ut) => {
      "inputId" in ut && T(3, (H = ut.inputId)),
        "name" in ut && T(4, (Y = ut.name)),
        "disabled" in ut && T(5, (S = ut.disabled)),
        "placeholder" in ut && T(6, (N = ut.placeholder)),
        "required" in ut && T(7, (D = ut.required)),
        "inputElement" in ut && T(0, (c = ut.inputElement)),
        "value" in ut && T(1, (p = ut.value)),
        "initialDate" in ut && T(46, (f = ut.initialDate)),
        "startDate" in ut && T(47, (u = ut.startDate)),
        "endDate" in ut && T(48, (n = ut.endDate)),
        "pickerOnly" in ut && T(8, (d = ut.pickerOnly)),
        "startView" in ut && T(2, (g = ut.startView)),
        "theme" in ut && T(9, (M = ut.theme)),
        "mode" in ut && T(49, (C = ut.mode)),
        "format" in ut && T(10, (P = ut.format)),
        "formatType" in ut && T(11, (j = ut.formatType)),
        "minuteIncrement" in ut && T(12, (m = ut.minuteIncrement)),
        "weekStart" in ut && T(13, (h = ut.weekStart)),
        "inputClasses" in ut && T(14, (v = ut.inputClasses)),
        "todayBtnClasses" in ut && T(15, (l = ut.todayBtnClasses)),
        "clearBtnClasses" in ut && T(16, (o = ut.clearBtnClasses)),
        "todayBtn" in ut && T(17, (i = ut.todayBtn)),
        "clearBtn" in ut && T(18, (t = ut.clearBtn)),
        "clearToggle" in ut && T(50, (e = ut.clearToggle)),
        "autoclose" in ut && T(51, (s = ut.autoclose)),
        "i18n" in ut && T(19, (a = ut.i18n)),
        "positionFn" in ut && T(20, (b = ut.positionFn)),
        "validatorAction" in ut && T(52, (r = ut.validatorAction));
    }),
    (q.$$.update = () => {
      if (
        ((q.$$.dirty[0] & 527360) | (q.$$.dirty[1] & 65536) &&
          T(26, (y = u ? ve(u, P, a, j) : null)),
        (q.$$.dirty[0] & 527360) | (q.$$.dirty[1] & 131072) &&
          T(27, (A = n ? new Date(ve(n, P, a, j).setSeconds(1)) : null)),
        q.$$.dirty[0] & 201326592 &&
          T(34, (O = (y && y > new Date()) || (A && A < new Date()))),
        q.$$.dirty[0] & 256 && T(25, (F = d)),
        q.$$.dirty[0] & 256 && T(33, (G = d ? () => {} : le)),
        (q.$$.dirty[0] & 25166848) | (q.$$.dirty[1] & 262144) &&
          (T(
            23,
            ($ =
              C === "auto"
                ? P.match(/g|hh?|ii?/i) && P.match(/y|m|d/i)
                  ? "datetime"
                  : P.match(/g|hh?|ii?/i)
                  ? "time"
                  : "date"
                : C)
          ),
          $ === "time" && it !== $ && T(24, (it = $))),
        q.$$.dirty[0] & 4194305 && c && T(0, (c.readOnly = R), c),
        q.$$.dirty[0] & 256 && T(32, (U = !!d)),
        (q.$$.dirty[0] & 2624514) | (q.$$.dirty[1] & 50593792))
      ) {
        if (p !== V) {
          const ut = p ? ve(p, P, a, j) : null;
          T(21, (x = ut)), T(55, (V = p));
        }
        B !== P &&
          x &&
          (T(1, (p = Ee(x, P, a, j))),
          T(55, (V = p)),
          T(56, (B = P)),
          C === "auto" &&
            T(
              23,
              ($ =
                P.match(/g|hh?|ii?/i) && P.match(/y|m|d/i)
                  ? "datetime"
                  : P.match(/g|hh?|ii?/i)
                  ? "time"
                  : "date")
            ));
      }
      q.$$.dirty[0] & 33554432 && (F || (nt = !1));
    }),
    [
      c,
      p,
      g,
      H,
      Y,
      S,
      N,
      D,
      d,
      M,
      P,
      j,
      m,
      h,
      v,
      l,
      o,
      i,
      t,
      a,
      b,
      x,
      R,
      $,
      it,
      F,
      y,
      A,
      W,
      X,
      _,
      z,
      U,
      G,
      O,
      Z,
      E,
      ct,
      Q,
      K,
      st,
      et,
      ot,
      lt,
      ht,
      mt,
      f,
      u,
      n,
      C,
      e,
      s,
      r,
      w,
      L,
      V,
      B,
      yt,
      gt,
      ft,
      St,
      bt,
      kt,
      Ct,
    ]
  );
}
class Ds extends te {
  constructor(k) {
    super(),
      ee(
        this,
        k,
        vs,
        xs,
        $t,
        {
          inputId: 3,
          name: 4,
          disabled: 5,
          placeholder: 6,
          required: 7,
          inputElement: 0,
          value: 1,
          initialDate: 46,
          startDate: 47,
          endDate: 48,
          pickerOnly: 8,
          startView: 2,
          theme: 9,
          mode: 49,
          format: 10,
          formatType: 11,
          minuteIncrement: 12,
          weekStart: 13,
          inputClasses: 14,
          todayBtnClasses: 15,
          clearBtnClasses: 16,
          todayBtn: 17,
          clearBtn: 18,
          clearToggle: 50,
          autoclose: 51,
          i18n: 19,
          positionFn: 20,
          validatorAction: 52,
          setDateValue: 53,
          getLastPickerPhase: 54,
        },
        null,
        [-1, -1, -1]
      );
  }
  get setDateValue() {
    return this.$$.ctx[53];
  }
  get getLastPickerPhase() {
    return this.$$.ctx[54];
  }
}
export { Es as R, Ds as S };
